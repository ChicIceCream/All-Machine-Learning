[
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "generativeai",
        "importPath": "google",
        "description": "google",
        "isExtraImport": true,
        "detail": "google",
        "documentation": {}
    },
    {
        "label": "streamlit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "streamlit",
        "description": "streamlit",
        "detail": "streamlit",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "environ",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "PyPDF2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "PyPDF2",
        "description": "PyPDF2",
        "detail": "PyPDF2",
        "documentation": {}
    },
    {
        "label": "PdfReader",
        "importPath": "PyPDF2",
        "description": "PyPDF2",
        "isExtraImport": true,
        "detail": "PyPDF2",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "TextIOWrapper",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "__all__",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "SEEK_SET",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "SEEK_CUR",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "SEEK_END",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "google.generativeai",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "google.generativeai",
        "description": "google.generativeai",
        "detail": "google.generativeai",
        "documentation": {}
    },
    {
        "label": "pdf2image",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pdf2image",
        "description": "pdf2image",
        "detail": "pdf2image",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "RecursiveCharacterTextSplitter",
        "importPath": "langchain.text_splitter",
        "description": "langchain.text_splitter",
        "isExtraImport": true,
        "detail": "langchain.text_splitter",
        "documentation": {}
    },
    {
        "label": "RecursiveCharacterTextSplitter",
        "importPath": "langchain.text_splitter",
        "description": "langchain.text_splitter",
        "isExtraImport": true,
        "detail": "langchain.text_splitter",
        "documentation": {}
    },
    {
        "label": "ChatGoogleGenerativeAI",
        "importPath": "langchain_google_genai",
        "description": "langchain_google_genai",
        "isExtraImport": true,
        "detail": "langchain_google_genai",
        "documentation": {}
    },
    {
        "label": "GoogleGenerativeAIEmbeddings",
        "importPath": "langchain_google_genai",
        "description": "langchain_google_genai",
        "isExtraImport": true,
        "detail": "langchain_google_genai",
        "documentation": {}
    },
    {
        "label": "GoogleGenerativeAIEmbeddings",
        "importPath": "langchain_google_genai",
        "description": "langchain_google_genai",
        "isExtraImport": true,
        "detail": "langchain_google_genai",
        "documentation": {}
    },
    {
        "label": "load_qa_chain",
        "importPath": "langchain.chains.question_answering",
        "description": "langchain.chains.question_answering",
        "isExtraImport": true,
        "detail": "langchain.chains.question_answering",
        "documentation": {}
    },
    {
        "label": "PromptTemplate",
        "importPath": "langchain.prompts",
        "description": "langchain.prompts",
        "isExtraImport": true,
        "detail": "langchain.prompts",
        "documentation": {}
    },
    {
        "label": "FAISS",
        "importPath": "langchain_community.vectorstores",
        "description": "langchain_community.vectorstores",
        "isExtraImport": true,
        "detail": "langchain_community.vectorstores",
        "documentation": {}
    },
    {
        "label": "FAISS",
        "importPath": "langchain_community.vectorstores",
        "description": "langchain_community.vectorstores",
        "isExtraImport": true,
        "detail": "langchain_community.vectorstores",
        "documentation": {}
    },
    {
        "label": "ChatGroq",
        "importPath": "langchain_groq",
        "description": "langchain_groq",
        "isExtraImport": true,
        "detail": "langchain_groq",
        "documentation": {}
    },
    {
        "label": "create_stuff_documents_chain",
        "importPath": "langchain.chains.combine_documents",
        "description": "langchain.chains.combine_documents",
        "isExtraImport": true,
        "detail": "langchain.chains.combine_documents",
        "documentation": {}
    },
    {
        "label": "ChatPromptTemplate",
        "importPath": "langchain_core.prompts",
        "description": "langchain_core.prompts",
        "isExtraImport": true,
        "detail": "langchain_core.prompts",
        "documentation": {}
    },
    {
        "label": "create_retrieval_chain",
        "importPath": "langchain.chains",
        "description": "langchain.chains",
        "isExtraImport": true,
        "detail": "langchain.chains",
        "documentation": {}
    },
    {
        "label": "PyPDFDirectoryLoader",
        "importPath": "langchain_community.document_loaders",
        "description": "langchain_community.document_loaders",
        "isExtraImport": true,
        "detail": "langchain_community.document_loaders",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "count",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "repeat",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "spacy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "spacy",
        "description": "spacy",
        "detail": "spacy",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "ChainMap",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "collections.abc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections.abc",
        "description": "collections.abc",
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "MutableMapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "concurrent.futures",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "_base",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "_base",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "heapq",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "heapq",
        "description": "heapq",
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "nlargest",
        "importPath": "heapq",
        "description": "heapq",
        "isExtraImport": true,
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "socket",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "socket",
        "description": "socket",
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "stat",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "stat",
        "description": "stat",
        "detail": "stat",
        "documentation": {}
    },
    {
        "label": "ST_MODE",
        "importPath": "stat",
        "description": "stat",
        "isExtraImport": true,
        "detail": "stat",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "Popen",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "PIPE",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "DEVNULL",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "current_thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "RLock",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "getrefcount",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "getrefcount",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "executable",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "maxsize",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "warn",
        "importPath": "warnings",
        "description": "warnings",
        "isExtraImport": true,
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "warn",
        "importPath": "warnings",
        "description": "warnings",
        "isExtraImport": true,
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "weakref",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "weakref",
        "description": "weakref",
        "detail": "weakref",
        "documentation": {}
    },
    {
        "label": "ref",
        "importPath": "weakref",
        "description": "weakref",
        "isExtraImport": true,
        "detail": "weakref",
        "documentation": {}
    },
    {
        "label": "reprlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "reprlib",
        "description": "reprlib",
        "detail": "reprlib",
        "documentation": {}
    },
    {
        "label": "_thread",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_thread",
        "description": "_thread",
        "detail": "_thread",
        "documentation": {}
    },
    {
        "label": "get_ident",
        "importPath": "_thread",
        "description": "_thread",
        "isExtraImport": true,
        "detail": "_thread",
        "documentation": {}
    },
    {
        "label": "allocate_lock",
        "importPath": "_thread",
        "description": "_thread",
        "isExtraImport": true,
        "detail": "_thread",
        "documentation": {}
    },
    {
        "label": "allocate_lock",
        "importPath": "_thread",
        "description": "_thread",
        "isExtraImport": true,
        "detail": "_thread",
        "documentation": {}
    },
    {
        "label": "linecache",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "linecache",
        "description": "linecache",
        "detail": "linecache",
        "documentation": {}
    },
    {
        "label": "enum",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "enum",
        "description": "enum",
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "IntEnum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "CO_GENERATOR",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "CO_COROUTINE",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "CO_ASYNC_GENERATOR",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "types",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "types",
        "description": "types",
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "GenericAlias",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "GenericAlias",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "GenericAlias",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "MethodType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "GenericAlias",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "FunctionType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "GenericAlias",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "GenericAlias",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "GenericAlias",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "contextvars",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextvars",
        "description": "contextvars",
        "detail": "contextvars",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "errno",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "errno",
        "description": "errno",
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "EALREADY",
        "importPath": "errno",
        "description": "errno",
        "isExtraImport": true,
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "EINPROGRESS",
        "importPath": "errno",
        "description": "errno",
        "isExtraImport": true,
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "EWOULDBLOCK",
        "importPath": "errno",
        "description": "errno",
        "isExtraImport": true,
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "ECONNRESET",
        "importPath": "errno",
        "description": "errno",
        "isExtraImport": true,
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "EINVAL",
        "importPath": "errno",
        "description": "errno",
        "isExtraImport": true,
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "errno",
        "description": "errno",
        "isExtraImport": true,
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "selectors",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "selectors",
        "description": "selectors",
        "detail": "selectors",
        "documentation": {}
    },
    {
        "label": "contextlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextlib",
        "description": "contextlib",
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "nullcontext",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "typing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "typing",
        "description": "typing",
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "_overlapped",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_overlapped",
        "description": "_overlapped",
        "detail": "_overlapped",
        "documentation": {}
    },
    {
        "label": "_winapi",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_winapi",
        "description": "_winapi",
        "detail": "_winapi",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "msvcrt",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "msvcrt",
        "description": "msvcrt",
        "detail": "msvcrt",
        "documentation": {}
    },
    {
        "label": "struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct",
        "description": "struct",
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "calcsize",
        "importPath": "struct",
        "description": "struct",
        "isExtraImport": true,
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "_collections_abc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_collections_abc",
        "description": "_collections_abc",
        "detail": "_collections_abc",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "_collections_abc",
        "description": "_collections_abc",
        "isExtraImport": true,
        "detail": "_collections_abc",
        "documentation": {}
    },
    {
        "label": "__all__",
        "importPath": "_collections_abc",
        "description": "_collections_abc",
        "isExtraImport": true,
        "detail": "_collections_abc",
        "documentation": {}
    },
    {
        "label": "_CallableGenericAlias",
        "importPath": "_collections_abc",
        "description": "_collections_abc",
        "isExtraImport": true,
        "detail": "_collections_abc",
        "documentation": {}
    },
    {
        "label": "queue",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "queue",
        "description": "queue",
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "multiprocessing.connection",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "multiprocessing.connection",
        "description": "multiprocessing.connection",
        "detail": "multiprocessing.connection",
        "documentation": {}
    },
    {
        "label": "Queue",
        "importPath": "multiprocessing.queues",
        "description": "multiprocessing.queues",
        "isExtraImport": true,
        "detail": "multiprocessing.queues",
        "documentation": {}
    },
    {
        "label": "framework_info",
        "importPath": "ctypes.macholib.framework",
        "description": "ctypes.macholib.framework",
        "isExtraImport": true,
        "detail": "ctypes.macholib.framework",
        "documentation": {}
    },
    {
        "label": "dylib_info",
        "importPath": "ctypes.macholib.dylib",
        "description": "ctypes.macholib.dylib",
        "isExtraImport": true,
        "detail": "ctypes.macholib.dylib",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "compile",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "IGNORECASE",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "escape",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "test.support",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "test.support",
        "description": "test.support",
        "detail": "test.support",
        "documentation": {}
    },
    {
        "label": "bigmemtest",
        "importPath": "test.support",
        "description": "test.support",
        "isExtraImport": true,
        "detail": "test.support",
        "documentation": {}
    },
    {
        "label": "_2G",
        "importPath": "test.support",
        "description": "test.support",
        "isExtraImport": true,
        "detail": "test.support",
        "documentation": {}
    },
    {
        "label": "os_helper",
        "importPath": "test.support",
        "description": "test.support",
        "isExtraImport": true,
        "detail": "test.support",
        "documentation": {}
    },
    {
        "label": "import_helper",
        "importPath": "test.support",
        "description": "test.support",
        "isExtraImport": true,
        "detail": "test.support",
        "documentation": {}
    },
    {
        "label": "os_helper",
        "importPath": "test.support",
        "description": "test.support",
        "isExtraImport": true,
        "detail": "test.support",
        "documentation": {}
    },
    {
        "label": "ctypes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ctypes",
        "description": "ctypes",
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "_SimpleCData",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "wintypes",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "c_void_p",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "sizeof",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "need_symbol",
        "importPath": "ctypes.test",
        "description": "ctypes.test",
        "isExtraImport": true,
        "detail": "ctypes.test",
        "documentation": {}
    },
    {
        "label": "need_symbol",
        "importPath": "ctypes.test",
        "description": "ctypes.test",
        "isExtraImport": true,
        "detail": "ctypes.test",
        "documentation": {}
    },
    {
        "label": "need_symbol",
        "importPath": "ctypes.test",
        "description": "ctypes.test",
        "isExtraImport": true,
        "detail": "ctypes.test",
        "documentation": {}
    },
    {
        "label": "need_symbol",
        "importPath": "ctypes.test",
        "description": "ctypes.test",
        "isExtraImport": true,
        "detail": "ctypes.test",
        "documentation": {}
    },
    {
        "label": "need_symbol",
        "importPath": "ctypes.test",
        "description": "ctypes.test",
        "isExtraImport": true,
        "detail": "ctypes.test",
        "documentation": {}
    },
    {
        "label": "need_symbol",
        "importPath": "ctypes.test",
        "description": "ctypes.test",
        "isExtraImport": true,
        "detail": "ctypes.test",
        "documentation": {}
    },
    {
        "label": "need_symbol",
        "importPath": "ctypes.test",
        "description": "ctypes.test",
        "isExtraImport": true,
        "detail": "ctypes.test",
        "documentation": {}
    },
    {
        "label": "need_symbol",
        "importPath": "ctypes.test",
        "description": "ctypes.test",
        "isExtraImport": true,
        "detail": "ctypes.test",
        "documentation": {}
    },
    {
        "label": "need_symbol",
        "importPath": "ctypes.test",
        "description": "ctypes.test",
        "isExtraImport": true,
        "detail": "ctypes.test",
        "documentation": {}
    },
    {
        "label": "need_symbol",
        "importPath": "ctypes.test",
        "description": "ctypes.test",
        "isExtraImport": true,
        "detail": "ctypes.test",
        "documentation": {}
    },
    {
        "label": "need_symbol",
        "importPath": "ctypes.test",
        "description": "ctypes.test",
        "isExtraImport": true,
        "detail": "ctypes.test",
        "documentation": {}
    },
    {
        "label": "need_symbol",
        "importPath": "ctypes.test",
        "description": "ctypes.test",
        "isExtraImport": true,
        "detail": "ctypes.test",
        "documentation": {}
    },
    {
        "label": "need_symbol",
        "importPath": "ctypes.test",
        "description": "ctypes.test",
        "isExtraImport": true,
        "detail": "ctypes.test",
        "documentation": {}
    },
    {
        "label": "need_symbol",
        "importPath": "ctypes.test",
        "description": "ctypes.test",
        "isExtraImport": true,
        "detail": "ctypes.test",
        "documentation": {}
    },
    {
        "label": "need_symbol",
        "importPath": "ctypes.test",
        "description": "ctypes.test",
        "isExtraImport": true,
        "detail": "ctypes.test",
        "documentation": {}
    },
    {
        "label": "need_symbol",
        "importPath": "ctypes.test",
        "description": "ctypes.test",
        "isExtraImport": true,
        "detail": "ctypes.test",
        "documentation": {}
    },
    {
        "label": "binascii",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "binascii",
        "description": "binascii",
        "detail": "binascii",
        "documentation": {}
    },
    {
        "label": "hexlify",
        "importPath": "binascii",
        "description": "binascii",
        "isExtraImport": true,
        "detail": "binascii",
        "documentation": {}
    },
    {
        "label": "hexlify",
        "importPath": "binascii",
        "description": "binascii",
        "isExtraImport": true,
        "detail": "binascii",
        "documentation": {}
    },
    {
        "label": "_ctypes_test",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_ctypes_test",
        "description": "_ctypes_test",
        "detail": "_ctypes_test",
        "documentation": {}
    },
    {
        "label": "support",
        "importPath": "test",
        "description": "test",
        "isExtraImport": true,
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "support",
        "importPath": "test",
        "description": "test",
        "isExtraImport": true,
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "support",
        "importPath": "test",
        "description": "test",
        "isExtraImport": true,
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "support",
        "importPath": "test",
        "description": "test",
        "isExtraImport": true,
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "support",
        "importPath": "test",
        "description": "test",
        "isExtraImport": true,
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "support",
        "importPath": "test",
        "description": "test",
        "isExtraImport": true,
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "support",
        "importPath": "test",
        "description": "test",
        "isExtraImport": true,
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "support",
        "importPath": "test",
        "description": "test",
        "isExtraImport": true,
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "support",
        "importPath": "test",
        "description": "test",
        "isExtraImport": true,
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "sys,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys.",
        "description": "sys.",
        "detail": "sys.",
        "documentation": {}
    },
    {
        "label": "unittest,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest.",
        "description": "unittest.",
        "detail": "unittest.",
        "documentation": {}
    },
    {
        "label": "find_library",
        "importPath": "ctypes.util",
        "description": "ctypes.util",
        "isExtraImport": true,
        "detail": "ctypes.util",
        "documentation": {}
    },
    {
        "label": "find_library",
        "importPath": "ctypes.util",
        "description": "ctypes.util",
        "isExtraImport": true,
        "detail": "ctypes.util",
        "documentation": {}
    },
    {
        "label": "find_library",
        "importPath": "ctypes.util",
        "description": "ctypes.util",
        "isExtraImport": true,
        "detail": "ctypes.util",
        "documentation": {}
    },
    {
        "label": "unittest.mock",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "os.path",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.path",
        "description": "os.path",
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "array",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "array",
        "description": "array",
        "detail": "array",
        "documentation": {}
    },
    {
        "label": "gc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gc",
        "description": "gc",
        "detail": "gc",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "dyld_find",
        "importPath": "ctypes.macholib.dyld",
        "description": "ctypes.macholib.dyld",
        "isExtraImport": true,
        "detail": "ctypes.macholib.dyld",
        "documentation": {}
    },
    {
        "label": "ctypes.test.test_objects",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ctypes.test.test_objects",
        "description": "ctypes.test.test_objects",
        "detail": "ctypes.test.test_objects",
        "documentation": {}
    },
    {
        "label": "re,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re.",
        "description": "re.",
        "detail": "re.",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "PyObj_FromPtr",
        "importPath": "_ctypes",
        "description": "_ctypes",
        "isExtraImport": true,
        "detail": "_ctypes",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "_curses",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_curses",
        "description": "_curses",
        "detail": "_curses",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "_curses_panel",
        "description": "_curses_panel",
        "isExtraImport": true,
        "detail": "_curses_panel",
        "documentation": {}
    },
    {
        "label": "curses",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "curses",
        "description": "curses",
        "detail": "curses",
        "documentation": {}
    },
    {
        "label": "curses.ascii",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "curses.ascii",
        "description": "curses.ascii",
        "detail": "curses.ascii",
        "documentation": {}
    },
    {
        "label": "ast",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ast",
        "description": "ast",
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "_gdbm",
        "description": "_gdbm",
        "isExtraImport": true,
        "detail": "_gdbm",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "_dbm",
        "description": "_dbm",
        "isExtraImport": true,
        "detail": "_dbm",
        "documentation": {}
    },
    {
        "label": "Command",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "Command",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "Command",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "Command",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "Command",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "Command",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "Command",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "Command",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "Command",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "Command",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "Command",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "distutils.errors",
        "description": "distutils.errors",
        "isExtraImport": true,
        "detail": "distutils.errors",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "distutils.errors",
        "description": "distutils.errors",
        "isExtraImport": true,
        "detail": "distutils.errors",
        "documentation": {}
    },
    {
        "label": "DistutilsOptionError",
        "importPath": "distutils.errors",
        "description": "distutils.errors",
        "isExtraImport": true,
        "detail": "distutils.errors",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "distutils.errors",
        "description": "distutils.errors",
        "isExtraImport": true,
        "detail": "distutils.errors",
        "documentation": {}
    },
    {
        "label": "DistutilsOptionError",
        "importPath": "distutils.errors",
        "description": "distutils.errors",
        "isExtraImport": true,
        "detail": "distutils.errors",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "distutils.errors",
        "description": "distutils.errors",
        "isExtraImport": true,
        "detail": "distutils.errors",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "distutils.errors",
        "description": "distutils.errors",
        "isExtraImport": true,
        "detail": "distutils.errors",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "distutils.errors",
        "description": "distutils.errors",
        "isExtraImport": true,
        "detail": "distutils.errors",
        "documentation": {}
    },
    {
        "label": "DistutilsSetupError",
        "importPath": "distutils.errors",
        "description": "distutils.errors",
        "isExtraImport": true,
        "detail": "distutils.errors",
        "documentation": {}
    },
    {
        "label": "DistutilsExecError",
        "importPath": "distutils.errors",
        "description": "distutils.errors",
        "isExtraImport": true,
        "detail": "distutils.errors",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "distutils.errors",
        "description": "distutils.errors",
        "isExtraImport": true,
        "detail": "distutils.errors",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "distutils.errors",
        "description": "distutils.errors",
        "isExtraImport": true,
        "detail": "distutils.errors",
        "documentation": {}
    },
    {
        "label": "DistutilsOptionError",
        "importPath": "distutils.errors",
        "description": "distutils.errors",
        "isExtraImport": true,
        "detail": "distutils.errors",
        "documentation": {}
    },
    {
        "label": "DistutilsExecError",
        "importPath": "distutils.errors",
        "description": "distutils.errors",
        "isExtraImport": true,
        "detail": "distutils.errors",
        "documentation": {}
    },
    {
        "label": "DistutilsPlatformError",
        "importPath": "distutils.errors",
        "description": "distutils.errors",
        "isExtraImport": true,
        "detail": "distutils.errors",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "distutils.errors",
        "description": "distutils.errors",
        "isExtraImport": true,
        "detail": "distutils.errors",
        "documentation": {}
    },
    {
        "label": "get_platform",
        "importPath": "distutils.util",
        "description": "distutils.util",
        "isExtraImport": true,
        "detail": "distutils.util",
        "documentation": {}
    },
    {
        "label": "get_platform",
        "importPath": "distutils.util",
        "description": "distutils.util",
        "isExtraImport": true,
        "detail": "distutils.util",
        "documentation": {}
    },
    {
        "label": "get_platform",
        "importPath": "distutils.util",
        "description": "distutils.util",
        "isExtraImport": true,
        "detail": "distutils.util",
        "documentation": {}
    },
    {
        "label": "get_platform",
        "importPath": "distutils.util",
        "description": "distutils.util",
        "isExtraImport": true,
        "detail": "distutils.util",
        "documentation": {}
    },
    {
        "label": "get_platform",
        "importPath": "distutils.util",
        "description": "distutils.util",
        "isExtraImport": true,
        "detail": "distutils.util",
        "documentation": {}
    },
    {
        "label": "convert_path",
        "importPath": "distutils.util",
        "description": "distutils.util",
        "isExtraImport": true,
        "detail": "distutils.util",
        "documentation": {}
    },
    {
        "label": "Mixin2to3",
        "importPath": "distutils.util",
        "description": "distutils.util",
        "isExtraImport": true,
        "detail": "distutils.util",
        "documentation": {}
    },
    {
        "label": "convert_path",
        "importPath": "distutils.util",
        "description": "distutils.util",
        "isExtraImport": true,
        "detail": "distutils.util",
        "documentation": {}
    },
    {
        "label": "Mixin2to3",
        "importPath": "distutils.util",
        "description": "distutils.util",
        "isExtraImport": true,
        "detail": "distutils.util",
        "documentation": {}
    },
    {
        "label": "split_quoted",
        "importPath": "distutils.util",
        "description": "distutils.util",
        "isExtraImport": true,
        "detail": "distutils.util",
        "documentation": {}
    },
    {
        "label": "execute",
        "importPath": "distutils.util",
        "description": "distutils.util",
        "isExtraImport": true,
        "detail": "distutils.util",
        "documentation": {}
    },
    {
        "label": "get_platform",
        "importPath": "distutils.util",
        "description": "distutils.util",
        "isExtraImport": true,
        "detail": "distutils.util",
        "documentation": {}
    },
    {
        "label": "remove_tree",
        "importPath": "distutils.dir_util",
        "description": "distutils.dir_util",
        "isExtraImport": true,
        "detail": "distutils.dir_util",
        "documentation": {}
    },
    {
        "label": "ensure_relative",
        "importPath": "distutils.dir_util",
        "description": "distutils.dir_util",
        "isExtraImport": true,
        "detail": "distutils.dir_util",
        "documentation": {}
    },
    {
        "label": "remove_tree",
        "importPath": "distutils.dir_util",
        "description": "distutils.dir_util",
        "isExtraImport": true,
        "detail": "distutils.dir_util",
        "documentation": {}
    },
    {
        "label": "remove_tree",
        "importPath": "distutils.dir_util",
        "description": "distutils.dir_util",
        "isExtraImport": true,
        "detail": "distutils.dir_util",
        "documentation": {}
    },
    {
        "label": "mkpath",
        "importPath": "distutils.dir_util",
        "description": "distutils.dir_util",
        "isExtraImport": true,
        "detail": "distutils.dir_util",
        "documentation": {}
    },
    {
        "label": "mkpath",
        "importPath": "distutils.dir_util",
        "description": "distutils.dir_util",
        "isExtraImport": true,
        "detail": "distutils.dir_util",
        "documentation": {}
    },
    {
        "label": "get_python_version",
        "importPath": "distutils.sysconfig",
        "description": "distutils.sysconfig",
        "isExtraImport": true,
        "detail": "distutils.sysconfig",
        "documentation": {}
    },
    {
        "label": "get_python_version",
        "importPath": "distutils.sysconfig",
        "description": "distutils.sysconfig",
        "isExtraImport": true,
        "detail": "distutils.sysconfig",
        "documentation": {}
    },
    {
        "label": "get_python_version",
        "importPath": "distutils.sysconfig",
        "description": "distutils.sysconfig",
        "isExtraImport": true,
        "detail": "distutils.sysconfig",
        "documentation": {}
    },
    {
        "label": "customize_compiler",
        "importPath": "distutils.sysconfig",
        "description": "distutils.sysconfig",
        "isExtraImport": true,
        "detail": "distutils.sysconfig",
        "documentation": {}
    },
    {
        "label": "customize_compiler",
        "importPath": "distutils.sysconfig",
        "description": "distutils.sysconfig",
        "isExtraImport": true,
        "detail": "distutils.sysconfig",
        "documentation": {}
    },
    {
        "label": "get_python_version",
        "importPath": "distutils.sysconfig",
        "description": "distutils.sysconfig",
        "isExtraImport": true,
        "detail": "distutils.sysconfig",
        "documentation": {}
    },
    {
        "label": "get_config_h_filename",
        "importPath": "distutils.sysconfig",
        "description": "distutils.sysconfig",
        "isExtraImport": true,
        "detail": "distutils.sysconfig",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "distutils",
        "description": "distutils",
        "isExtraImport": true,
        "detail": "distutils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "distutils",
        "description": "distutils",
        "isExtraImport": true,
        "detail": "distutils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "distutils",
        "description": "distutils",
        "isExtraImport": true,
        "detail": "distutils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "distutils",
        "description": "distutils",
        "isExtraImport": true,
        "detail": "distutils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "distutils",
        "description": "distutils",
        "isExtraImport": true,
        "detail": "distutils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "distutils",
        "description": "distutils",
        "isExtraImport": true,
        "detail": "distutils",
        "documentation": {}
    },
    {
        "label": "sysconfig",
        "importPath": "distutils",
        "description": "distutils",
        "isExtraImport": true,
        "detail": "distutils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "distutils",
        "description": "distutils",
        "isExtraImport": true,
        "detail": "distutils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "distutils",
        "description": "distutils",
        "isExtraImport": true,
        "detail": "distutils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "distutils",
        "description": "distutils",
        "isExtraImport": true,
        "detail": "distutils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "distutils",
        "description": "distutils",
        "isExtraImport": true,
        "detail": "distutils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "distutils",
        "description": "distutils",
        "isExtraImport": true,
        "detail": "distutils",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "distutils",
        "description": "distutils",
        "isExtraImport": true,
        "detail": "distutils",
        "documentation": {}
    },
    {
        "label": "dir_util",
        "importPath": "distutils",
        "description": "distutils",
        "isExtraImport": true,
        "detail": "distutils",
        "documentation": {}
    },
    {
        "label": "file_util",
        "importPath": "distutils",
        "description": "distutils",
        "isExtraImport": true,
        "detail": "distutils",
        "documentation": {}
    },
    {
        "label": "archive_util",
        "importPath": "distutils",
        "description": "distutils",
        "isExtraImport": true,
        "detail": "distutils",
        "documentation": {}
    },
    {
        "label": "dep_util",
        "importPath": "distutils",
        "description": "distutils",
        "isExtraImport": true,
        "detail": "distutils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "distutils",
        "description": "distutils",
        "isExtraImport": true,
        "detail": "distutils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "distutils",
        "description": "distutils",
        "isExtraImport": true,
        "detail": "distutils",
        "documentation": {}
    },
    {
        "label": "StrictVersion",
        "importPath": "distutils.version",
        "description": "distutils.version",
        "isExtraImport": true,
        "detail": "distutils.version",
        "documentation": {}
    },
    {
        "label": "msilib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "msilib",
        "description": "msilib",
        "detail": "msilib",
        "documentation": {}
    },
    {
        "label": "schema",
        "importPath": "msilib",
        "description": "msilib",
        "isExtraImport": true,
        "detail": "msilib",
        "documentation": {}
    },
    {
        "label": "sequence",
        "importPath": "msilib",
        "description": "msilib",
        "isExtraImport": true,
        "detail": "msilib",
        "documentation": {}
    },
    {
        "label": "text",
        "importPath": "msilib",
        "description": "msilib",
        "isExtraImport": true,
        "detail": "msilib",
        "documentation": {}
    },
    {
        "label": "Directory",
        "importPath": "msilib",
        "description": "msilib",
        "isExtraImport": true,
        "detail": "msilib",
        "documentation": {}
    },
    {
        "label": "Feature",
        "importPath": "msilib",
        "description": "msilib",
        "isExtraImport": true,
        "detail": "msilib",
        "documentation": {}
    },
    {
        "label": "Dialog",
        "importPath": "msilib",
        "description": "msilib",
        "isExtraImport": true,
        "detail": "msilib",
        "documentation": {}
    },
    {
        "label": "add_data",
        "importPath": "msilib",
        "description": "msilib",
        "isExtraImport": true,
        "detail": "msilib",
        "documentation": {}
    },
    {
        "label": "subprocess,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess.",
        "description": "subprocess.",
        "detail": "subprocess.",
        "documentation": {}
    },
    {
        "label": "DEBUG",
        "importPath": "distutils.debug",
        "description": "distutils.debug",
        "isExtraImport": true,
        "detail": "distutils.debug",
        "documentation": {}
    },
    {
        "label": "write_file",
        "importPath": "distutils.file_util",
        "description": "distutils.file_util",
        "isExtraImport": true,
        "detail": "distutils.file_util",
        "documentation": {}
    },
    {
        "label": "write_file",
        "importPath": "distutils.file_util",
        "description": "distutils.file_util",
        "isExtraImport": true,
        "detail": "distutils.file_util",
        "documentation": {}
    },
    {
        "label": "move_file",
        "importPath": "distutils.file_util",
        "description": "distutils.file_util",
        "isExtraImport": true,
        "detail": "distutils.file_util",
        "documentation": {}
    },
    {
        "label": "newer_group",
        "importPath": "distutils.dep_util",
        "description": "distutils.dep_util",
        "isExtraImport": true,
        "detail": "distutils.dep_util",
        "documentation": {}
    },
    {
        "label": "newer",
        "importPath": "distutils.dep_util",
        "description": "distutils.dep_util",
        "isExtraImport": true,
        "detail": "distutils.dep_util",
        "documentation": {}
    },
    {
        "label": "newer",
        "importPath": "distutils.dep_util",
        "description": "distutils.dep_util",
        "isExtraImport": true,
        "detail": "distutils.dep_util",
        "documentation": {}
    },
    {
        "label": "newer_group",
        "importPath": "distutils.dep_util",
        "description": "distutils.dep_util",
        "isExtraImport": true,
        "detail": "distutils.dep_util",
        "documentation": {}
    },
    {
        "label": "Extension",
        "importPath": "distutils.extension",
        "description": "distutils.extension",
        "isExtraImport": true,
        "detail": "distutils.extension",
        "documentation": {}
    },
    {
        "label": "USER_BASE",
        "importPath": "site",
        "description": "site",
        "isExtraImport": true,
        "detail": "site",
        "documentation": {}
    },
    {
        "label": "importlib.util",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib.util",
        "description": "importlib.util",
        "detail": "importlib.util",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "os,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.",
        "description": "os.",
        "detail": "os.",
        "documentation": {}
    },
    {
        "label": "tokenize",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tokenize",
        "description": "tokenize",
        "detail": "tokenize",
        "documentation": {}
    },
    {
        "label": "spawn",
        "importPath": "distutils.spawn",
        "description": "distutils.spawn",
        "isExtraImport": true,
        "detail": "distutils.spawn",
        "documentation": {}
    },
    {
        "label": "spawn",
        "importPath": "distutils.spawn",
        "description": "distutils.spawn",
        "isExtraImport": true,
        "detail": "distutils.spawn",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "distutils.ccompiler",
        "description": "distutils.ccompiler",
        "isExtraImport": true,
        "detail": "distutils.ccompiler",
        "documentation": {}
    },
    {
        "label": "CCompiler",
        "importPath": "distutils.ccompiler",
        "description": "distutils.ccompiler",
        "isExtraImport": true,
        "detail": "distutils.ccompiler",
        "documentation": {}
    },
    {
        "label": "gen_lib_options",
        "importPath": "distutils.ccompiler",
        "description": "distutils.ccompiler",
        "isExtraImport": true,
        "detail": "distutils.ccompiler",
        "documentation": {}
    },
    {
        "label": "winreg",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "winreg",
        "description": "winreg",
        "detail": "winreg",
        "documentation": {}
    },
    {
        "label": "builtins",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "builtins",
        "description": "builtins",
        "detail": "builtins",
        "documentation": {}
    },
    {
        "label": "open",
        "importPath": "builtins",
        "description": "builtins",
        "isExtraImport": true,
        "detail": "builtins",
        "documentation": {}
    },
    {
        "label": "Chunk",
        "importPath": "chunk",
        "description": "chunk",
        "isExtraImport": true,
        "detail": "chunk",
        "documentation": {}
    },
    {
        "label": "webbrowser",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "webbrowser",
        "description": "webbrowser",
        "detail": "webbrowser",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "gettext",
        "importPath": "gettext",
        "description": "gettext",
        "isExtraImport": true,
        "detail": "gettext",
        "documentation": {}
    },
    {
        "label": "ngettext",
        "importPath": "gettext",
        "description": "gettext",
        "isExtraImport": true,
        "detail": "gettext",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "_ast",
        "description": "_ast",
        "isExtraImport": true,
        "detail": "_ast",
        "documentation": {}
    },
    {
        "label": "asyncore",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncore",
        "description": "asyncore",
        "detail": "asyncore",
        "documentation": {}
    },
    {
        "label": "select",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "select",
        "description": "select",
        "detail": "select",
        "documentation": {}
    },
    {
        "label": "fnmatch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "fnmatch",
        "description": "fnmatch",
        "detail": "fnmatch",
        "documentation": {}
    },
    {
        "label": "_compression",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_compression",
        "description": "_compression",
        "detail": "_compression",
        "documentation": {}
    },
    {
        "label": "BZ2Compressor",
        "importPath": "_bz2",
        "description": "_bz2",
        "isExtraImport": true,
        "detail": "_bz2",
        "documentation": {}
    },
    {
        "label": "BZ2Decompressor",
        "importPath": "_bz2",
        "description": "_bz2",
        "isExtraImport": true,
        "detail": "_bz2",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "date",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "locale",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "locale",
        "description": "locale",
        "detail": "locale",
        "documentation": {}
    },
    {
        "label": "urllib.parse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "FeedParser",
        "importPath": "email.parser",
        "description": "email.parser",
        "isExtraImport": true,
        "detail": "email.parser",
        "documentation": {}
    },
    {
        "label": "Message",
        "importPath": "email.message",
        "description": "email.message",
        "isExtraImport": true,
        "detail": "email.message",
        "documentation": {}
    },
    {
        "label": "html",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "html",
        "description": "html",
        "detail": "html",
        "documentation": {}
    },
    {
        "label": "keyword",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "keyword",
        "description": "keyword",
        "detail": "keyword",
        "documentation": {}
    },
    {
        "label": "pydoc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pydoc",
        "description": "pydoc",
        "detail": "pydoc",
        "documentation": {}
    },
    {
        "label": "string,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string.",
        "description": "string.",
        "detail": "string.",
        "documentation": {}
    },
    {
        "label": "CommandCompiler",
        "importPath": "codeop",
        "description": "codeop",
        "isExtraImport": true,
        "detail": "codeop",
        "documentation": {}
    },
    {
        "label": "compile_command",
        "importPath": "codeop",
        "description": "codeop",
        "isExtraImport": true,
        "detail": "codeop",
        "documentation": {}
    },
    {
        "label": "__future__",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "__future__",
        "description": "__future__",
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "py_compile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "py_compile",
        "description": "py_compile",
        "detail": "py_compile",
        "documentation": {}
    },
    {
        "label": "filecmp",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "filecmp",
        "description": "filecmp",
        "detail": "filecmp",
        "documentation": {}
    },
    {
        "label": "pathlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pathlib",
        "description": "pathlib",
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "abc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "abc",
        "description": "abc",
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABCMeta",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "Context",
        "importPath": "_contextvars",
        "description": "_contextvars",
        "isExtraImport": true,
        "detail": "_contextvars",
        "documentation": {}
    },
    {
        "label": "ContextVar",
        "importPath": "_contextvars",
        "description": "_contextvars",
        "isExtraImport": true,
        "detail": "_contextvars",
        "documentation": {}
    },
    {
        "label": "Token",
        "importPath": "_contextvars",
        "description": "_contextvars",
        "isExtraImport": true,
        "detail": "_contextvars",
        "documentation": {}
    },
    {
        "label": "copy_context",
        "importPath": "_contextvars",
        "description": "_contextvars",
        "isExtraImport": true,
        "detail": "_contextvars",
        "documentation": {}
    },
    {
        "label": "dispatch_table",
        "importPath": "copyreg",
        "description": "copyreg",
        "isExtraImport": true,
        "detail": "copyreg",
        "documentation": {}
    },
    {
        "label": "_lsprof",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_lsprof",
        "description": "_lsprof",
        "detail": "_lsprof",
        "documentation": {}
    },
    {
        "label": "profile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "profile",
        "description": "profile",
        "detail": "profile",
        "documentation": {}
    },
    {
        "label": "SystemRandom",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "Error",
        "importPath": "_csv",
        "description": "_csv",
        "isExtraImport": true,
        "detail": "_csv",
        "documentation": {}
    },
    {
        "label": "__version__",
        "importPath": "_csv",
        "description": "_csv",
        "isExtraImport": true,
        "detail": "_csv",
        "documentation": {}
    },
    {
        "label": "writer",
        "importPath": "_csv",
        "description": "_csv",
        "isExtraImport": true,
        "detail": "_csv",
        "documentation": {}
    },
    {
        "label": "reader",
        "importPath": "_csv",
        "description": "_csv",
        "isExtraImport": true,
        "detail": "_csv",
        "documentation": {}
    },
    {
        "label": "register_dialect",
        "importPath": "_csv",
        "description": "_csv",
        "isExtraImport": true,
        "detail": "_csv",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "_csv",
        "description": "_csv",
        "isExtraImport": true,
        "detail": "_csv",
        "documentation": {}
    },
    {
        "label": "Dialect",
        "importPath": "_csv",
        "description": "_csv",
        "isExtraImport": true,
        "detail": "_csv",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "index",
        "importPath": "operator",
        "description": "operator",
        "isExtraImport": true,
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "opcode",
        "description": "opcode",
        "isExtraImport": true,
        "detail": "opcode",
        "documentation": {}
    },
    {
        "label": "__all__",
        "importPath": "opcode",
        "description": "opcode",
        "isExtraImport": true,
        "detail": "opcode",
        "documentation": {}
    },
    {
        "label": "sysconfig",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sysconfig",
        "description": "sysconfig",
        "detail": "sysconfig",
        "documentation": {}
    },
    {
        "label": "numbers",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numbers",
        "description": "numbers",
        "detail": "numbers",
        "documentation": {}
    },
    {
        "label": "codecs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "codecs",
        "description": "codecs",
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "FileIO",
        "importPath": "_io",
        "description": "_io",
        "isExtraImport": true,
        "detail": "_io",
        "documentation": {}
    },
    {
        "label": "WeakSet",
        "importPath": "_weakrefset",
        "description": "_weakrefset",
        "isExtraImport": true,
        "detail": "_weakrefset",
        "documentation": {}
    },
    {
        "label": "calendar",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "calendar",
        "description": "calendar",
        "detail": "calendar",
        "documentation": {}
    },
    {
        "label": "ref",
        "importPath": "_weakref",
        "description": "_weakref",
        "isExtraImport": true,
        "detail": "_weakref",
        "documentation": {}
    },
    {
        "label": "sqlite3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlite3",
        "description": "sqlite3",
        "detail": "sqlite3",
        "documentation": {}
    },
    {
        "label": "YouTubeTranscriptApi",
        "importPath": "youtube_transcript_api",
        "description": "youtube_transcript_api",
        "isExtraImport": true,
        "detail": "youtube_transcript_api",
        "documentation": {}
    },
    {
        "label": "get_gemini_response",
        "kind": 2,
        "importPath": "ATS Modofied Resume Review.app",
        "description": "ATS Modofied Resume Review.app",
        "peekOfCode": "def get_gemini_response(input, resume, prompt):\n    # Define my model here as flash model \n    model = genai.GenerativeModel(\"gemini-1.5-flash\")\n    # calling my model\n    response = model.generate_content([input, resume, prompt])\n    return response.text\ndef input_pdf_text(uploaded_file):\n    reader = pdf.PdfReader(uploaded_file)\n    text = \"\"\n    for page in reader.pages:",
        "detail": "ATS Modofied Resume Review.app",
        "documentation": {}
    },
    {
        "label": "input_pdf_text",
        "kind": 2,
        "importPath": "ATS Modofied Resume Review.app",
        "description": "ATS Modofied Resume Review.app",
        "peekOfCode": "def input_pdf_text(uploaded_file):\n    reader = pdf.PdfReader(uploaded_file)\n    text = \"\"\n    for page in reader.pages:\n        text += page.extract_text()\n    return text\nanalyze_prompt = '''\n\"Analyze the content of my resume. Provide a detailed breakdown of my strengths, key skills, and qualifications, based on the information in the resume. Highlight the areas where I stand out, and how my experience aligns with general industry standards.\"\n'''\nimprovement_prompt = '''",
        "detail": "ATS Modofied Resume Review.app",
        "documentation": {}
    },
    {
        "label": "analyze_prompt",
        "kind": 5,
        "importPath": "ATS Modofied Resume Review.app",
        "description": "ATS Modofied Resume Review.app",
        "peekOfCode": "analyze_prompt = '''\n\"Analyze the content of my resume. Provide a detailed breakdown of my strengths, key skills, and qualifications, based on the information in the resume. Highlight the areas where I stand out, and how my experience aligns with general industry standards.\"\n'''\nimprovement_prompt = '''\nReview my resume and suggest specific improvements to make it more effective. Identify gaps in skills, experience, or presentation that could enhance my chances in the job market. Provide actionable recommendations for better structure, clarity, or any other areas that can be optimized.\n'''\nkeyword_prompt = '''\nScan my resume for important keywords and industry-specific terms related to my field or target job description. Identify any crucial keywords or phrases that are missing and explain how incorporating them could make my resume more attractive to potential employers and Applicant Tracking Systems (ATS).\n'''\npercentage_prompt = '''",
        "detail": "ATS Modofied Resume Review.app",
        "documentation": {}
    },
    {
        "label": "improvement_prompt",
        "kind": 5,
        "importPath": "ATS Modofied Resume Review.app",
        "description": "ATS Modofied Resume Review.app",
        "peekOfCode": "improvement_prompt = '''\nReview my resume and suggest specific improvements to make it more effective. Identify gaps in skills, experience, or presentation that could enhance my chances in the job market. Provide actionable recommendations for better structure, clarity, or any other areas that can be optimized.\n'''\nkeyword_prompt = '''\nScan my resume for important keywords and industry-specific terms related to my field or target job description. Identify any crucial keywords or phrases that are missing and explain how incorporating them could make my resume more attractive to potential employers and Applicant Tracking Systems (ATS).\n'''\npercentage_prompt = '''\nCompare my resume to the provided job description and calculate a percentage match. Analyze how well my skills, experience, and qualifications align with the requirements of the job. Highlight the areas where I meet the criteria and those where I fall short, with suggestions to improve alignment\n'''\n## Streamlit app",
        "detail": "ATS Modofied Resume Review.app",
        "documentation": {}
    },
    {
        "label": "keyword_prompt",
        "kind": 5,
        "importPath": "ATS Modofied Resume Review.app",
        "description": "ATS Modofied Resume Review.app",
        "peekOfCode": "keyword_prompt = '''\nScan my resume for important keywords and industry-specific terms related to my field or target job description. Identify any crucial keywords or phrases that are missing and explain how incorporating them could make my resume more attractive to potential employers and Applicant Tracking Systems (ATS).\n'''\npercentage_prompt = '''\nCompare my resume to the provided job description and calculate a percentage match. Analyze how well my skills, experience, and qualifications align with the requirements of the job. Highlight the areas where I meet the criteria and those where I fall short, with suggestions to improve alignment\n'''\n## Streamlit app\nst.title(\"ATS Resume Reviewer\")\nst.text(\"Improve your resume\")\njd = st.text_area(\"Paste the job description over here\")",
        "detail": "ATS Modofied Resume Review.app",
        "documentation": {}
    },
    {
        "label": "percentage_prompt",
        "kind": 5,
        "importPath": "ATS Modofied Resume Review.app",
        "description": "ATS Modofied Resume Review.app",
        "peekOfCode": "percentage_prompt = '''\nCompare my resume to the provided job description and calculate a percentage match. Analyze how well my skills, experience, and qualifications align with the requirements of the job. Highlight the areas where I meet the criteria and those where I fall short, with suggestions to improve alignment\n'''\n## Streamlit app\nst.title(\"ATS Resume Reviewer\")\nst.text(\"Improve your resume\")\njd = st.text_area(\"Paste the job description over here\")\nuploaded_file = st.file_uploader(\"Upload your resume here\", type=\"pdf\")\nsubmit1 = st.button(\"Tell me about my resume\")\nsubmit2 = st.button(\"How can I improve?\")",
        "detail": "ATS Modofied Resume Review.app",
        "documentation": {}
    },
    {
        "label": "jd",
        "kind": 5,
        "importPath": "ATS Modofied Resume Review.app",
        "description": "ATS Modofied Resume Review.app",
        "peekOfCode": "jd = st.text_area(\"Paste the job description over here\")\nuploaded_file = st.file_uploader(\"Upload your resume here\", type=\"pdf\")\nsubmit1 = st.button(\"Tell me about my resume\")\nsubmit2 = st.button(\"How can I improve?\")\nsubmit3 = st.button(\"Missing keywords?\")\nsubmit4 = st.button(\"Percentage Match to job description\")\nif submit1:\n    if uploaded_file is not None:\n        pdf_text = input_pdf_text(uploaded_file)\n        response = get_gemini_response(jd, pdf_text, analyze_prompt)",
        "detail": "ATS Modofied Resume Review.app",
        "documentation": {}
    },
    {
        "label": "uploaded_file",
        "kind": 5,
        "importPath": "ATS Modofied Resume Review.app",
        "description": "ATS Modofied Resume Review.app",
        "peekOfCode": "uploaded_file = st.file_uploader(\"Upload your resume here\", type=\"pdf\")\nsubmit1 = st.button(\"Tell me about my resume\")\nsubmit2 = st.button(\"How can I improve?\")\nsubmit3 = st.button(\"Missing keywords?\")\nsubmit4 = st.button(\"Percentage Match to job description\")\nif submit1:\n    if uploaded_file is not None:\n        pdf_text = input_pdf_text(uploaded_file)\n        response = get_gemini_response(jd, pdf_text, analyze_prompt)\n        st.subheader(\"The Response is : \")",
        "detail": "ATS Modofied Resume Review.app",
        "documentation": {}
    },
    {
        "label": "submit1",
        "kind": 5,
        "importPath": "ATS Modofied Resume Review.app",
        "description": "ATS Modofied Resume Review.app",
        "peekOfCode": "submit1 = st.button(\"Tell me about my resume\")\nsubmit2 = st.button(\"How can I improve?\")\nsubmit3 = st.button(\"Missing keywords?\")\nsubmit4 = st.button(\"Percentage Match to job description\")\nif submit1:\n    if uploaded_file is not None:\n        pdf_text = input_pdf_text(uploaded_file)\n        response = get_gemini_response(jd, pdf_text, analyze_prompt)\n        st.subheader(\"The Response is : \")\n        st.write(response)",
        "detail": "ATS Modofied Resume Review.app",
        "documentation": {}
    },
    {
        "label": "submit2",
        "kind": 5,
        "importPath": "ATS Modofied Resume Review.app",
        "description": "ATS Modofied Resume Review.app",
        "peekOfCode": "submit2 = st.button(\"How can I improve?\")\nsubmit3 = st.button(\"Missing keywords?\")\nsubmit4 = st.button(\"Percentage Match to job description\")\nif submit1:\n    if uploaded_file is not None:\n        pdf_text = input_pdf_text(uploaded_file)\n        response = get_gemini_response(jd, pdf_text, analyze_prompt)\n        st.subheader(\"The Response is : \")\n        st.write(response)\n    else:",
        "detail": "ATS Modofied Resume Review.app",
        "documentation": {}
    },
    {
        "label": "submit3",
        "kind": 5,
        "importPath": "ATS Modofied Resume Review.app",
        "description": "ATS Modofied Resume Review.app",
        "peekOfCode": "submit3 = st.button(\"Missing keywords?\")\nsubmit4 = st.button(\"Percentage Match to job description\")\nif submit1:\n    if uploaded_file is not None:\n        pdf_text = input_pdf_text(uploaded_file)\n        response = get_gemini_response(jd, pdf_text, analyze_prompt)\n        st.subheader(\"The Response is : \")\n        st.write(response)\n    else:\n        print(\"Please upload your resume!\")",
        "detail": "ATS Modofied Resume Review.app",
        "documentation": {}
    },
    {
        "label": "submit4",
        "kind": 5,
        "importPath": "ATS Modofied Resume Review.app",
        "description": "ATS Modofied Resume Review.app",
        "peekOfCode": "submit4 = st.button(\"Percentage Match to job description\")\nif submit1:\n    if uploaded_file is not None:\n        pdf_text = input_pdf_text(uploaded_file)\n        response = get_gemini_response(jd, pdf_text, analyze_prompt)\n        st.subheader(\"The Response is : \")\n        st.write(response)\n    else:\n        print(\"Please upload your resume!\")\nif submit2:",
        "detail": "ATS Modofied Resume Review.app",
        "documentation": {}
    },
    {
        "label": "get_gemini_response",
        "kind": 2,
        "importPath": "ATS Resume Review.app",
        "description": "ATS Resume Review.app",
        "peekOfCode": "def get_gemini_response(input, pdf_content, prompt):\n    model = genai.GenerativeModel('gemini-1.5-flash') # load the model\n    response = model.generate_content([input, pdf_content[0], prompt])\n    return response.text\ndef input_pdf_setup(uploaded_file):\n    if uploaded_file is not None:\n        # Convert the PDF to Image      \n        images = pdf2image.convert_from_bytes(uploaded_file.read())\n        first_page = images[0]\n        # Convert to  bytes",
        "detail": "ATS Resume Review.app",
        "documentation": {}
    },
    {
        "label": "input_pdf_setup",
        "kind": 2,
        "importPath": "ATS Resume Review.app",
        "description": "ATS Resume Review.app",
        "peekOfCode": "def input_pdf_setup(uploaded_file):\n    if uploaded_file is not None:\n        # Convert the PDF to Image      \n        images = pdf2image.convert_from_bytes(uploaded_file.read())\n        first_page = images[0]\n        # Convert to  bytes\n        img_byte_arr = io.BytesIO()\n        first_page.save(img_byte_arr, format='JPEG')\n        img_byte_arr = img_byte_arr.getvalue()\n        pdf_parts = [",
        "detail": "ATS Resume Review.app",
        "documentation": {}
    },
    {
        "label": "input_text",
        "kind": 5,
        "importPath": "ATS Resume Review.app",
        "description": "ATS Resume Review.app",
        "peekOfCode": "input_text = st.text_area(\"Job Description: \", key='input')\nuploaded_file = st.file_uploader(\"Upload your resume here (PDF): \", type=['pdf'])\nsubmit1 = st.button(\"Tell me about my resume\")\nsubmit2 = st.button(\"How can I improve?\")\nsubmit3 = st.button(\"Missing keywords?\")\nsubmit4 = st.button(\"Percentage Match to job description\")\nanalyze_prompt = '''\n\"Analyze the content of my resume. Provide a detailed breakdown of my strengths, key skills, and qualifications, based on the information in the resume. Highlight the areas where I stand out, and how my experience aligns with general industry standards.\"\n'''\nimprovement_prompt = '''",
        "detail": "ATS Resume Review.app",
        "documentation": {}
    },
    {
        "label": "uploaded_file",
        "kind": 5,
        "importPath": "ATS Resume Review.app",
        "description": "ATS Resume Review.app",
        "peekOfCode": "uploaded_file = st.file_uploader(\"Upload your resume here (PDF): \", type=['pdf'])\nsubmit1 = st.button(\"Tell me about my resume\")\nsubmit2 = st.button(\"How can I improve?\")\nsubmit3 = st.button(\"Missing keywords?\")\nsubmit4 = st.button(\"Percentage Match to job description\")\nanalyze_prompt = '''\n\"Analyze the content of my resume. Provide a detailed breakdown of my strengths, key skills, and qualifications, based on the information in the resume. Highlight the areas where I stand out, and how my experience aligns with general industry standards.\"\n'''\nimprovement_prompt = '''\nReview my resume and suggest specific improvements to make it more effective. Identify gaps in skills, experience, or presentation that could enhance my chances in the job market. Provide actionable recommendations for better structure, clarity, or any other areas that can be optimized.",
        "detail": "ATS Resume Review.app",
        "documentation": {}
    },
    {
        "label": "submit1",
        "kind": 5,
        "importPath": "ATS Resume Review.app",
        "description": "ATS Resume Review.app",
        "peekOfCode": "submit1 = st.button(\"Tell me about my resume\")\nsubmit2 = st.button(\"How can I improve?\")\nsubmit3 = st.button(\"Missing keywords?\")\nsubmit4 = st.button(\"Percentage Match to job description\")\nanalyze_prompt = '''\n\"Analyze the content of my resume. Provide a detailed breakdown of my strengths, key skills, and qualifications, based on the information in the resume. Highlight the areas where I stand out, and how my experience aligns with general industry standards.\"\n'''\nimprovement_prompt = '''\nReview my resume and suggest specific improvements to make it more effective. Identify gaps in skills, experience, or presentation that could enhance my chances in the job market. Provide actionable recommendations for better structure, clarity, or any other areas that can be optimized.\n'''",
        "detail": "ATS Resume Review.app",
        "documentation": {}
    },
    {
        "label": "submit2",
        "kind": 5,
        "importPath": "ATS Resume Review.app",
        "description": "ATS Resume Review.app",
        "peekOfCode": "submit2 = st.button(\"How can I improve?\")\nsubmit3 = st.button(\"Missing keywords?\")\nsubmit4 = st.button(\"Percentage Match to job description\")\nanalyze_prompt = '''\n\"Analyze the content of my resume. Provide a detailed breakdown of my strengths, key skills, and qualifications, based on the information in the resume. Highlight the areas where I stand out, and how my experience aligns with general industry standards.\"\n'''\nimprovement_prompt = '''\nReview my resume and suggest specific improvements to make it more effective. Identify gaps in skills, experience, or presentation that could enhance my chances in the job market. Provide actionable recommendations for better structure, clarity, or any other areas that can be optimized.\n'''\nkeyword_prompt = '''",
        "detail": "ATS Resume Review.app",
        "documentation": {}
    },
    {
        "label": "submit3",
        "kind": 5,
        "importPath": "ATS Resume Review.app",
        "description": "ATS Resume Review.app",
        "peekOfCode": "submit3 = st.button(\"Missing keywords?\")\nsubmit4 = st.button(\"Percentage Match to job description\")\nanalyze_prompt = '''\n\"Analyze the content of my resume. Provide a detailed breakdown of my strengths, key skills, and qualifications, based on the information in the resume. Highlight the areas where I stand out, and how my experience aligns with general industry standards.\"\n'''\nimprovement_prompt = '''\nReview my resume and suggest specific improvements to make it more effective. Identify gaps in skills, experience, or presentation that could enhance my chances in the job market. Provide actionable recommendations for better structure, clarity, or any other areas that can be optimized.\n'''\nkeyword_prompt = '''\nScan my resume for important keywords and industry-specific terms related to my field or target job description. Identify any crucial keywords or phrases that are missing and explain how incorporating them could make my resume more attractive to potential employers and Applicant Tracking Systems (ATS).",
        "detail": "ATS Resume Review.app",
        "documentation": {}
    },
    {
        "label": "submit4",
        "kind": 5,
        "importPath": "ATS Resume Review.app",
        "description": "ATS Resume Review.app",
        "peekOfCode": "submit4 = st.button(\"Percentage Match to job description\")\nanalyze_prompt = '''\n\"Analyze the content of my resume. Provide a detailed breakdown of my strengths, key skills, and qualifications, based on the information in the resume. Highlight the areas where I stand out, and how my experience aligns with general industry standards.\"\n'''\nimprovement_prompt = '''\nReview my resume and suggest specific improvements to make it more effective. Identify gaps in skills, experience, or presentation that could enhance my chances in the job market. Provide actionable recommendations for better structure, clarity, or any other areas that can be optimized.\n'''\nkeyword_prompt = '''\nScan my resume for important keywords and industry-specific terms related to my field or target job description. Identify any crucial keywords or phrases that are missing and explain how incorporating them could make my resume more attractive to potential employers and Applicant Tracking Systems (ATS).\n'''",
        "detail": "ATS Resume Review.app",
        "documentation": {}
    },
    {
        "label": "analyze_prompt",
        "kind": 5,
        "importPath": "ATS Resume Review.app",
        "description": "ATS Resume Review.app",
        "peekOfCode": "analyze_prompt = '''\n\"Analyze the content of my resume. Provide a detailed breakdown of my strengths, key skills, and qualifications, based on the information in the resume. Highlight the areas where I stand out, and how my experience aligns with general industry standards.\"\n'''\nimprovement_prompt = '''\nReview my resume and suggest specific improvements to make it more effective. Identify gaps in skills, experience, or presentation that could enhance my chances in the job market. Provide actionable recommendations for better structure, clarity, or any other areas that can be optimized.\n'''\nkeyword_prompt = '''\nScan my resume for important keywords and industry-specific terms related to my field or target job description. Identify any crucial keywords or phrases that are missing and explain how incorporating them could make my resume more attractive to potential employers and Applicant Tracking Systems (ATS).\n'''\npercentage_prompt = '''",
        "detail": "ATS Resume Review.app",
        "documentation": {}
    },
    {
        "label": "improvement_prompt",
        "kind": 5,
        "importPath": "ATS Resume Review.app",
        "description": "ATS Resume Review.app",
        "peekOfCode": "improvement_prompt = '''\nReview my resume and suggest specific improvements to make it more effective. Identify gaps in skills, experience, or presentation that could enhance my chances in the job market. Provide actionable recommendations for better structure, clarity, or any other areas that can be optimized.\n'''\nkeyword_prompt = '''\nScan my resume for important keywords and industry-specific terms related to my field or target job description. Identify any crucial keywords or phrases that are missing and explain how incorporating them could make my resume more attractive to potential employers and Applicant Tracking Systems (ATS).\n'''\npercentage_prompt = '''\nCompare my resume to the provided job description and calculate a percentage match. Analyze how well my skills, experience, and qualifications align with the requirements of the job. Highlight the areas where I meet the criteria and those where I fall short, with suggestions to improve alignment\n'''\nif submit1:",
        "detail": "ATS Resume Review.app",
        "documentation": {}
    },
    {
        "label": "keyword_prompt",
        "kind": 5,
        "importPath": "ATS Resume Review.app",
        "description": "ATS Resume Review.app",
        "peekOfCode": "keyword_prompt = '''\nScan my resume for important keywords and industry-specific terms related to my field or target job description. Identify any crucial keywords or phrases that are missing and explain how incorporating them could make my resume more attractive to potential employers and Applicant Tracking Systems (ATS).\n'''\npercentage_prompt = '''\nCompare my resume to the provided job description and calculate a percentage match. Analyze how well my skills, experience, and qualifications align with the requirements of the job. Highlight the areas where I meet the criteria and those where I fall short, with suggestions to improve alignment\n'''\nif submit1:\n    if uploaded_file is not None:\n        pdf_content = input_pdf_setup(uploaded_file)\n        response = get_gemini_response(analyze_prompt, pdf_content, input_text)",
        "detail": "ATS Resume Review.app",
        "documentation": {}
    },
    {
        "label": "percentage_prompt",
        "kind": 5,
        "importPath": "ATS Resume Review.app",
        "description": "ATS Resume Review.app",
        "peekOfCode": "percentage_prompt = '''\nCompare my resume to the provided job description and calculate a percentage match. Analyze how well my skills, experience, and qualifications align with the requirements of the job. Highlight the areas where I meet the criteria and those where I fall short, with suggestions to improve alignment\n'''\nif submit1:\n    if uploaded_file is not None:\n        pdf_content = input_pdf_setup(uploaded_file)\n        response = get_gemini_response(analyze_prompt, pdf_content, input_text)\n        st.subheader(\"The Response is : \")\n        st.write(response)\n    else:",
        "detail": "ATS Resume Review.app",
        "documentation": {}
    },
    {
        "label": "get_gemini_response",
        "kind": 2,
        "importPath": "Chatbot with History.app",
        "description": "Chatbot with History.app",
        "peekOfCode": "def get_gemini_response(question):\n    response = chat.send_message(question)\n    return response\n# Function to display text in a streaming manner by chunks\ndef stream_response(response_text, chunk_size=14):\n    placeholder = st.empty()\n    words = response_text.split()\n    chunks = [\" \".join(words[i:i + chunk_size]) for i in range(0, len(words), chunk_size)]\n    text = \"\"\n    for chunk in chunks:",
        "detail": "Chatbot with History.app",
        "documentation": {}
    },
    {
        "label": "stream_response",
        "kind": 2,
        "importPath": "Chatbot with History.app",
        "description": "Chatbot with History.app",
        "peekOfCode": "def stream_response(response_text, chunk_size=14):\n    placeholder = st.empty()\n    words = response_text.split()\n    chunks = [\" \".join(words[i:i + chunk_size]) for i in range(0, len(words), chunk_size)]\n    text = \"\"\n    for chunk in chunks:\n        for letter in chunk:\n            text += letter\n            placeholder.text(text)\n            time.sleep(0.01)  # Adjust the speed of letter streaming here",
        "detail": "Chatbot with History.app",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "Chatbot with History.app",
        "description": "Chatbot with History.app",
        "peekOfCode": "model = genai.GenerativeModel(\"gemini-pro\")\nchat = model.start_chat(history=[])\ndef get_gemini_response(question):\n    response = chat.send_message(question)\n    return response\n# Function to display text in a streaming manner by chunks\ndef stream_response(response_text, chunk_size=14):\n    placeholder = st.empty()\n    words = response_text.split()\n    chunks = [\" \".join(words[i:i + chunk_size]) for i in range(0, len(words), chunk_size)]",
        "detail": "Chatbot with History.app",
        "documentation": {}
    },
    {
        "label": "chat",
        "kind": 5,
        "importPath": "Chatbot with History.app",
        "description": "Chatbot with History.app",
        "peekOfCode": "chat = model.start_chat(history=[])\ndef get_gemini_response(question):\n    response = chat.send_message(question)\n    return response\n# Function to display text in a streaming manner by chunks\ndef stream_response(response_text, chunk_size=14):\n    placeholder = st.empty()\n    words = response_text.split()\n    chunks = [\" \".join(words[i:i + chunk_size]) for i in range(0, len(words), chunk_size)]\n    text = \"\"",
        "detail": "Chatbot with History.app",
        "documentation": {}
    },
    {
        "label": "input_text",
        "kind": 5,
        "importPath": "Chatbot with History.app",
        "description": "Chatbot with History.app",
        "peekOfCode": "input_text = st.text_input(\"Input: \", key=\"input\")\nsubmit = st.button(\"Submit\")\nif submit and input_text:\n    response = get_gemini_response(input_text)\n    # Append the input and response to the chat history\n    st.session_state['chat_history'].append((\"**You\", input_text))\n    st.subheader(\"The response is: \")\n    # Adding spinning animation and generating response using stream\n    with st.spinner('Generating response...'):\n        response = get_gemini_response(input_text)",
        "detail": "Chatbot with History.app",
        "documentation": {}
    },
    {
        "label": "submit",
        "kind": 5,
        "importPath": "Chatbot with History.app",
        "description": "Chatbot with History.app",
        "peekOfCode": "submit = st.button(\"Submit\")\nif submit and input_text:\n    response = get_gemini_response(input_text)\n    # Append the input and response to the chat history\n    st.session_state['chat_history'].append((\"**You\", input_text))\n    st.subheader(\"The response is: \")\n    # Adding spinning animation and generating response using stream\n    with st.spinner('Generating response...'):\n        response = get_gemini_response(input_text)\n    st.header(\"The response to your question is: \")",
        "detail": "Chatbot with History.app",
        "documentation": {}
    },
    {
        "label": "clear_history",
        "kind": 5,
        "importPath": "Chatbot with History.app",
        "description": "Chatbot with History.app",
        "peekOfCode": "clear_history = st.button(\"Clear chat history\")\nif clear_history:\n    st.session_state['chat_history'] = []\n# Display chat history\nst.subheader(\"The chat history is: \")\nfor role, text in st.session_state['chat_history']:\n    st.write(f\"{role}: {text}\")",
        "detail": "Chatbot with History.app",
        "documentation": {}
    },
    {
        "label": "get_pdf_text",
        "kind": 2,
        "importPath": "Chatting with Multiple PDFs.app",
        "description": "Chatting with Multiple PDFs.app",
        "peekOfCode": "def get_pdf_text(pdf_docs):\n    text = \"\"\n    for pdf in pdf_docs:\n        pdf_reader = PdfReader(pdf)\n        for page in pdf_reader.pages:\n            text += page.extract_text()\n    return text\ndef get_text_chunks(text):\n    text_splitter = RecursiveCharacterTextSplitter(chunk_size=10000, chunk_overlap=1000)\n    chunks = text_splitter.split_text(text)",
        "detail": "Chatting with Multiple PDFs.app",
        "documentation": {}
    },
    {
        "label": "get_text_chunks",
        "kind": 2,
        "importPath": "Chatting with Multiple PDFs.app",
        "description": "Chatting with Multiple PDFs.app",
        "peekOfCode": "def get_text_chunks(text):\n    text_splitter = RecursiveCharacterTextSplitter(chunk_size=10000, chunk_overlap=1000)\n    chunks = text_splitter.split_text(text)\n    return chunks\ndef get_vector_store(text_chunks):\n    embeddings = GoogleGenerativeAIEmbeddings(model=\"models/embedding-001\")\n    vector_store = FAISS.from_texts(text_chunks, embedding=embeddings)\n    os.makedirs(\"faiss_index\", exist_ok=True)\n    vector_store.save_local(\"faiss_index\")\n    print(\"FAISS index saved successfully.\")",
        "detail": "Chatting with Multiple PDFs.app",
        "documentation": {}
    },
    {
        "label": "get_vector_store",
        "kind": 2,
        "importPath": "Chatting with Multiple PDFs.app",
        "description": "Chatting with Multiple PDFs.app",
        "peekOfCode": "def get_vector_store(text_chunks):\n    embeddings = GoogleGenerativeAIEmbeddings(model=\"models/embedding-001\")\n    vector_store = FAISS.from_texts(text_chunks, embedding=embeddings)\n    os.makedirs(\"faiss_index\", exist_ok=True)\n    vector_store.save_local(\"faiss_index\")\n    print(\"FAISS index saved successfully.\")\ndef get_conversational_chain():\n    prompt_template = \"\"\"\n    Answer the question in as much detail as possible from the provided context. Make sure to provide all the \n    details. If the answer is not found to be in the provided context, give a generic output such as : \"Answer is",
        "detail": "Chatting with Multiple PDFs.app",
        "documentation": {}
    },
    {
        "label": "get_conversational_chain",
        "kind": 2,
        "importPath": "Chatting with Multiple PDFs.app",
        "description": "Chatting with Multiple PDFs.app",
        "peekOfCode": "def get_conversational_chain():\n    prompt_template = \"\"\"\n    Answer the question in as much detail as possible from the provided context. Make sure to provide all the \n    details. If the answer is not found to be in the provided context, give a generic output such as : \"Answer is\n    not available in the PDF\", and make sure not to provide the wrong answer.\n    Context : \\n {context}? \\n\n    Question : \\n {question} \\n\n    Answer : \n    \"\"\"\n    model = ChatGoogleGenerativeAI(model=\"gemini-pro\", temperature=0.3)",
        "detail": "Chatting with Multiple PDFs.app",
        "documentation": {}
    },
    {
        "label": "user_input",
        "kind": 2,
        "importPath": "Chatting with Multiple PDFs.app",
        "description": "Chatting with Multiple PDFs.app",
        "peekOfCode": "def user_input(user_question):\n    embeddings = GoogleGenerativeAIEmbeddings(model=\"models/embedding-001\")\n    if not os.path.exists(\"faiss_index/index.faiss\"):\n        print(\"FAISS index file not found. Please ensure the index has been created.\")\n        st.error(\"FAISS index file not found. Please ensure the index has been created.\")\n        return\n    new_db = FAISS.load_local(\"faiss_index\", embeddings, allow_dangerous_deserialization=True)\n    docs = new_db.similarity_search(user_question)\n    chain = get_conversational_chain()\n    response = chain({\"input_documents\": docs, \"question\": user_question}, return_only_outputs=True)",
        "detail": "Chatting with Multiple PDFs.app",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Chatting with Multiple PDFs.app",
        "description": "Chatting with Multiple PDFs.app",
        "peekOfCode": "def main():\n    st.set_page_config(\"Chat With Multiple PDF\") \n    st.header(\"Chat with Multiple PDF using Gemini 🤖\") \n    user_question = st.text_input(\"Ask a Question from the PDF Files\") \n    if user_question: \n        user_input(user_question) \n    with st.sidebar: \n        st.title(\"Menu:\") \n        pdf_docs = st.file_uploader(\"Upload your PDF Files and Click on the Submit & Process\", accept_multiple_files=True, type=[\"pdf\"]) \n        if st.button(\"Submit & Process\"): ",
        "detail": "Chatting with Multiple PDFs.app",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "Chatting with Multiple PDFs.app",
        "description": "Chatting with Multiple PDFs.app",
        "peekOfCode": "model = genai.GenerativeModel(\"\")\ndef get_pdf_text(pdf_docs):\n    text = \"\"\n    for pdf in pdf_docs:\n        pdf_reader = PdfReader(pdf)\n        for page in pdf_reader.pages:\n            text += page.extract_text()\n    return text\ndef get_text_chunks(text):\n    text_splitter = RecursiveCharacterTextSplitter(chunk_size=10000, chunk_overlap=1000)",
        "detail": "Chatting with Multiple PDFs.app",
        "documentation": {}
    },
    {
        "label": "vector_embeddings",
        "kind": 2,
        "importPath": "Document-Q&A-with-Gemma.app",
        "description": "Document-Q&A-with-Gemma.app",
        "peekOfCode": "def vector_embeddings():\n    if \"vetors\" not in st.session_state:\n        st.session_state.embeddings = GoogleGenerativeAIEmbeddings(model=\"models/embedding-001\")\n        st.session_state.loader = PyPDFDirectoryLoader(\"./pdf_folder\")\n        st.session_state.docs = st.session_state.loader.load()\n        st.session_state.text_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=200)\n        st.session_state.final_documents = st.session_state.text_splitter.split_documents(st.session_state.docs)\n        st.session_state.vectors = FAISS.from_documents(st.session_state.final_documents, st.session_state.embeddings)\nprompt1 = st.text_input(\"Enter your question from the documents : \")\nif st.button(\"Creating Vector Store\"):",
        "detail": "Document-Q&A-with-Gemma.app",
        "documentation": {}
    },
    {
        "label": "groq_api_key",
        "kind": 5,
        "importPath": "Document-Q&A-with-Gemma.app",
        "description": "Document-Q&A-with-Gemma.app",
        "peekOfCode": "groq_api_key = os.getenv(\"GROQ_API_KEY\")\n# os.environ['GOOGLE_API_KEY']= os.getenv(\"GOOGLE_API_KEY\")\nst.title(\"Gemma Document Q&A\")\nllm = ChatGroq(\n    groq_api_key = groq_api_key,\n    model = \"Gemma-7b-it\"\n)\nprompt = ChatPromptTemplate.from_template(\n    \"\"\"\n    Answer the questions based on the provided context only.",
        "detail": "Document-Q&A-with-Gemma.app",
        "documentation": {}
    },
    {
        "label": "llm",
        "kind": 5,
        "importPath": "Document-Q&A-with-Gemma.app",
        "description": "Document-Q&A-with-Gemma.app",
        "peekOfCode": "llm = ChatGroq(\n    groq_api_key = groq_api_key,\n    model = \"Gemma-7b-it\"\n)\nprompt = ChatPromptTemplate.from_template(\n    \"\"\"\n    Answer the questions based on the provided context only.\n    Please provide the most accurate response based on the question.\n    <context>\n    {context}",
        "detail": "Document-Q&A-with-Gemma.app",
        "documentation": {}
    },
    {
        "label": "prompt",
        "kind": 5,
        "importPath": "Document-Q&A-with-Gemma.app",
        "description": "Document-Q&A-with-Gemma.app",
        "peekOfCode": "prompt = ChatPromptTemplate.from_template(\n    \"\"\"\n    Answer the questions based on the provided context only.\n    Please provide the most accurate response based on the question.\n    <context>\n    {context}\n    <context>\n    Question:{input}\n    \"\"\"\n)",
        "detail": "Document-Q&A-with-Gemma.app",
        "documentation": {}
    },
    {
        "label": "prompt1",
        "kind": 5,
        "importPath": "Document-Q&A-with-Gemma.app",
        "description": "Document-Q&A-with-Gemma.app",
        "peekOfCode": "prompt1 = st.text_input(\"Enter your question from the documents : \")\nif st.button(\"Creating Vector Store\"):\n    vector_embeddings()\n    st.write(\"Vector Store DB is ready\")\nimport time\nif prompt1:\n    document_chain = create_stuff_documents_chain(llm, prompt)\n    retriever = st.session_state.vectors.as_retriever()\n    retrieval_chain = create_retrieval_chain(retriever, document_chain)\n    start = time.process_time()",
        "detail": "Document-Q&A-with-Gemma.app",
        "documentation": {}
    },
    {
        "label": "get_gemini_response",
        "kind": 2,
        "importPath": "First App Gemini.app",
        "description": "First App Gemini.app",
        "peekOfCode": "def get_gemini_response(question):\n    '''\n    This function will load the Gemini model and get responses\n    '''\n    response = model.generate_content(question)\n    return response.text\n## Now we will set up our Streamlit application\nst.set_page_config(page_title=\"Q&A Demo\")\nst.header(\"Gemini LLM Application\")\ninput = st.text_input(\"Input: \",key=\"input\")",
        "detail": "First App Gemini.app",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "First App Gemini.app",
        "description": "First App Gemini.app",
        "peekOfCode": "model = genai.GenerativeModel(\"gemini-pro\")\ndef get_gemini_response(question):\n    '''\n    This function will load the Gemini model and get responses\n    '''\n    response = model.generate_content(question)\n    return response.text\n## Now we will set up our Streamlit application\nst.set_page_config(page_title=\"Q&A Demo\")\nst.header(\"Gemini LLM Application\")",
        "detail": "First App Gemini.app",
        "documentation": {}
    },
    {
        "label": "input",
        "kind": 5,
        "importPath": "First App Gemini.app",
        "description": "First App Gemini.app",
        "peekOfCode": "input = st.text_input(\"Input: \",key=\"input\")\nsubmit = st.button(\"Ask the question\")\n# When submit is clicked\nif submit:\n    response = get_gemini_response(input)\n    st.header(\"The response to your question is : \")\n    st.write(response)",
        "detail": "First App Gemini.app",
        "documentation": {}
    },
    {
        "label": "submit",
        "kind": 5,
        "importPath": "First App Gemini.app",
        "description": "First App Gemini.app",
        "peekOfCode": "submit = st.button(\"Ask the question\")\n# When submit is clicked\nif submit:\n    response = get_gemini_response(input)\n    st.header(\"The response to your question is : \")\n    st.write(response)",
        "detail": "First App Gemini.app",
        "documentation": {}
    },
    {
        "label": "get_gemini_response",
        "kind": 2,
        "importPath": "Invoice-Data-Extractor.app",
        "description": "Invoice-Data-Extractor.app",
        "peekOfCode": "def get_gemini_response(input, image, prompt):\n    response = model.generate_content([input, image[0], prompt])\n    return response.text\ndef input_image_details(upload_file):\n    if upload_file is not None:\n        # Read the file into bytes\n        bytes_data = upload_file.getvalue()\n        image_parts = [\n            {\n                \"mime_type\": upload_file.type,",
        "detail": "Invoice-Data-Extractor.app",
        "documentation": {}
    },
    {
        "label": "input_image_details",
        "kind": 2,
        "importPath": "Invoice-Data-Extractor.app",
        "description": "Invoice-Data-Extractor.app",
        "peekOfCode": "def input_image_details(upload_file):\n    if upload_file is not None:\n        # Read the file into bytes\n        bytes_data = upload_file.getvalue()\n        image_parts = [\n            {\n                \"mime_type\": upload_file.type,\n                \"data\": bytes_data\n            }\n        ]",
        "detail": "Invoice-Data-Extractor.app",
        "documentation": {}
    },
    {
        "label": "stream_response",
        "kind": 2,
        "importPath": "Invoice-Data-Extractor.app",
        "description": "Invoice-Data-Extractor.app",
        "peekOfCode": "def stream_response(response_text, chunk_size=14):\n    placeholder = st.empty()\n    words = response_text.split()\n    chunks = [\" \".join(words[i:i + chunk_size]) for i in range(0, len(words), chunk_size)]\n    text = \"\"\n    for chunk in chunks:\n        for letter in chunk:\n            text += letter\n            placeholder.text(text)\n            time.sleep(0.01)  # Adjust the speed of letter streaming here",
        "detail": "Invoice-Data-Extractor.app",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "Invoice-Data-Extractor.app",
        "description": "Invoice-Data-Extractor.app",
        "peekOfCode": "model = genai.GenerativeModel(\"gemini-1.5-flash\")\ndef get_gemini_response(input, image, prompt):\n    response = model.generate_content([input, image[0], prompt])\n    return response.text\ndef input_image_details(upload_file):\n    if upload_file is not None:\n        # Read the file into bytes\n        bytes_data = upload_file.getvalue()\n        image_parts = [\n            {",
        "detail": "Invoice-Data-Extractor.app",
        "documentation": {}
    },
    {
        "label": "input_text",
        "kind": 5,
        "importPath": "Invoice-Data-Extractor.app",
        "description": "Invoice-Data-Extractor.app",
        "peekOfCode": "input_text = st.text_input(\"Input: \", key=\"input\")\nuploaded_file = st.file_uploader(\"Upload Image\", type=[\"jpg\", \"jpeg\", \"png\"])\nimage = None\nif uploaded_file is not None:\n    image = Image.open(uploaded_file)\n    st.image(image, caption='Uploaded Image.', use_column_width=True)\nsubmit = st.button(\"Extract Invoice Data\")\ninput_prompt = \"\"\"\nYou are an expert in reading invoices. \nThe user has uploaded an invoice image and is asking for help.",
        "detail": "Invoice-Data-Extractor.app",
        "documentation": {}
    },
    {
        "label": "uploaded_file",
        "kind": 5,
        "importPath": "Invoice-Data-Extractor.app",
        "description": "Invoice-Data-Extractor.app",
        "peekOfCode": "uploaded_file = st.file_uploader(\"Upload Image\", type=[\"jpg\", \"jpeg\", \"png\"])\nimage = None\nif uploaded_file is not None:\n    image = Image.open(uploaded_file)\n    st.image(image, caption='Uploaded Image.', use_column_width=True)\nsubmit = st.button(\"Extract Invoice Data\")\ninput_prompt = \"\"\"\nYou are an expert in reading invoices. \nThe user has uploaded an invoice image and is asking for help.\nIf the user asks any questions about the invoice, read from the image and ",
        "detail": "Invoice-Data-Extractor.app",
        "documentation": {}
    },
    {
        "label": "image",
        "kind": 5,
        "importPath": "Invoice-Data-Extractor.app",
        "description": "Invoice-Data-Extractor.app",
        "peekOfCode": "image = None\nif uploaded_file is not None:\n    image = Image.open(uploaded_file)\n    st.image(image, caption='Uploaded Image.', use_column_width=True)\nsubmit = st.button(\"Extract Invoice Data\")\ninput_prompt = \"\"\"\nYou are an expert in reading invoices. \nThe user has uploaded an invoice image and is asking for help.\nIf the user asks any questions about the invoice, read from the image and \nprovide an answer.",
        "detail": "Invoice-Data-Extractor.app",
        "documentation": {}
    },
    {
        "label": "submit",
        "kind": 5,
        "importPath": "Invoice-Data-Extractor.app",
        "description": "Invoice-Data-Extractor.app",
        "peekOfCode": "submit = st.button(\"Extract Invoice Data\")\ninput_prompt = \"\"\"\nYou are an expert in reading invoices. \nThe user has uploaded an invoice image and is asking for help.\nIf the user asks any questions about the invoice, read from the image and \nprovide an answer.\n\"\"\"\n# When submit is clicked\nif submit:\n    with st.spinner('Generating response...'):",
        "detail": "Invoice-Data-Extractor.app",
        "documentation": {}
    },
    {
        "label": "input_prompt",
        "kind": 5,
        "importPath": "Invoice-Data-Extractor.app",
        "description": "Invoice-Data-Extractor.app",
        "peekOfCode": "input_prompt = \"\"\"\nYou are an expert in reading invoices. \nThe user has uploaded an invoice image and is asking for help.\nIf the user asks any questions about the invoice, read from the image and \nprovide an answer.\n\"\"\"\n# When submit is clicked\nif submit:\n    with st.spinner('Generating response...'):\n        image_data = input_image_details(uploaded_file)",
        "detail": "Invoice-Data-Extractor.app",
        "documentation": {}
    },
    {
        "label": "clean_text",
        "kind": 2,
        "importPath": "NLP.Word Embeddings",
        "description": "NLP.Word Embeddings",
        "peekOfCode": "def clean_text(sentence):\n    clean_sentence = \"\".join(l for l in sentence if l not in string.punctuation)\n    return clean_sentence\n# function to calculate the cosine\ndef cosine_similarity_calc(vec_1,vec_2):\n    sim = np.dot(vec_1,vec_2)/(np.linalg.norm(vec_1)*np.linalg.norm(vec_2))\n    return sim\n# function to calculate cosine similarity using word vectors (input is a series)\ndef embeddings_similarity(sentences):\n    # first we need to get data into | sentence_a | sentence_b | format",
        "detail": "NLP.Word Embeddings",
        "documentation": {}
    },
    {
        "label": "cosine_similarity_calc",
        "kind": 2,
        "importPath": "NLP.Word Embeddings",
        "description": "NLP.Word Embeddings",
        "peekOfCode": "def cosine_similarity_calc(vec_1,vec_2):\n    sim = np.dot(vec_1,vec_2)/(np.linalg.norm(vec_1)*np.linalg.norm(vec_2))\n    return sim\n# function to calculate cosine similarity using word vectors (input is a series)\ndef embeddings_similarity(sentences):\n    # first we need to get data into | sentence_a | sentence_b | format\n    sentence_pairs = list(itertools.combinations(sentences, 2))\n    sentence_a = [pair[0] for pair in sentence_pairs]\n    sentence_b = [pair[1] for pair in sentence_pairs]\n    sentence_pairs_df = pd.DataFrame({'sentence_a':sentence_a, 'sentence_b':sentence_b})",
        "detail": "NLP.Word Embeddings",
        "documentation": {}
    },
    {
        "label": "embeddings_similarity",
        "kind": 2,
        "importPath": "NLP.Word Embeddings",
        "description": "NLP.Word Embeddings",
        "peekOfCode": "def embeddings_similarity(sentences):\n    # first we need to get data into | sentence_a | sentence_b | format\n    sentence_pairs = list(itertools.combinations(sentences, 2))\n    sentence_a = [pair[0] for pair in sentence_pairs]\n    sentence_b = [pair[1] for pair in sentence_pairs]\n    sentence_pairs_df = pd.DataFrame({'sentence_a':sentence_a, 'sentence_b':sentence_b})\n    # get unique combinations of sentance_a and sentance_b\n    sentence_pairs_df = sentence_pairs_df.loc[\n        pd.DataFrame(\n            np.sort(sentence_pairs_df[['sentence_a', 'sentence_b']],1),",
        "detail": "NLP.Word Embeddings",
        "documentation": {}
    },
    {
        "label": "sentences",
        "kind": 5,
        "importPath": "NLP.Word Embeddings",
        "description": "NLP.Word Embeddings",
        "peekOfCode": "sentences = ['Hi, how are you?', 'Hey what\\'s up?']\nprint(embeddings_similarity(sentences))",
        "detail": "NLP.Word Embeddings",
        "documentation": {}
    },
    {
        "label": "get_gemini_response",
        "kind": 2,
        "importPath": "Nutrition-Provider.app",
        "description": "Nutrition-Provider.app",
        "peekOfCode": "def get_gemini_response(prompt, image):\n    model = genai.GenerativeModel(\"gemini-1.5-pro\")\n    response = model.generate_content([prompt, image])\n    return response.text\ndef input_image_setup(uploaded_file):\n    if uploaded_file is not None:\n        bytes_data = uploaded_file.getvalue()\n        image_parts = [\n            {\n                \"mime_type\": uploaded_file.type,",
        "detail": "Nutrition-Provider.app",
        "documentation": {}
    },
    {
        "label": "input_image_setup",
        "kind": 2,
        "importPath": "Nutrition-Provider.app",
        "description": "Nutrition-Provider.app",
        "peekOfCode": "def input_image_setup(uploaded_file):\n    if uploaded_file is not None:\n        bytes_data = uploaded_file.getvalue()\n        image_parts = [\n            {\n                \"mime_type\": uploaded_file.type,\n                \"bytes_info\": bytes_data\n            }\n        ]\n        return image_parts",
        "detail": "Nutrition-Provider.app",
        "documentation": {}
    },
    {
        "label": "stream_response",
        "kind": 2,
        "importPath": "Nutrition-Provider.app",
        "description": "Nutrition-Provider.app",
        "peekOfCode": "def stream_response(response_text, chunk_size=14):\n    placeholder = st.empty()\n    words = response_text.split()\n    chunks = [\" \".join(words[i:i + chunk_size]) for i in range(0, len(words), chunk_size)]\n    text = \"\"\n    for chunk in chunks:\n        for letter in chunk:\n            text += letter\n            placeholder.text(text)\n            time.sleep(0.01)  # Adjust the speed of letter streaming here",
        "detail": "Nutrition-Provider.app",
        "documentation": {}
    },
    {
        "label": "prompt",
        "kind": 5,
        "importPath": "Nutrition-Provider.app",
        "description": "Nutrition-Provider.app",
        "peekOfCode": "prompt = \"\"\"\nYou are a highly advanced AI model specialized in analyzing food images to estimate their calorie content. \nGiven an image of a meal, provide a detailed breakdown of the food items present and their respective calorie counts.\nIf you cannot be accurate, or cannot decide how much calories can one serving provide, give an avergae calorie for that\ndish that should be true for most. \nAfter recognising the food in the image, the output should be a list of the food and their calories. Only give an answer\nlike the example\nHere is an example : \n1. Item 1 --- no. of calories\n2. Item 2 --- no. of calories",
        "detail": "Nutrition-Provider.app",
        "documentation": {}
    },
    {
        "label": "uploaded_file",
        "kind": 5,
        "importPath": "Nutrition-Provider.app",
        "description": "Nutrition-Provider.app",
        "peekOfCode": "uploaded_file = st.file_uploader(\"Enter an image of your meal!\", type=[\"jpg\", \"png\", \"jpeg\"])\nimage = None\nif uploaded_file is not None:\n    meal_image = Image.open(uploaded_file)  # Open image using PIL\n    st.image(meal_image)  # Display the uploaded image in Streamlit\n    image = meal_image  # Store the image for later use in the API call\n# Button to trigger calorie check when pressed.\nif st.button(\"Check for calories\"):\n    if image is not None:\n        # Correct: passing `image` directly as a PIL image object to the API.",
        "detail": "Nutrition-Provider.app",
        "documentation": {}
    },
    {
        "label": "image",
        "kind": 5,
        "importPath": "Nutrition-Provider.app",
        "description": "Nutrition-Provider.app",
        "peekOfCode": "image = None\nif uploaded_file is not None:\n    meal_image = Image.open(uploaded_file)  # Open image using PIL\n    st.image(meal_image)  # Display the uploaded image in Streamlit\n    image = meal_image  # Store the image for later use in the API call\n# Button to trigger calorie check when pressed.\nif st.button(\"Check for calories\"):\n    if image is not None:\n        # Correct: passing `image` directly as a PIL image object to the API.\n        response = get_gemini_response(prompt, image)",
        "detail": "Nutrition-Provider.app",
        "documentation": {}
    },
    {
        "label": "get_gemini_response",
        "kind": 2,
        "importPath": "PDF Summarizaer.main",
        "description": "PDF Summarizaer.main",
        "peekOfCode": "def get_gemini_response(input, resume, prompt):\n    # Define my model here as flash model \n    model = genai.GenerativeModel(\"gemini-1.5-flash\")\n    # calling my model\n    response = model.generate_content([input, resume, prompt])\n    return response.text\ndef input_pdf_text(uploaded_file):\n    reader = pdf.PdfReader(uploaded_file)\n    text = \"\"\n    for page in reader.pages:",
        "detail": "PDF Summarizaer.main",
        "documentation": {}
    },
    {
        "label": "input_pdf_text",
        "kind": 2,
        "importPath": "PDF Summarizaer.main",
        "description": "PDF Summarizaer.main",
        "peekOfCode": "def input_pdf_text(uploaded_file):\n    reader = pdf.PdfReader(uploaded_file)\n    text = \"\"\n    for page in reader.pages:\n        text += page.extract_text()\n    return text\n# Function to display text in a streaming manner by chunks\ndef stream_response(response_text, chunk_size=14):\n    placeholder = st.empty()\n    words = response_text.split()",
        "detail": "PDF Summarizaer.main",
        "documentation": {}
    },
    {
        "label": "stream_response",
        "kind": 2,
        "importPath": "PDF Summarizaer.main",
        "description": "PDF Summarizaer.main",
        "peekOfCode": "def stream_response(response_text, chunk_size=14):\n    placeholder = st.empty()\n    words = response_text.split()\n    chunks = [\" \".join(words[i:i + chunk_size]) for i in range(0, len(words), chunk_size)]\n    text = \"\"\n    for chunk in chunks:\n        for letter in chunk:\n            text += letter\n            placeholder.text(text)\n            time.sleep(0.01)  # Adjust the speed of letter streaming here",
        "detail": "PDF Summarizaer.main",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "PDF Summarizaer.main",
        "description": "PDF Summarizaer.main",
        "peekOfCode": "model = genai.GenerativeModel(\"gemini-1.5-flash\")\ndef get_gemini_response(input, resume, prompt):\n    # Define my model here as flash model \n    model = genai.GenerativeModel(\"gemini-1.5-flash\")\n    # calling my model\n    response = model.generate_content([input, resume, prompt])\n    return response.text\ndef input_pdf_text(uploaded_file):\n    reader = pdf.PdfReader(uploaded_file)\n    text = \"\"",
        "detail": "PDF Summarizaer.main",
        "documentation": {}
    },
    {
        "label": "input_text",
        "kind": 5,
        "importPath": "PDF Summarizaer.main",
        "description": "PDF Summarizaer.main",
        "peekOfCode": "input_text = st.text_input(\"Input: \", key=\"input\")\nuploaded_file = st.file_uploader(\"Upload PDF\", type=[\"pdf\"])\npdf_text = None\nif uploaded_file is not None:\n    pdf_text = input_pdf_text(uploaded_file)\nsubmit = st.button(\"Extract Invoice Data\")\ninput_prompt = \"\"\"\nYou are an expert in reading pdfs. \nThe user has uploaded a pdf for you to summarise. give the sumamry of the input data    \n\"\"\"",
        "detail": "PDF Summarizaer.main",
        "documentation": {}
    },
    {
        "label": "uploaded_file",
        "kind": 5,
        "importPath": "PDF Summarizaer.main",
        "description": "PDF Summarizaer.main",
        "peekOfCode": "uploaded_file = st.file_uploader(\"Upload PDF\", type=[\"pdf\"])\npdf_text = None\nif uploaded_file is not None:\n    pdf_text = input_pdf_text(uploaded_file)\nsubmit = st.button(\"Extract Invoice Data\")\ninput_prompt = \"\"\"\nYou are an expert in reading pdfs. \nThe user has uploaded a pdf for you to summarise. give the sumamry of the input data    \n\"\"\"\n# When submit is clicked",
        "detail": "PDF Summarizaer.main",
        "documentation": {}
    },
    {
        "label": "pdf_text",
        "kind": 5,
        "importPath": "PDF Summarizaer.main",
        "description": "PDF Summarizaer.main",
        "peekOfCode": "pdf_text = None\nif uploaded_file is not None:\n    pdf_text = input_pdf_text(uploaded_file)\nsubmit = st.button(\"Extract Invoice Data\")\ninput_prompt = \"\"\"\nYou are an expert in reading pdfs. \nThe user has uploaded a pdf for you to summarise. give the sumamry of the input data    \n\"\"\"\n# When submit is clicked\nif submit:",
        "detail": "PDF Summarizaer.main",
        "documentation": {}
    },
    {
        "label": "submit",
        "kind": 5,
        "importPath": "PDF Summarizaer.main",
        "description": "PDF Summarizaer.main",
        "peekOfCode": "submit = st.button(\"Extract Invoice Data\")\ninput_prompt = \"\"\"\nYou are an expert in reading pdfs. \nThe user has uploaded a pdf for you to summarise. give the sumamry of the input data    \n\"\"\"\n# When submit is clicked\nif submit:\n    with st.spinner('Generating response...'):\n        pdf_data = input_pdf_text(uploaded_file)\n        response = get_gemini_response(input_prompt, pdf_data, input_text)",
        "detail": "PDF Summarizaer.main",
        "documentation": {}
    },
    {
        "label": "input_prompt",
        "kind": 5,
        "importPath": "PDF Summarizaer.main",
        "description": "PDF Summarizaer.main",
        "peekOfCode": "input_prompt = \"\"\"\nYou are an expert in reading pdfs. \nThe user has uploaded a pdf for you to summarise. give the sumamry of the input data    \n\"\"\"\n# When submit is clicked\nif submit:\n    with st.spinner('Generating response...'):\n        pdf_data = input_pdf_text(uploaded_file)\n        response = get_gemini_response(input_prompt, pdf_data, input_text)\n    st.header(\"The response to your question is: \")",
        "detail": "PDF Summarizaer.main",
        "documentation": {}
    },
    {
        "label": "get_gemini_response",
        "kind": 2,
        "importPath": "PDF Summarizaer.terminal",
        "description": "PDF Summarizaer.terminal",
        "peekOfCode": "def get_gemini_response(resume_text, prompt):\n    model = genai.GenerativeModel(\"gemini-1.5-flash\")\n    # Calling the model\n    response = model.generate_content([resume_text, prompt])\n    return response.text\ndef input_pdf_text(file_path):\n    with open(file_path, \"rb\") as file:\n        reader = pdf.PdfReader(file)\n        text = \"\"\n        for page in reader.pages:",
        "detail": "PDF Summarizaer.terminal",
        "documentation": {}
    },
    {
        "label": "input_pdf_text",
        "kind": 2,
        "importPath": "PDF Summarizaer.terminal",
        "description": "PDF Summarizaer.terminal",
        "peekOfCode": "def input_pdf_text(file_path):\n    with open(file_path, \"rb\") as file:\n        reader = pdf.PdfReader(file)\n        text = \"\"\n        for page in reader.pages:\n            text += page.extract_text()\n    return text\ndef main():    \n    pdf_path = \"C:\\\\Users\\\\User\\\\Downloads\\\\SJS Transcript Call.pdf\"  # Replace with your file path\n    if not os.path.exists(pdf_path):",
        "detail": "PDF Summarizaer.terminal",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "PDF Summarizaer.terminal",
        "description": "PDF Summarizaer.terminal",
        "peekOfCode": "def main():    \n    pdf_path = \"C:\\\\Users\\\\User\\\\Downloads\\\\SJS Transcript Call.pdf\"  # Replace with your file path\n    if not os.path.exists(pdf_path):\n        print(\"File not found!\")\n        return\n    pdf_text = input_pdf_text(pdf_path)\n    # Prompt for the model\n    input_prompt = \"\"\"\nYou are an expert in analyzing documents for investment insights. \nThe user has uploaded a PDF containing information about a company's business.",
        "detail": "PDF Summarizaer.terminal",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "PDF Summarizaer.terminal",
        "description": "PDF Summarizaer.terminal",
        "peekOfCode": "model = genai.GenerativeModel(\"gemini-1.5-flash\")\ndef get_gemini_response(resume_text, prompt):\n    model = genai.GenerativeModel(\"gemini-1.5-flash\")\n    # Calling the model\n    response = model.generate_content([resume_text, prompt])\n    return response.text\ndef input_pdf_text(file_path):\n    with open(file_path, \"rb\") as file:\n        reader = pdf.PdfReader(file)\n        text = \"\"",
        "detail": "PDF Summarizaer.terminal",
        "documentation": {}
    },
    {
        "label": "_SendfileFallbackProtocol",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.base_events",
        "description": "protobuf.Lib.asyncio.base_events",
        "peekOfCode": "class _SendfileFallbackProtocol(protocols.Protocol):\n    def __init__(self, transp):\n        if not isinstance(transp, transports._FlowControlMixin):\n            raise TypeError(\"transport should be _FlowControlMixin instance\")\n        self._transport = transp\n        self._proto = transp.get_protocol()\n        self._should_resume_reading = transp.is_reading()\n        self._should_resume_writing = transp._protocol_paused\n        transp.pause_reading()\n        transp.set_protocol(self)",
        "detail": "protobuf.Lib.asyncio.base_events",
        "documentation": {}
    },
    {
        "label": "Server",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.base_events",
        "description": "protobuf.Lib.asyncio.base_events",
        "peekOfCode": "class Server(events.AbstractServer):\n    def __init__(self, loop, sockets, protocol_factory, ssl_context, backlog,\n                 ssl_handshake_timeout):\n        self._loop = loop\n        self._sockets = sockets\n        self._active_count = 0\n        self._waiters = []\n        self._protocol_factory = protocol_factory\n        self._backlog = backlog\n        self._ssl_context = ssl_context",
        "detail": "protobuf.Lib.asyncio.base_events",
        "documentation": {}
    },
    {
        "label": "BaseEventLoop",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.base_events",
        "description": "protobuf.Lib.asyncio.base_events",
        "peekOfCode": "class BaseEventLoop(events.AbstractEventLoop):\n    def __init__(self):\n        self._timer_cancelled_count = 0\n        self._closed = False\n        self._stopping = False\n        self._ready = collections.deque()\n        self._scheduled = []\n        self._default_executor = None\n        self._internal_fds = 0\n        # Identifier of the thread running the event loop, or None if the",
        "detail": "protobuf.Lib.asyncio.base_events",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.base_events",
        "description": "protobuf.Lib.asyncio.base_events",
        "peekOfCode": "__all__ = 'BaseEventLoop','Server',\n# Minimum number of _scheduled timer handles before cleanup of\n# cancelled handles is performed.\n_MIN_SCHEDULED_TIMER_HANDLES = 100\n# Minimum fraction of _scheduled timer handles that are cancelled\n# before cleanup of cancelled handles is performed.\n_MIN_CANCELLED_TIMER_HANDLES_FRACTION = 0.5\n_HAS_IPv6 = hasattr(socket, 'AF_INET6')\n# Maximum timeout passed to select to avoid OS limitations\nMAXIMUM_SELECT_TIMEOUT = 24 * 3600",
        "detail": "protobuf.Lib.asyncio.base_events",
        "documentation": {}
    },
    {
        "label": "_MIN_SCHEDULED_TIMER_HANDLES",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.base_events",
        "description": "protobuf.Lib.asyncio.base_events",
        "peekOfCode": "_MIN_SCHEDULED_TIMER_HANDLES = 100\n# Minimum fraction of _scheduled timer handles that are cancelled\n# before cleanup of cancelled handles is performed.\n_MIN_CANCELLED_TIMER_HANDLES_FRACTION = 0.5\n_HAS_IPv6 = hasattr(socket, 'AF_INET6')\n# Maximum timeout passed to select to avoid OS limitations\nMAXIMUM_SELECT_TIMEOUT = 24 * 3600\n# Used for deprecation and removal of `loop.create_datagram_endpoint()`'s\n# *reuse_address* parameter\n_unset = object()",
        "detail": "protobuf.Lib.asyncio.base_events",
        "documentation": {}
    },
    {
        "label": "_MIN_CANCELLED_TIMER_HANDLES_FRACTION",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.base_events",
        "description": "protobuf.Lib.asyncio.base_events",
        "peekOfCode": "_MIN_CANCELLED_TIMER_HANDLES_FRACTION = 0.5\n_HAS_IPv6 = hasattr(socket, 'AF_INET6')\n# Maximum timeout passed to select to avoid OS limitations\nMAXIMUM_SELECT_TIMEOUT = 24 * 3600\n# Used for deprecation and removal of `loop.create_datagram_endpoint()`'s\n# *reuse_address* parameter\n_unset = object()\ndef _format_handle(handle):\n    cb = handle._callback\n    if isinstance(getattr(cb, '__self__', None), tasks.Task):",
        "detail": "protobuf.Lib.asyncio.base_events",
        "documentation": {}
    },
    {
        "label": "_HAS_IPv6",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.base_events",
        "description": "protobuf.Lib.asyncio.base_events",
        "peekOfCode": "_HAS_IPv6 = hasattr(socket, 'AF_INET6')\n# Maximum timeout passed to select to avoid OS limitations\nMAXIMUM_SELECT_TIMEOUT = 24 * 3600\n# Used for deprecation and removal of `loop.create_datagram_endpoint()`'s\n# *reuse_address* parameter\n_unset = object()\ndef _format_handle(handle):\n    cb = handle._callback\n    if isinstance(getattr(cb, '__self__', None), tasks.Task):\n        # format the task",
        "detail": "protobuf.Lib.asyncio.base_events",
        "documentation": {}
    },
    {
        "label": "MAXIMUM_SELECT_TIMEOUT",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.base_events",
        "description": "protobuf.Lib.asyncio.base_events",
        "peekOfCode": "MAXIMUM_SELECT_TIMEOUT = 24 * 3600\n# Used for deprecation and removal of `loop.create_datagram_endpoint()`'s\n# *reuse_address* parameter\n_unset = object()\ndef _format_handle(handle):\n    cb = handle._callback\n    if isinstance(getattr(cb, '__self__', None), tasks.Task):\n        # format the task\n        return repr(cb.__self__)\n    else:",
        "detail": "protobuf.Lib.asyncio.base_events",
        "documentation": {}
    },
    {
        "label": "_unset",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.base_events",
        "description": "protobuf.Lib.asyncio.base_events",
        "peekOfCode": "_unset = object()\ndef _format_handle(handle):\n    cb = handle._callback\n    if isinstance(getattr(cb, '__self__', None), tasks.Task):\n        # format the task\n        return repr(cb.__self__)\n    else:\n        return str(handle)\ndef _format_pipe(fd):\n    if fd == subprocess.PIPE:",
        "detail": "protobuf.Lib.asyncio.base_events",
        "documentation": {}
    },
    {
        "label": "isfuture",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncio.base_futures",
        "description": "protobuf.Lib.asyncio.base_futures",
        "peekOfCode": "def isfuture(obj):\n    \"\"\"Check for a Future.\n    This returns True when obj is a Future instance or is advertising\n    itself as duck-type compatible by setting _asyncio_future_blocking.\n    See comment in Future for more details.\n    \"\"\"\n    return (hasattr(obj.__class__, '_asyncio_future_blocking') and\n            obj._asyncio_future_blocking is not None)\ndef _format_callbacks(cb):\n    \"\"\"helper function for Future.__repr__\"\"\"",
        "detail": "protobuf.Lib.asyncio.base_futures",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.base_futures",
        "description": "protobuf.Lib.asyncio.base_futures",
        "peekOfCode": "__all__ = ()\nimport reprlib\nfrom _thread import get_ident\nfrom . import format_helpers\n# States for Future.\n_PENDING = 'PENDING'\n_CANCELLED = 'CANCELLED'\n_FINISHED = 'FINISHED'\ndef isfuture(obj):\n    \"\"\"Check for a Future.",
        "detail": "protobuf.Lib.asyncio.base_futures",
        "documentation": {}
    },
    {
        "label": "_PENDING",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.base_futures",
        "description": "protobuf.Lib.asyncio.base_futures",
        "peekOfCode": "_PENDING = 'PENDING'\n_CANCELLED = 'CANCELLED'\n_FINISHED = 'FINISHED'\ndef isfuture(obj):\n    \"\"\"Check for a Future.\n    This returns True when obj is a Future instance or is advertising\n    itself as duck-type compatible by setting _asyncio_future_blocking.\n    See comment in Future for more details.\n    \"\"\"\n    return (hasattr(obj.__class__, '_asyncio_future_blocking') and",
        "detail": "protobuf.Lib.asyncio.base_futures",
        "documentation": {}
    },
    {
        "label": "_CANCELLED",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.base_futures",
        "description": "protobuf.Lib.asyncio.base_futures",
        "peekOfCode": "_CANCELLED = 'CANCELLED'\n_FINISHED = 'FINISHED'\ndef isfuture(obj):\n    \"\"\"Check for a Future.\n    This returns True when obj is a Future instance or is advertising\n    itself as duck-type compatible by setting _asyncio_future_blocking.\n    See comment in Future for more details.\n    \"\"\"\n    return (hasattr(obj.__class__, '_asyncio_future_blocking') and\n            obj._asyncio_future_blocking is not None)",
        "detail": "protobuf.Lib.asyncio.base_futures",
        "documentation": {}
    },
    {
        "label": "_FINISHED",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.base_futures",
        "description": "protobuf.Lib.asyncio.base_futures",
        "peekOfCode": "_FINISHED = 'FINISHED'\ndef isfuture(obj):\n    \"\"\"Check for a Future.\n    This returns True when obj is a Future instance or is advertising\n    itself as duck-type compatible by setting _asyncio_future_blocking.\n    See comment in Future for more details.\n    \"\"\"\n    return (hasattr(obj.__class__, '_asyncio_future_blocking') and\n            obj._asyncio_future_blocking is not None)\ndef _format_callbacks(cb):",
        "detail": "protobuf.Lib.asyncio.base_futures",
        "documentation": {}
    },
    {
        "label": "_repr_running",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.base_futures",
        "description": "protobuf.Lib.asyncio.base_futures",
        "peekOfCode": "_repr_running = set()\ndef _future_repr_info(future):\n    # (Future) -> str\n    \"\"\"helper function for Future.__repr__\"\"\"\n    info = [future._state.lower()]\n    if future._state == _FINISHED:\n        if future._exception is not None:\n            info.append(f'exception={future._exception!r}')\n        else:\n            key = id(future), get_ident()",
        "detail": "protobuf.Lib.asyncio.base_futures",
        "documentation": {}
    },
    {
        "label": "BaseSubprocessTransport",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.base_subprocess",
        "description": "protobuf.Lib.asyncio.base_subprocess",
        "peekOfCode": "class BaseSubprocessTransport(transports.SubprocessTransport):\n    def __init__(self, loop, protocol, args, shell,\n                 stdin, stdout, stderr, bufsize,\n                 waiter=None, extra=None, **kwargs):\n        super().__init__(extra)\n        self._closed = False\n        self._protocol = protocol\n        self._loop = loop\n        self._proc = None\n        self._pid = None",
        "detail": "protobuf.Lib.asyncio.base_subprocess",
        "documentation": {}
    },
    {
        "label": "WriteSubprocessPipeProto",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.base_subprocess",
        "description": "protobuf.Lib.asyncio.base_subprocess",
        "peekOfCode": "class WriteSubprocessPipeProto(protocols.BaseProtocol):\n    def __init__(self, proc, fd):\n        self.proc = proc\n        self.fd = fd\n        self.pipe = None\n        self.disconnected = False\n    def connection_made(self, transport):\n        self.pipe = transport\n    def __repr__(self):\n        return f'<{self.__class__.__name__} fd={self.fd} pipe={self.pipe!r}>'",
        "detail": "protobuf.Lib.asyncio.base_subprocess",
        "documentation": {}
    },
    {
        "label": "ReadSubprocessPipeProto",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.base_subprocess",
        "description": "protobuf.Lib.asyncio.base_subprocess",
        "peekOfCode": "class ReadSubprocessPipeProto(WriteSubprocessPipeProto,\n                              protocols.Protocol):\n    def data_received(self, data):\n        self.proc._pipe_data_received(self.fd, data)",
        "detail": "protobuf.Lib.asyncio.base_subprocess",
        "documentation": {}
    },
    {
        "label": "_SendfileMode",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.constants",
        "description": "protobuf.Lib.asyncio.constants",
        "peekOfCode": "class _SendfileMode(enum.Enum):\n    UNSUPPORTED = enum.auto()\n    TRY_NATIVE = enum.auto()\n    FALLBACK = enum.auto()",
        "detail": "protobuf.Lib.asyncio.constants",
        "documentation": {}
    },
    {
        "label": "LOG_THRESHOLD_FOR_CONNLOST_WRITES",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.constants",
        "description": "protobuf.Lib.asyncio.constants",
        "peekOfCode": "LOG_THRESHOLD_FOR_CONNLOST_WRITES = 5\n# Seconds to wait before retrying accept().\nACCEPT_RETRY_DELAY = 1\n# Number of stack entries to capture in debug mode.\n# The larger the number, the slower the operation in debug mode\n# (see extract_stack() in format_helpers.py).\nDEBUG_STACK_DEPTH = 10\n# Number of seconds to wait for SSL handshake to complete\n# The default timeout matches that of Nginx.\nSSL_HANDSHAKE_TIMEOUT = 60.0",
        "detail": "protobuf.Lib.asyncio.constants",
        "documentation": {}
    },
    {
        "label": "ACCEPT_RETRY_DELAY",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.constants",
        "description": "protobuf.Lib.asyncio.constants",
        "peekOfCode": "ACCEPT_RETRY_DELAY = 1\n# Number of stack entries to capture in debug mode.\n# The larger the number, the slower the operation in debug mode\n# (see extract_stack() in format_helpers.py).\nDEBUG_STACK_DEPTH = 10\n# Number of seconds to wait for SSL handshake to complete\n# The default timeout matches that of Nginx.\nSSL_HANDSHAKE_TIMEOUT = 60.0\n# Used in sendfile fallback code.  We use fallback for platforms\n# that don't support sendfile, or for TLS connections.",
        "detail": "protobuf.Lib.asyncio.constants",
        "documentation": {}
    },
    {
        "label": "DEBUG_STACK_DEPTH",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.constants",
        "description": "protobuf.Lib.asyncio.constants",
        "peekOfCode": "DEBUG_STACK_DEPTH = 10\n# Number of seconds to wait for SSL handshake to complete\n# The default timeout matches that of Nginx.\nSSL_HANDSHAKE_TIMEOUT = 60.0\n# Used in sendfile fallback code.  We use fallback for platforms\n# that don't support sendfile, or for TLS connections.\nSENDFILE_FALLBACK_READBUFFER_SIZE = 1024 * 256\n# The enum should be here to break circular dependencies between\n# base_events and sslproto\nclass _SendfileMode(enum.Enum):",
        "detail": "protobuf.Lib.asyncio.constants",
        "documentation": {}
    },
    {
        "label": "SSL_HANDSHAKE_TIMEOUT",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.constants",
        "description": "protobuf.Lib.asyncio.constants",
        "peekOfCode": "SSL_HANDSHAKE_TIMEOUT = 60.0\n# Used in sendfile fallback code.  We use fallback for platforms\n# that don't support sendfile, or for TLS connections.\nSENDFILE_FALLBACK_READBUFFER_SIZE = 1024 * 256\n# The enum should be here to break circular dependencies between\n# base_events and sslproto\nclass _SendfileMode(enum.Enum):\n    UNSUPPORTED = enum.auto()\n    TRY_NATIVE = enum.auto()\n    FALLBACK = enum.auto()",
        "detail": "protobuf.Lib.asyncio.constants",
        "documentation": {}
    },
    {
        "label": "SENDFILE_FALLBACK_READBUFFER_SIZE",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.constants",
        "description": "protobuf.Lib.asyncio.constants",
        "peekOfCode": "SENDFILE_FALLBACK_READBUFFER_SIZE = 1024 * 256\n# The enum should be here to break circular dependencies between\n# base_events and sslproto\nclass _SendfileMode(enum.Enum):\n    UNSUPPORTED = enum.auto()\n    TRY_NATIVE = enum.auto()\n    FALLBACK = enum.auto()",
        "detail": "protobuf.Lib.asyncio.constants",
        "documentation": {}
    },
    {
        "label": "CoroWrapper",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.coroutines",
        "description": "protobuf.Lib.asyncio.coroutines",
        "peekOfCode": "class CoroWrapper:\n    # Wrapper for coroutine object in _DEBUG mode.\n    def __init__(self, gen, func=None):\n        assert inspect.isgenerator(gen) or inspect.iscoroutine(gen), gen\n        self.gen = gen\n        self.func = func  # Used to unwrap @coroutine decorator\n        self._source_traceback = format_helpers.extract_stack(sys._getframe(1))\n        self.__name__ = getattr(gen, '__name__', None)\n        self.__qualname__ = getattr(gen, '__qualname__', None)\n    def __repr__(self):",
        "detail": "protobuf.Lib.asyncio.coroutines",
        "documentation": {}
    },
    {
        "label": "coroutine",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncio.coroutines",
        "description": "protobuf.Lib.asyncio.coroutines",
        "peekOfCode": "def coroutine(func):\n    \"\"\"Decorator to mark coroutines.\n    If the coroutine is not yielded from before it is destroyed,\n    an error message is logged.\n    \"\"\"\n    warnings.warn('\"@coroutine\" decorator is deprecated since Python 3.8, use \"async def\" instead',\n                  DeprecationWarning,\n                  stacklevel=2)\n    if inspect.iscoroutinefunction(func):\n        # In Python 3.5 that's all we need to do for coroutines",
        "detail": "protobuf.Lib.asyncio.coroutines",
        "documentation": {}
    },
    {
        "label": "iscoroutinefunction",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncio.coroutines",
        "description": "protobuf.Lib.asyncio.coroutines",
        "peekOfCode": "def iscoroutinefunction(func):\n    \"\"\"Return True if func is a decorated coroutine function.\"\"\"\n    return (inspect.iscoroutinefunction(func) or\n            getattr(func, '_is_coroutine', None) is _is_coroutine)\n# Prioritize native coroutine check to speed-up\n# asyncio.iscoroutine.\n_COROUTINE_TYPES = (types.CoroutineType, types.GeneratorType,\n                    collections.abc.Coroutine, CoroWrapper)\n_iscoroutine_typecache = set()\ndef iscoroutine(obj):",
        "detail": "protobuf.Lib.asyncio.coroutines",
        "documentation": {}
    },
    {
        "label": "iscoroutine",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncio.coroutines",
        "description": "protobuf.Lib.asyncio.coroutines",
        "peekOfCode": "def iscoroutine(obj):\n    \"\"\"Return True if obj is a coroutine object.\"\"\"\n    if type(obj) in _iscoroutine_typecache:\n        return True\n    if isinstance(obj, _COROUTINE_TYPES):\n        # Just in case we don't want to cache more than 100\n        # positive types.  That shouldn't ever happen, unless\n        # someone stressing the system on purpose.\n        if len(_iscoroutine_typecache) < 100:\n            _iscoroutine_typecache.add(type(obj))",
        "detail": "protobuf.Lib.asyncio.coroutines",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.coroutines",
        "description": "protobuf.Lib.asyncio.coroutines",
        "peekOfCode": "__all__ = 'coroutine', 'iscoroutinefunction', 'iscoroutine'\nimport collections.abc\nimport functools\nimport inspect\nimport os\nimport sys\nimport traceback\nimport types\nimport warnings\nfrom . import base_futures",
        "detail": "protobuf.Lib.asyncio.coroutines",
        "documentation": {}
    },
    {
        "label": "_DEBUG",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.coroutines",
        "description": "protobuf.Lib.asyncio.coroutines",
        "peekOfCode": "_DEBUG = _is_debug_mode()\nclass CoroWrapper:\n    # Wrapper for coroutine object in _DEBUG mode.\n    def __init__(self, gen, func=None):\n        assert inspect.isgenerator(gen) or inspect.iscoroutine(gen), gen\n        self.gen = gen\n        self.func = func  # Used to unwrap @coroutine decorator\n        self._source_traceback = format_helpers.extract_stack(sys._getframe(1))\n        self.__name__ = getattr(gen, '__name__', None)\n        self.__qualname__ = getattr(gen, '__qualname__', None)",
        "detail": "protobuf.Lib.asyncio.coroutines",
        "documentation": {}
    },
    {
        "label": "_is_coroutine",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.coroutines",
        "description": "protobuf.Lib.asyncio.coroutines",
        "peekOfCode": "_is_coroutine = object()\ndef iscoroutinefunction(func):\n    \"\"\"Return True if func is a decorated coroutine function.\"\"\"\n    return (inspect.iscoroutinefunction(func) or\n            getattr(func, '_is_coroutine', None) is _is_coroutine)\n# Prioritize native coroutine check to speed-up\n# asyncio.iscoroutine.\n_COROUTINE_TYPES = (types.CoroutineType, types.GeneratorType,\n                    collections.abc.Coroutine, CoroWrapper)\n_iscoroutine_typecache = set()",
        "detail": "protobuf.Lib.asyncio.coroutines",
        "documentation": {}
    },
    {
        "label": "_COROUTINE_TYPES",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.coroutines",
        "description": "protobuf.Lib.asyncio.coroutines",
        "peekOfCode": "_COROUTINE_TYPES = (types.CoroutineType, types.GeneratorType,\n                    collections.abc.Coroutine, CoroWrapper)\n_iscoroutine_typecache = set()\ndef iscoroutine(obj):\n    \"\"\"Return True if obj is a coroutine object.\"\"\"\n    if type(obj) in _iscoroutine_typecache:\n        return True\n    if isinstance(obj, _COROUTINE_TYPES):\n        # Just in case we don't want to cache more than 100\n        # positive types.  That shouldn't ever happen, unless",
        "detail": "protobuf.Lib.asyncio.coroutines",
        "documentation": {}
    },
    {
        "label": "_iscoroutine_typecache",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.coroutines",
        "description": "protobuf.Lib.asyncio.coroutines",
        "peekOfCode": "_iscoroutine_typecache = set()\ndef iscoroutine(obj):\n    \"\"\"Return True if obj is a coroutine object.\"\"\"\n    if type(obj) in _iscoroutine_typecache:\n        return True\n    if isinstance(obj, _COROUTINE_TYPES):\n        # Just in case we don't want to cache more than 100\n        # positive types.  That shouldn't ever happen, unless\n        # someone stressing the system on purpose.\n        if len(_iscoroutine_typecache) < 100:",
        "detail": "protobuf.Lib.asyncio.coroutines",
        "documentation": {}
    },
    {
        "label": "Handle",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.events",
        "description": "protobuf.Lib.asyncio.events",
        "peekOfCode": "class Handle:\n    \"\"\"Object returned by callback registration methods.\"\"\"\n    __slots__ = ('_callback', '_args', '_cancelled', '_loop',\n                 '_source_traceback', '_repr', '__weakref__',\n                 '_context')\n    def __init__(self, callback, args, loop, context=None):\n        if context is None:\n            context = contextvars.copy_context()\n        self._context = context\n        self._loop = loop",
        "detail": "protobuf.Lib.asyncio.events",
        "documentation": {}
    },
    {
        "label": "TimerHandle",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.events",
        "description": "protobuf.Lib.asyncio.events",
        "peekOfCode": "class TimerHandle(Handle):\n    \"\"\"Object returned by timed callback registration methods.\"\"\"\n    __slots__ = ['_scheduled', '_when']\n    def __init__(self, when, callback, args, loop, context=None):\n        assert when is not None\n        super().__init__(callback, args, loop, context)\n        if self._source_traceback:\n            del self._source_traceback[-1]\n        self._when = when\n        self._scheduled = False",
        "detail": "protobuf.Lib.asyncio.events",
        "documentation": {}
    },
    {
        "label": "AbstractServer",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.events",
        "description": "protobuf.Lib.asyncio.events",
        "peekOfCode": "class AbstractServer:\n    \"\"\"Abstract server returned by create_server().\"\"\"\n    def close(self):\n        \"\"\"Stop serving.  This leaves existing connections open.\"\"\"\n        raise NotImplementedError\n    def get_loop(self):\n        \"\"\"Get the event loop the Server object is attached to.\"\"\"\n        raise NotImplementedError\n    def is_serving(self):\n        \"\"\"Return True if the server is accepting connections.\"\"\"",
        "detail": "protobuf.Lib.asyncio.events",
        "documentation": {}
    },
    {
        "label": "AbstractEventLoop",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.events",
        "description": "protobuf.Lib.asyncio.events",
        "peekOfCode": "class AbstractEventLoop:\n    \"\"\"Abstract event loop.\"\"\"\n    # Running and stopping the event loop.\n    def run_forever(self):\n        \"\"\"Run the event loop until stop() is called.\"\"\"\n        raise NotImplementedError\n    def run_until_complete(self, future):\n        \"\"\"Run the event loop until a Future is done.\n        Return the Future's result, or raise its exception.\n        \"\"\"",
        "detail": "protobuf.Lib.asyncio.events",
        "documentation": {}
    },
    {
        "label": "AbstractEventLoopPolicy",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.events",
        "description": "protobuf.Lib.asyncio.events",
        "peekOfCode": "class AbstractEventLoopPolicy:\n    \"\"\"Abstract policy for accessing the event loop.\"\"\"\n    def get_event_loop(self):\n        \"\"\"Get the event loop for the current context.\n        Returns an event loop object implementing the BaseEventLoop interface,\n        or raises an exception in case no event loop has been set for the\n        current context and the current policy does not specify to create one.\n        It should never return None.\"\"\"\n        raise NotImplementedError\n    def set_event_loop(self, loop):",
        "detail": "protobuf.Lib.asyncio.events",
        "documentation": {}
    },
    {
        "label": "BaseDefaultEventLoopPolicy",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.events",
        "description": "protobuf.Lib.asyncio.events",
        "peekOfCode": "class BaseDefaultEventLoopPolicy(AbstractEventLoopPolicy):\n    \"\"\"Default policy implementation for accessing the event loop.\n    In this policy, each thread has its own event loop.  However, we\n    only automatically create an event loop by default for the main\n    thread; other threads by default have no event loop.\n    Other policies may have different rules (e.g. a single global\n    event loop, or automatically creating an event loop per thread, or\n    using some other notion of context to which an event loop is\n    associated).\n    \"\"\"",
        "detail": "protobuf.Lib.asyncio.events",
        "documentation": {}
    },
    {
        "label": "_RunningLoop",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.events",
        "description": "protobuf.Lib.asyncio.events",
        "peekOfCode": "class _RunningLoop(threading.local):\n    loop_pid = (None, None)\n_running_loop = _RunningLoop()\ndef get_running_loop():\n    \"\"\"Return the running event loop.  Raise a RuntimeError if there is none.\n    This function is thread-specific.\n    \"\"\"\n    # NOTE: this function is implemented in C (see _asynciomodule.c)\n    loop = _get_running_loop()\n    if loop is None:",
        "detail": "protobuf.Lib.asyncio.events",
        "documentation": {}
    },
    {
        "label": "get_running_loop",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncio.events",
        "description": "protobuf.Lib.asyncio.events",
        "peekOfCode": "def get_running_loop():\n    \"\"\"Return the running event loop.  Raise a RuntimeError if there is none.\n    This function is thread-specific.\n    \"\"\"\n    # NOTE: this function is implemented in C (see _asynciomodule.c)\n    loop = _get_running_loop()\n    if loop is None:\n        raise RuntimeError('no running event loop')\n    return loop\ndef _get_running_loop():",
        "detail": "protobuf.Lib.asyncio.events",
        "documentation": {}
    },
    {
        "label": "get_event_loop_policy",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncio.events",
        "description": "protobuf.Lib.asyncio.events",
        "peekOfCode": "def get_event_loop_policy():\n    \"\"\"Get the current event loop policy.\"\"\"\n    if _event_loop_policy is None:\n        _init_event_loop_policy()\n    return _event_loop_policy\ndef set_event_loop_policy(policy):\n    \"\"\"Set the current event loop policy.\n    If policy is None, the default policy is restored.\"\"\"\n    global _event_loop_policy\n    assert policy is None or isinstance(policy, AbstractEventLoopPolicy)",
        "detail": "protobuf.Lib.asyncio.events",
        "documentation": {}
    },
    {
        "label": "set_event_loop_policy",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncio.events",
        "description": "protobuf.Lib.asyncio.events",
        "peekOfCode": "def set_event_loop_policy(policy):\n    \"\"\"Set the current event loop policy.\n    If policy is None, the default policy is restored.\"\"\"\n    global _event_loop_policy\n    assert policy is None or isinstance(policy, AbstractEventLoopPolicy)\n    _event_loop_policy = policy\ndef get_event_loop():\n    \"\"\"Return an asyncio event loop.\n    When called from a coroutine or a callback (e.g. scheduled with call_soon\n    or similar API), this function will always return the running event loop.",
        "detail": "protobuf.Lib.asyncio.events",
        "documentation": {}
    },
    {
        "label": "get_event_loop",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncio.events",
        "description": "protobuf.Lib.asyncio.events",
        "peekOfCode": "def get_event_loop():\n    \"\"\"Return an asyncio event loop.\n    When called from a coroutine or a callback (e.g. scheduled with call_soon\n    or similar API), this function will always return the running event loop.\n    If there is no running event loop set, the function will return\n    the result of `get_event_loop_policy().get_event_loop()` call.\n    \"\"\"\n    # NOTE: this function is implemented in C (see _asynciomodule.c)\n    return _py__get_event_loop()\ndef _get_event_loop(stacklevel=3):",
        "detail": "protobuf.Lib.asyncio.events",
        "documentation": {}
    },
    {
        "label": "set_event_loop",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncio.events",
        "description": "protobuf.Lib.asyncio.events",
        "peekOfCode": "def set_event_loop(loop):\n    \"\"\"Equivalent to calling get_event_loop_policy().set_event_loop(loop).\"\"\"\n    get_event_loop_policy().set_event_loop(loop)\ndef new_event_loop():\n    \"\"\"Equivalent to calling get_event_loop_policy().new_event_loop().\"\"\"\n    return get_event_loop_policy().new_event_loop()\ndef get_child_watcher():\n    \"\"\"Equivalent to calling get_event_loop_policy().get_child_watcher().\"\"\"\n    return get_event_loop_policy().get_child_watcher()\ndef set_child_watcher(watcher):",
        "detail": "protobuf.Lib.asyncio.events",
        "documentation": {}
    },
    {
        "label": "new_event_loop",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncio.events",
        "description": "protobuf.Lib.asyncio.events",
        "peekOfCode": "def new_event_loop():\n    \"\"\"Equivalent to calling get_event_loop_policy().new_event_loop().\"\"\"\n    return get_event_loop_policy().new_event_loop()\ndef get_child_watcher():\n    \"\"\"Equivalent to calling get_event_loop_policy().get_child_watcher().\"\"\"\n    return get_event_loop_policy().get_child_watcher()\ndef set_child_watcher(watcher):\n    \"\"\"Equivalent to calling\n    get_event_loop_policy().set_child_watcher(watcher).\"\"\"\n    return get_event_loop_policy().set_child_watcher(watcher)",
        "detail": "protobuf.Lib.asyncio.events",
        "documentation": {}
    },
    {
        "label": "get_child_watcher",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncio.events",
        "description": "protobuf.Lib.asyncio.events",
        "peekOfCode": "def get_child_watcher():\n    \"\"\"Equivalent to calling get_event_loop_policy().get_child_watcher().\"\"\"\n    return get_event_loop_policy().get_child_watcher()\ndef set_child_watcher(watcher):\n    \"\"\"Equivalent to calling\n    get_event_loop_policy().set_child_watcher(watcher).\"\"\"\n    return get_event_loop_policy().set_child_watcher(watcher)\n# Alias pure-Python implementations for testing purposes.\n_py__get_running_loop = _get_running_loop\n_py__set_running_loop = _set_running_loop",
        "detail": "protobuf.Lib.asyncio.events",
        "documentation": {}
    },
    {
        "label": "set_child_watcher",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncio.events",
        "description": "protobuf.Lib.asyncio.events",
        "peekOfCode": "def set_child_watcher(watcher):\n    \"\"\"Equivalent to calling\n    get_event_loop_policy().set_child_watcher(watcher).\"\"\"\n    return get_event_loop_policy().set_child_watcher(watcher)\n# Alias pure-Python implementations for testing purposes.\n_py__get_running_loop = _get_running_loop\n_py__set_running_loop = _set_running_loop\n_py_get_running_loop = get_running_loop\n_py_get_event_loop = get_event_loop\n_py__get_event_loop = _get_event_loop",
        "detail": "protobuf.Lib.asyncio.events",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.events",
        "description": "protobuf.Lib.asyncio.events",
        "peekOfCode": "__all__ = (\n    'AbstractEventLoopPolicy',\n    'AbstractEventLoop', 'AbstractServer',\n    'Handle', 'TimerHandle',\n    'get_event_loop_policy', 'set_event_loop_policy',\n    'get_event_loop', 'set_event_loop', 'new_event_loop',\n    'get_child_watcher', 'set_child_watcher',\n    '_set_running_loop', 'get_running_loop',\n    '_get_running_loop',\n)",
        "detail": "protobuf.Lib.asyncio.events",
        "documentation": {}
    },
    {
        "label": "_event_loop_policy",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.events",
        "description": "protobuf.Lib.asyncio.events",
        "peekOfCode": "_event_loop_policy = None\n# Lock for protecting the on-the-fly creation of the event loop policy.\n_lock = threading.Lock()\n# A TLS for the running event loop, used by _get_running_loop.\nclass _RunningLoop(threading.local):\n    loop_pid = (None, None)\n_running_loop = _RunningLoop()\ndef get_running_loop():\n    \"\"\"Return the running event loop.  Raise a RuntimeError if there is none.\n    This function is thread-specific.",
        "detail": "protobuf.Lib.asyncio.events",
        "documentation": {}
    },
    {
        "label": "_lock",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.events",
        "description": "protobuf.Lib.asyncio.events",
        "peekOfCode": "_lock = threading.Lock()\n# A TLS for the running event loop, used by _get_running_loop.\nclass _RunningLoop(threading.local):\n    loop_pid = (None, None)\n_running_loop = _RunningLoop()\ndef get_running_loop():\n    \"\"\"Return the running event loop.  Raise a RuntimeError if there is none.\n    This function is thread-specific.\n    \"\"\"\n    # NOTE: this function is implemented in C (see _asynciomodule.c)",
        "detail": "protobuf.Lib.asyncio.events",
        "documentation": {}
    },
    {
        "label": "_running_loop",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.events",
        "description": "protobuf.Lib.asyncio.events",
        "peekOfCode": "_running_loop = _RunningLoop()\ndef get_running_loop():\n    \"\"\"Return the running event loop.  Raise a RuntimeError if there is none.\n    This function is thread-specific.\n    \"\"\"\n    # NOTE: this function is implemented in C (see _asynciomodule.c)\n    loop = _get_running_loop()\n    if loop is None:\n        raise RuntimeError('no running event loop')\n    return loop",
        "detail": "protobuf.Lib.asyncio.events",
        "documentation": {}
    },
    {
        "label": "_py__get_running_loop",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.events",
        "description": "protobuf.Lib.asyncio.events",
        "peekOfCode": "_py__get_running_loop = _get_running_loop\n_py__set_running_loop = _set_running_loop\n_py_get_running_loop = get_running_loop\n_py_get_event_loop = get_event_loop\n_py__get_event_loop = _get_event_loop\ntry:\n    # get_event_loop() is one of the most frequently called\n    # functions in asyncio.  Pure Python implementation is\n    # about 4 times slower than C-accelerated.\n    from _asyncio import (_get_running_loop, _set_running_loop,",
        "detail": "protobuf.Lib.asyncio.events",
        "documentation": {}
    },
    {
        "label": "_py__set_running_loop",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.events",
        "description": "protobuf.Lib.asyncio.events",
        "peekOfCode": "_py__set_running_loop = _set_running_loop\n_py_get_running_loop = get_running_loop\n_py_get_event_loop = get_event_loop\n_py__get_event_loop = _get_event_loop\ntry:\n    # get_event_loop() is one of the most frequently called\n    # functions in asyncio.  Pure Python implementation is\n    # about 4 times slower than C-accelerated.\n    from _asyncio import (_get_running_loop, _set_running_loop,\n                          get_running_loop, get_event_loop, _get_event_loop)",
        "detail": "protobuf.Lib.asyncio.events",
        "documentation": {}
    },
    {
        "label": "_py_get_running_loop",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.events",
        "description": "protobuf.Lib.asyncio.events",
        "peekOfCode": "_py_get_running_loop = get_running_loop\n_py_get_event_loop = get_event_loop\n_py__get_event_loop = _get_event_loop\ntry:\n    # get_event_loop() is one of the most frequently called\n    # functions in asyncio.  Pure Python implementation is\n    # about 4 times slower than C-accelerated.\n    from _asyncio import (_get_running_loop, _set_running_loop,\n                          get_running_loop, get_event_loop, _get_event_loop)\nexcept ImportError:",
        "detail": "protobuf.Lib.asyncio.events",
        "documentation": {}
    },
    {
        "label": "_py_get_event_loop",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.events",
        "description": "protobuf.Lib.asyncio.events",
        "peekOfCode": "_py_get_event_loop = get_event_loop\n_py__get_event_loop = _get_event_loop\ntry:\n    # get_event_loop() is one of the most frequently called\n    # functions in asyncio.  Pure Python implementation is\n    # about 4 times slower than C-accelerated.\n    from _asyncio import (_get_running_loop, _set_running_loop,\n                          get_running_loop, get_event_loop, _get_event_loop)\nexcept ImportError:\n    pass",
        "detail": "protobuf.Lib.asyncio.events",
        "documentation": {}
    },
    {
        "label": "_py__get_event_loop",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.events",
        "description": "protobuf.Lib.asyncio.events",
        "peekOfCode": "_py__get_event_loop = _get_event_loop\ntry:\n    # get_event_loop() is one of the most frequently called\n    # functions in asyncio.  Pure Python implementation is\n    # about 4 times slower than C-accelerated.\n    from _asyncio import (_get_running_loop, _set_running_loop,\n                          get_running_loop, get_event_loop, _get_event_loop)\nexcept ImportError:\n    pass\nelse:",
        "detail": "protobuf.Lib.asyncio.events",
        "documentation": {}
    },
    {
        "label": "CancelledError",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.exceptions",
        "description": "protobuf.Lib.asyncio.exceptions",
        "peekOfCode": "class CancelledError(BaseException):\n    \"\"\"The Future or Task was cancelled.\"\"\"\nclass TimeoutError(Exception):\n    \"\"\"The operation exceeded the given deadline.\"\"\"\nclass InvalidStateError(Exception):\n    \"\"\"The operation is not allowed in this state.\"\"\"\nclass SendfileNotAvailableError(RuntimeError):\n    \"\"\"Sendfile syscall is not available.\n    Raised if OS does not support sendfile syscall for given socket or\n    file type.",
        "detail": "protobuf.Lib.asyncio.exceptions",
        "documentation": {}
    },
    {
        "label": "TimeoutError",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.exceptions",
        "description": "protobuf.Lib.asyncio.exceptions",
        "peekOfCode": "class TimeoutError(Exception):\n    \"\"\"The operation exceeded the given deadline.\"\"\"\nclass InvalidStateError(Exception):\n    \"\"\"The operation is not allowed in this state.\"\"\"\nclass SendfileNotAvailableError(RuntimeError):\n    \"\"\"Sendfile syscall is not available.\n    Raised if OS does not support sendfile syscall for given socket or\n    file type.\n    \"\"\"\nclass IncompleteReadError(EOFError):",
        "detail": "protobuf.Lib.asyncio.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidStateError",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.exceptions",
        "description": "protobuf.Lib.asyncio.exceptions",
        "peekOfCode": "class InvalidStateError(Exception):\n    \"\"\"The operation is not allowed in this state.\"\"\"\nclass SendfileNotAvailableError(RuntimeError):\n    \"\"\"Sendfile syscall is not available.\n    Raised if OS does not support sendfile syscall for given socket or\n    file type.\n    \"\"\"\nclass IncompleteReadError(EOFError):\n    \"\"\"\n    Incomplete read error. Attributes:",
        "detail": "protobuf.Lib.asyncio.exceptions",
        "documentation": {}
    },
    {
        "label": "SendfileNotAvailableError",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.exceptions",
        "description": "protobuf.Lib.asyncio.exceptions",
        "peekOfCode": "class SendfileNotAvailableError(RuntimeError):\n    \"\"\"Sendfile syscall is not available.\n    Raised if OS does not support sendfile syscall for given socket or\n    file type.\n    \"\"\"\nclass IncompleteReadError(EOFError):\n    \"\"\"\n    Incomplete read error. Attributes:\n    - partial: read bytes string before the end of stream was reached\n    - expected: total number of expected bytes (or None if unknown)",
        "detail": "protobuf.Lib.asyncio.exceptions",
        "documentation": {}
    },
    {
        "label": "IncompleteReadError",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.exceptions",
        "description": "protobuf.Lib.asyncio.exceptions",
        "peekOfCode": "class IncompleteReadError(EOFError):\n    \"\"\"\n    Incomplete read error. Attributes:\n    - partial: read bytes string before the end of stream was reached\n    - expected: total number of expected bytes (or None if unknown)\n    \"\"\"\n    def __init__(self, partial, expected):\n        r_expected = 'undefined' if expected is None else repr(expected)\n        super().__init__(f'{len(partial)} bytes read on a total of '\n                         f'{r_expected} expected bytes')",
        "detail": "protobuf.Lib.asyncio.exceptions",
        "documentation": {}
    },
    {
        "label": "LimitOverrunError",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.exceptions",
        "description": "protobuf.Lib.asyncio.exceptions",
        "peekOfCode": "class LimitOverrunError(Exception):\n    \"\"\"Reached the buffer limit while looking for a separator.\n    Attributes:\n    - consumed: total number of to be consumed bytes.\n    \"\"\"\n    def __init__(self, message, consumed):\n        super().__init__(message)\n        self.consumed = consumed\n    def __reduce__(self):\n        return type(self), (self.args[0], self.consumed)",
        "detail": "protobuf.Lib.asyncio.exceptions",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.exceptions",
        "description": "protobuf.Lib.asyncio.exceptions",
        "peekOfCode": "__all__ = ('CancelledError', 'InvalidStateError', 'TimeoutError',\n           'IncompleteReadError', 'LimitOverrunError',\n           'SendfileNotAvailableError')\nclass CancelledError(BaseException):\n    \"\"\"The Future or Task was cancelled.\"\"\"\nclass TimeoutError(Exception):\n    \"\"\"The operation exceeded the given deadline.\"\"\"\nclass InvalidStateError(Exception):\n    \"\"\"The operation is not allowed in this state.\"\"\"\nclass SendfileNotAvailableError(RuntimeError):",
        "detail": "protobuf.Lib.asyncio.exceptions",
        "documentation": {}
    },
    {
        "label": "extract_stack",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncio.format_helpers",
        "description": "protobuf.Lib.asyncio.format_helpers",
        "peekOfCode": "def extract_stack(f=None, limit=None):\n    \"\"\"Replacement for traceback.extract_stack() that only does the\n    necessary work for asyncio debug mode.\n    \"\"\"\n    if f is None:\n        f = sys._getframe().f_back\n    if limit is None:\n        # Limit the amount of work to a reasonable amount, as extract_stack()\n        # can be called for each coroutine and future in debug mode.\n        limit = constants.DEBUG_STACK_DEPTH",
        "detail": "protobuf.Lib.asyncio.format_helpers",
        "documentation": {}
    },
    {
        "label": "Future",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.futures",
        "description": "protobuf.Lib.asyncio.futures",
        "peekOfCode": "class Future:\n    \"\"\"This class is *almost* compatible with concurrent.futures.Future.\n    Differences:\n    - This class is not thread-safe.\n    - result() and exception() do not take a timeout argument and\n      raise an exception when the future isn't done yet.\n    - Callbacks registered with add_done_callback() are always called\n      via the event loop's call_soon().\n    - This class is not compatible with the wait() and as_completed()\n      methods in the concurrent.futures package.",
        "detail": "protobuf.Lib.asyncio.futures",
        "documentation": {}
    },
    {
        "label": "wrap_future",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncio.futures",
        "description": "protobuf.Lib.asyncio.futures",
        "peekOfCode": "def wrap_future(future, *, loop=None):\n    \"\"\"Wrap concurrent.futures.Future object.\"\"\"\n    if isfuture(future):\n        return future\n    assert isinstance(future, concurrent.futures.Future), \\\n        f'concurrent.futures.Future is expected, got {future!r}'\n    if loop is None:\n        loop = events._get_event_loop()\n    new_future = loop.create_future()\n    _chain_future(future, new_future)",
        "detail": "protobuf.Lib.asyncio.futures",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.futures",
        "description": "protobuf.Lib.asyncio.futures",
        "peekOfCode": "__all__ = (\n    'Future', 'wrap_future', 'isfuture',\n)\nimport concurrent.futures\nimport contextvars\nimport logging\nimport sys\nfrom types import GenericAlias\nfrom . import base_futures\nfrom . import events",
        "detail": "protobuf.Lib.asyncio.futures",
        "documentation": {}
    },
    {
        "label": "isfuture",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.futures",
        "description": "protobuf.Lib.asyncio.futures",
        "peekOfCode": "isfuture = base_futures.isfuture\n_PENDING = base_futures._PENDING\n_CANCELLED = base_futures._CANCELLED\n_FINISHED = base_futures._FINISHED\nSTACK_DEBUG = logging.DEBUG - 1  # heavy-duty debugging\nclass Future:\n    \"\"\"This class is *almost* compatible with concurrent.futures.Future.\n    Differences:\n    - This class is not thread-safe.\n    - result() and exception() do not take a timeout argument and",
        "detail": "protobuf.Lib.asyncio.futures",
        "documentation": {}
    },
    {
        "label": "_PENDING",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.futures",
        "description": "protobuf.Lib.asyncio.futures",
        "peekOfCode": "_PENDING = base_futures._PENDING\n_CANCELLED = base_futures._CANCELLED\n_FINISHED = base_futures._FINISHED\nSTACK_DEBUG = logging.DEBUG - 1  # heavy-duty debugging\nclass Future:\n    \"\"\"This class is *almost* compatible with concurrent.futures.Future.\n    Differences:\n    - This class is not thread-safe.\n    - result() and exception() do not take a timeout argument and\n      raise an exception when the future isn't done yet.",
        "detail": "protobuf.Lib.asyncio.futures",
        "documentation": {}
    },
    {
        "label": "_CANCELLED",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.futures",
        "description": "protobuf.Lib.asyncio.futures",
        "peekOfCode": "_CANCELLED = base_futures._CANCELLED\n_FINISHED = base_futures._FINISHED\nSTACK_DEBUG = logging.DEBUG - 1  # heavy-duty debugging\nclass Future:\n    \"\"\"This class is *almost* compatible with concurrent.futures.Future.\n    Differences:\n    - This class is not thread-safe.\n    - result() and exception() do not take a timeout argument and\n      raise an exception when the future isn't done yet.\n    - Callbacks registered with add_done_callback() are always called",
        "detail": "protobuf.Lib.asyncio.futures",
        "documentation": {}
    },
    {
        "label": "_FINISHED",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.futures",
        "description": "protobuf.Lib.asyncio.futures",
        "peekOfCode": "_FINISHED = base_futures._FINISHED\nSTACK_DEBUG = logging.DEBUG - 1  # heavy-duty debugging\nclass Future:\n    \"\"\"This class is *almost* compatible with concurrent.futures.Future.\n    Differences:\n    - This class is not thread-safe.\n    - result() and exception() do not take a timeout argument and\n      raise an exception when the future isn't done yet.\n    - Callbacks registered with add_done_callback() are always called\n      via the event loop's call_soon().",
        "detail": "protobuf.Lib.asyncio.futures",
        "documentation": {}
    },
    {
        "label": "STACK_DEBUG",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.futures",
        "description": "protobuf.Lib.asyncio.futures",
        "peekOfCode": "STACK_DEBUG = logging.DEBUG - 1  # heavy-duty debugging\nclass Future:\n    \"\"\"This class is *almost* compatible with concurrent.futures.Future.\n    Differences:\n    - This class is not thread-safe.\n    - result() and exception() do not take a timeout argument and\n      raise an exception when the future isn't done yet.\n    - Callbacks registered with add_done_callback() are always called\n      via the event loop's call_soon().\n    - This class is not compatible with the wait() and as_completed()",
        "detail": "protobuf.Lib.asyncio.futures",
        "documentation": {}
    },
    {
        "label": "_PyFuture",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.futures",
        "description": "protobuf.Lib.asyncio.futures",
        "peekOfCode": "_PyFuture = Future\ndef _get_loop(fut):\n    # Tries to call Future.get_loop() if it's available.\n    # Otherwise fallbacks to using the old '_loop' property.\n    try:\n        get_loop = fut.get_loop\n    except AttributeError:\n        pass\n    else:\n        return get_loop()",
        "detail": "protobuf.Lib.asyncio.futures",
        "documentation": {}
    },
    {
        "label": "_ContextManagerMixin",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.locks",
        "description": "protobuf.Lib.asyncio.locks",
        "peekOfCode": "class _ContextManagerMixin:\n    async def __aenter__(self):\n        await self.acquire()\n        # We have no use for the \"as ...\"  clause in the with\n        # statement for locks.\n        return None\n    async def __aexit__(self, exc_type, exc, tb):\n        self.release()\nclass Lock(_ContextManagerMixin, mixins._LoopBoundMixin):\n    \"\"\"Primitive lock objects.",
        "detail": "protobuf.Lib.asyncio.locks",
        "documentation": {}
    },
    {
        "label": "Lock",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.locks",
        "description": "protobuf.Lib.asyncio.locks",
        "peekOfCode": "class Lock(_ContextManagerMixin, mixins._LoopBoundMixin):\n    \"\"\"Primitive lock objects.\n    A primitive lock is a synchronization primitive that is not owned\n    by a particular coroutine when locked.  A primitive lock is in one\n    of two states, 'locked' or 'unlocked'.\n    It is created in the unlocked state.  It has two basic methods,\n    acquire() and release().  When the state is unlocked, acquire()\n    changes the state to locked and returns immediately.  When the\n    state is locked, acquire() blocks until a call to release() in\n    another coroutine changes it to unlocked, then the acquire() call",
        "detail": "protobuf.Lib.asyncio.locks",
        "documentation": {}
    },
    {
        "label": "Event",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.locks",
        "description": "protobuf.Lib.asyncio.locks",
        "peekOfCode": "class Event(mixins._LoopBoundMixin):\n    \"\"\"Asynchronous equivalent to threading.Event.\n    Class implementing event objects. An event manages a flag that can be set\n    to true with the set() method and reset to false with the clear() method.\n    The wait() method blocks until the flag is true. The flag is initially\n    false.\n    \"\"\"\n    def __init__(self, *, loop=mixins._marker):\n        super().__init__(loop=loop)\n        self._waiters = collections.deque()",
        "detail": "protobuf.Lib.asyncio.locks",
        "documentation": {}
    },
    {
        "label": "Condition",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.locks",
        "description": "protobuf.Lib.asyncio.locks",
        "peekOfCode": "class Condition(_ContextManagerMixin, mixins._LoopBoundMixin):\n    \"\"\"Asynchronous equivalent to threading.Condition.\n    This class implements condition variable objects. A condition variable\n    allows one or more coroutines to wait until they are notified by another\n    coroutine.\n    A new Lock object is created and used as the underlying lock.\n    \"\"\"\n    def __init__(self, lock=None, *, loop=mixins._marker):\n        super().__init__(loop=loop)\n        if lock is None:",
        "detail": "protobuf.Lib.asyncio.locks",
        "documentation": {}
    },
    {
        "label": "Semaphore",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.locks",
        "description": "protobuf.Lib.asyncio.locks",
        "peekOfCode": "class Semaphore(_ContextManagerMixin, mixins._LoopBoundMixin):\n    \"\"\"A Semaphore implementation.\n    A semaphore manages an internal counter which is decremented by each\n    acquire() call and incremented by each release() call. The counter\n    can never go below zero; when acquire() finds that it is zero, it blocks,\n    waiting until some other thread calls release().\n    Semaphores also support the context management protocol.\n    The optional argument gives the initial value for the internal\n    counter; it defaults to 1. If the value given is less than 0,\n    ValueError is raised.",
        "detail": "protobuf.Lib.asyncio.locks",
        "documentation": {}
    },
    {
        "label": "BoundedSemaphore",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.locks",
        "description": "protobuf.Lib.asyncio.locks",
        "peekOfCode": "class BoundedSemaphore(Semaphore):\n    \"\"\"A bounded semaphore implementation.\n    This raises ValueError in release() if it would increase the value\n    above the initial value.\n    \"\"\"\n    def __init__(self, value=1, *, loop=mixins._marker):\n        self._bound_value = value\n        super().__init__(value, loop=loop)\n    def release(self):\n        if self._value >= self._bound_value:",
        "detail": "protobuf.Lib.asyncio.locks",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.locks",
        "description": "protobuf.Lib.asyncio.locks",
        "peekOfCode": "__all__ = ('Lock', 'Event', 'Condition', 'Semaphore', 'BoundedSemaphore')\nimport collections\nfrom . import exceptions\nfrom . import mixins\nfrom . import tasks\nclass _ContextManagerMixin:\n    async def __aenter__(self):\n        await self.acquire()\n        # We have no use for the \"as ...\"  clause in the with\n        # statement for locks.",
        "detail": "protobuf.Lib.asyncio.locks",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.log",
        "description": "protobuf.Lib.asyncio.log",
        "peekOfCode": "logger = logging.getLogger(__package__)",
        "detail": "protobuf.Lib.asyncio.log",
        "documentation": {}
    },
    {
        "label": "_LoopBoundMixin",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.mixins",
        "description": "protobuf.Lib.asyncio.mixins",
        "peekOfCode": "class _LoopBoundMixin:\n    _loop = None\n    def __init__(self, *, loop=_marker):\n        if loop is not _marker:\n            raise TypeError(\n                f'As of 3.10, the *loop* parameter was removed from '\n                f'{type(self).__name__}() since it is no longer necessary'\n            )\n    def _get_loop(self):\n        loop = events._get_running_loop()",
        "detail": "protobuf.Lib.asyncio.mixins",
        "documentation": {}
    },
    {
        "label": "_global_lock",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.mixins",
        "description": "protobuf.Lib.asyncio.mixins",
        "peekOfCode": "_global_lock = threading.Lock()\n# Used as a sentinel for loop parameter\n_marker = object()\nclass _LoopBoundMixin:\n    _loop = None\n    def __init__(self, *, loop=_marker):\n        if loop is not _marker:\n            raise TypeError(\n                f'As of 3.10, the *loop* parameter was removed from '\n                f'{type(self).__name__}() since it is no longer necessary'",
        "detail": "protobuf.Lib.asyncio.mixins",
        "documentation": {}
    },
    {
        "label": "_marker",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.mixins",
        "description": "protobuf.Lib.asyncio.mixins",
        "peekOfCode": "_marker = object()\nclass _LoopBoundMixin:\n    _loop = None\n    def __init__(self, *, loop=_marker):\n        if loop is not _marker:\n            raise TypeError(\n                f'As of 3.10, the *loop* parameter was removed from '\n                f'{type(self).__name__}() since it is no longer necessary'\n            )\n    def _get_loop(self):",
        "detail": "protobuf.Lib.asyncio.mixins",
        "documentation": {}
    },
    {
        "label": "_ProactorBasePipeTransport",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.proactor_events",
        "description": "protobuf.Lib.asyncio.proactor_events",
        "peekOfCode": "class _ProactorBasePipeTransport(transports._FlowControlMixin,\n                                 transports.BaseTransport):\n    \"\"\"Base class for pipe and socket transports.\"\"\"\n    def __init__(self, loop, sock, protocol, waiter=None,\n                 extra=None, server=None):\n        super().__init__(extra, loop)\n        self._set_extra(sock)\n        self._sock = sock\n        self.set_protocol(protocol)\n        self._server = server",
        "detail": "protobuf.Lib.asyncio.proactor_events",
        "documentation": {}
    },
    {
        "label": "_ProactorReadPipeTransport",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.proactor_events",
        "description": "protobuf.Lib.asyncio.proactor_events",
        "peekOfCode": "class _ProactorReadPipeTransport(_ProactorBasePipeTransport,\n                                 transports.ReadTransport):\n    \"\"\"Transport for read pipes.\"\"\"\n    def __init__(self, loop, sock, protocol, waiter=None,\n                 extra=None, server=None, buffer_size=65536):\n        self._pending_data_length = -1\n        self._paused = True\n        super().__init__(loop, sock, protocol, waiter, extra, server)\n        self._data = bytearray(buffer_size)\n        self._loop.call_soon(self._loop_reading)",
        "detail": "protobuf.Lib.asyncio.proactor_events",
        "documentation": {}
    },
    {
        "label": "_ProactorBaseWritePipeTransport",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.proactor_events",
        "description": "protobuf.Lib.asyncio.proactor_events",
        "peekOfCode": "class _ProactorBaseWritePipeTransport(_ProactorBasePipeTransport,\n                                      transports.WriteTransport):\n    \"\"\"Transport for write pipes.\"\"\"\n    _start_tls_compatible = True\n    def __init__(self, *args, **kw):\n        super().__init__(*args, **kw)\n        self._empty_waiter = None\n    def write(self, data):\n        if not isinstance(data, (bytes, bytearray, memoryview)):\n            raise TypeError(",
        "detail": "protobuf.Lib.asyncio.proactor_events",
        "documentation": {}
    },
    {
        "label": "_ProactorWritePipeTransport",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.proactor_events",
        "description": "protobuf.Lib.asyncio.proactor_events",
        "peekOfCode": "class _ProactorWritePipeTransport(_ProactorBaseWritePipeTransport):\n    def __init__(self, *args, **kw):\n        super().__init__(*args, **kw)\n        self._read_fut = self._loop._proactor.recv(self._sock, 16)\n        self._read_fut.add_done_callback(self._pipe_closed)\n    def _pipe_closed(self, fut):\n        if fut.cancelled():\n            # the transport has been closed\n            return\n        assert fut.result() == b''",
        "detail": "protobuf.Lib.asyncio.proactor_events",
        "documentation": {}
    },
    {
        "label": "_ProactorDatagramTransport",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.proactor_events",
        "description": "protobuf.Lib.asyncio.proactor_events",
        "peekOfCode": "class _ProactorDatagramTransport(_ProactorBasePipeTransport,\n                                 transports.DatagramTransport):\n    max_size = 256 * 1024\n    def __init__(self, loop, sock, protocol, address=None,\n                 waiter=None, extra=None):\n        self._address = address\n        self._empty_waiter = None\n        # We don't need to call _protocol.connection_made() since our base\n        # constructor does it for us.\n        super().__init__(loop, sock, protocol, waiter=waiter, extra=extra)",
        "detail": "protobuf.Lib.asyncio.proactor_events",
        "documentation": {}
    },
    {
        "label": "_ProactorDuplexPipeTransport",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.proactor_events",
        "description": "protobuf.Lib.asyncio.proactor_events",
        "peekOfCode": "class _ProactorDuplexPipeTransport(_ProactorReadPipeTransport,\n                                   _ProactorBaseWritePipeTransport,\n                                   transports.Transport):\n    \"\"\"Transport for duplex pipes.\"\"\"\n    def can_write_eof(self):\n        return False\n    def write_eof(self):\n        raise NotImplementedError\nclass _ProactorSocketTransport(_ProactorReadPipeTransport,\n                               _ProactorBaseWritePipeTransport,",
        "detail": "protobuf.Lib.asyncio.proactor_events",
        "documentation": {}
    },
    {
        "label": "_ProactorSocketTransport",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.proactor_events",
        "description": "protobuf.Lib.asyncio.proactor_events",
        "peekOfCode": "class _ProactorSocketTransport(_ProactorReadPipeTransport,\n                               _ProactorBaseWritePipeTransport,\n                               transports.Transport):\n    \"\"\"Transport for connected sockets.\"\"\"\n    _sendfile_compatible = constants._SendfileMode.TRY_NATIVE\n    def __init__(self, loop, sock, protocol, waiter=None,\n                 extra=None, server=None):\n        super().__init__(loop, sock, protocol, waiter, extra, server)\n        base_events._set_nodelay(sock)\n    def _set_extra(self, sock):",
        "detail": "protobuf.Lib.asyncio.proactor_events",
        "documentation": {}
    },
    {
        "label": "BaseProactorEventLoop",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.proactor_events",
        "description": "protobuf.Lib.asyncio.proactor_events",
        "peekOfCode": "class BaseProactorEventLoop(base_events.BaseEventLoop):\n    def __init__(self, proactor):\n        super().__init__()\n        logger.debug('Using proactor: %s', proactor.__class__.__name__)\n        self._proactor = proactor\n        self._selector = proactor   # convenient alias\n        self._self_reading_future = None\n        self._accept_futures = {}   # socket file descriptor => Future\n        proactor.set_loop(self)\n        self._make_self_pipe()",
        "detail": "protobuf.Lib.asyncio.proactor_events",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.proactor_events",
        "description": "protobuf.Lib.asyncio.proactor_events",
        "peekOfCode": "__all__ = 'BaseProactorEventLoop',\nimport io\nimport os\nimport socket\nimport warnings\nimport signal\nimport threading\nimport collections\nfrom . import base_events\nfrom . import constants",
        "detail": "protobuf.Lib.asyncio.proactor_events",
        "documentation": {}
    },
    {
        "label": "BaseProtocol",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.protocols",
        "description": "protobuf.Lib.asyncio.protocols",
        "peekOfCode": "class BaseProtocol:\n    \"\"\"Common base class for protocol interfaces.\n    Usually user implements protocols that derived from BaseProtocol\n    like Protocol or ProcessProtocol.\n    The only case when BaseProtocol should be implemented directly is\n    write-only transport like write pipe\n    \"\"\"\n    __slots__ = ()\n    def connection_made(self, transport):\n        \"\"\"Called when a connection is made.",
        "detail": "protobuf.Lib.asyncio.protocols",
        "documentation": {}
    },
    {
        "label": "Protocol",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.protocols",
        "description": "protobuf.Lib.asyncio.protocols",
        "peekOfCode": "class Protocol(BaseProtocol):\n    \"\"\"Interface for stream protocol.\n    The user should implement this interface.  They can inherit from\n    this class but don't need to.  The implementations here do\n    nothing (they don't raise exceptions).\n    When the user wants to requests a transport, they pass a protocol\n    factory to a utility function (e.g., EventLoop.create_connection()).\n    When the connection is made successfully, connection_made() is\n    called with a suitable transport object.  Then data_received()\n    will be called 0 or more times with data (bytes) received from the",
        "detail": "protobuf.Lib.asyncio.protocols",
        "documentation": {}
    },
    {
        "label": "BufferedProtocol",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.protocols",
        "description": "protobuf.Lib.asyncio.protocols",
        "peekOfCode": "class BufferedProtocol(BaseProtocol):\n    \"\"\"Interface for stream protocol with manual buffer control.\n    Event methods, such as `create_server` and `create_connection`,\n    accept factories that return protocols that implement this interface.\n    The idea of BufferedProtocol is that it allows to manually allocate\n    and control the receive buffer.  Event loops can then use the buffer\n    provided by the protocol to avoid unnecessary data copies.  This\n    can result in noticeable performance improvement for protocols that\n    receive big amounts of data.  Sophisticated protocols can allocate\n    the buffer only once at creation time.",
        "detail": "protobuf.Lib.asyncio.protocols",
        "documentation": {}
    },
    {
        "label": "DatagramProtocol",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.protocols",
        "description": "protobuf.Lib.asyncio.protocols",
        "peekOfCode": "class DatagramProtocol(BaseProtocol):\n    \"\"\"Interface for datagram protocol.\"\"\"\n    __slots__ = ()\n    def datagram_received(self, data, addr):\n        \"\"\"Called when some datagram is received.\"\"\"\n    def error_received(self, exc):\n        \"\"\"Called when a send or receive operation raises an OSError.\n        (Other than BlockingIOError or InterruptedError.)\n        \"\"\"\nclass SubprocessProtocol(BaseProtocol):",
        "detail": "protobuf.Lib.asyncio.protocols",
        "documentation": {}
    },
    {
        "label": "SubprocessProtocol",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.protocols",
        "description": "protobuf.Lib.asyncio.protocols",
        "peekOfCode": "class SubprocessProtocol(BaseProtocol):\n    \"\"\"Interface for protocol for subprocess calls.\"\"\"\n    __slots__ = ()\n    def pipe_data_received(self, fd, data):\n        \"\"\"Called when the subprocess writes data into stdout/stderr pipe.\n        fd is int file descriptor.\n        data is bytes object.\n        \"\"\"\n    def pipe_connection_lost(self, fd, exc):\n        \"\"\"Called when a file descriptor associated with the child process is",
        "detail": "protobuf.Lib.asyncio.protocols",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.protocols",
        "description": "protobuf.Lib.asyncio.protocols",
        "peekOfCode": "__all__ = (\n    'BaseProtocol', 'Protocol', 'DatagramProtocol',\n    'SubprocessProtocol', 'BufferedProtocol',\n)\nclass BaseProtocol:\n    \"\"\"Common base class for protocol interfaces.\n    Usually user implements protocols that derived from BaseProtocol\n    like Protocol or ProcessProtocol.\n    The only case when BaseProtocol should be implemented directly is\n    write-only transport like write pipe",
        "detail": "protobuf.Lib.asyncio.protocols",
        "documentation": {}
    },
    {
        "label": "QueueEmpty",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.queues",
        "description": "protobuf.Lib.asyncio.queues",
        "peekOfCode": "class QueueEmpty(Exception):\n    \"\"\"Raised when Queue.get_nowait() is called on an empty Queue.\"\"\"\n    pass\nclass QueueFull(Exception):\n    \"\"\"Raised when the Queue.put_nowait() method is called on a full Queue.\"\"\"\n    pass\nclass Queue(mixins._LoopBoundMixin):\n    \"\"\"A queue, useful for coordinating producer and consumer coroutines.\n    If maxsize is less than or equal to zero, the queue size is infinite. If it\n    is an integer greater than 0, then \"await put()\" will block when the",
        "detail": "protobuf.Lib.asyncio.queues",
        "documentation": {}
    },
    {
        "label": "QueueFull",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.queues",
        "description": "protobuf.Lib.asyncio.queues",
        "peekOfCode": "class QueueFull(Exception):\n    \"\"\"Raised when the Queue.put_nowait() method is called on a full Queue.\"\"\"\n    pass\nclass Queue(mixins._LoopBoundMixin):\n    \"\"\"A queue, useful for coordinating producer and consumer coroutines.\n    If maxsize is less than or equal to zero, the queue size is infinite. If it\n    is an integer greater than 0, then \"await put()\" will block when the\n    queue reaches maxsize, until an item is removed by get().\n    Unlike the standard library Queue, you can reliably know this Queue's size\n    with qsize(), since your single-threaded asyncio application won't be",
        "detail": "protobuf.Lib.asyncio.queues",
        "documentation": {}
    },
    {
        "label": "Queue",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.queues",
        "description": "protobuf.Lib.asyncio.queues",
        "peekOfCode": "class Queue(mixins._LoopBoundMixin):\n    \"\"\"A queue, useful for coordinating producer and consumer coroutines.\n    If maxsize is less than or equal to zero, the queue size is infinite. If it\n    is an integer greater than 0, then \"await put()\" will block when the\n    queue reaches maxsize, until an item is removed by get().\n    Unlike the standard library Queue, you can reliably know this Queue's size\n    with qsize(), since your single-threaded asyncio application won't be\n    interrupted between calling qsize() and doing an operation on the Queue.\n    \"\"\"\n    def __init__(self, maxsize=0, *, loop=mixins._marker):",
        "detail": "protobuf.Lib.asyncio.queues",
        "documentation": {}
    },
    {
        "label": "PriorityQueue",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.queues",
        "description": "protobuf.Lib.asyncio.queues",
        "peekOfCode": "class PriorityQueue(Queue):\n    \"\"\"A subclass of Queue; retrieves entries in priority order (lowest first).\n    Entries are typically tuples of the form: (priority number, data).\n    \"\"\"\n    def _init(self, maxsize):\n        self._queue = []\n    def _put(self, item, heappush=heapq.heappush):\n        heappush(self._queue, item)\n    def _get(self, heappop=heapq.heappop):\n        return heappop(self._queue)",
        "detail": "protobuf.Lib.asyncio.queues",
        "documentation": {}
    },
    {
        "label": "LifoQueue",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.queues",
        "description": "protobuf.Lib.asyncio.queues",
        "peekOfCode": "class LifoQueue(Queue):\n    \"\"\"A subclass of Queue that retrieves most recently added entries first.\"\"\"\n    def _init(self, maxsize):\n        self._queue = []\n    def _put(self, item):\n        self._queue.append(item)\n    def _get(self):\n        return self._queue.pop()",
        "detail": "protobuf.Lib.asyncio.queues",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.queues",
        "description": "protobuf.Lib.asyncio.queues",
        "peekOfCode": "__all__ = ('Queue', 'PriorityQueue', 'LifoQueue', 'QueueFull', 'QueueEmpty')\nimport collections\nimport heapq\nfrom types import GenericAlias\nfrom . import locks\nfrom . import mixins\nclass QueueEmpty(Exception):\n    \"\"\"Raised when Queue.get_nowait() is called on an empty Queue.\"\"\"\n    pass\nclass QueueFull(Exception):",
        "detail": "protobuf.Lib.asyncio.queues",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncio.runners",
        "description": "protobuf.Lib.asyncio.runners",
        "peekOfCode": "def run(main, *, debug=None):\n    \"\"\"Execute the coroutine and return the result.\n    This function runs the passed coroutine, taking care of\n    managing the asyncio event loop and finalizing asynchronous\n    generators.\n    This function cannot be called when another asyncio event loop is\n    running in the same thread.\n    If debug is True, the event loop will be run in debug mode.\n    This function always creates a new event loop and closes it at the end.\n    It should be used as a main entry point for asyncio programs, and should",
        "detail": "protobuf.Lib.asyncio.runners",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.runners",
        "description": "protobuf.Lib.asyncio.runners",
        "peekOfCode": "__all__ = 'run',\nfrom . import coroutines\nfrom . import events\nfrom . import tasks\ndef run(main, *, debug=None):\n    \"\"\"Execute the coroutine and return the result.\n    This function runs the passed coroutine, taking care of\n    managing the asyncio event loop and finalizing asynchronous\n    generators.\n    This function cannot be called when another asyncio event loop is",
        "detail": "protobuf.Lib.asyncio.runners",
        "documentation": {}
    },
    {
        "label": "BaseSelectorEventLoop",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.selector_events",
        "description": "protobuf.Lib.asyncio.selector_events",
        "peekOfCode": "class BaseSelectorEventLoop(base_events.BaseEventLoop):\n    \"\"\"Selector event loop.\n    See events.EventLoop for API specification.\n    \"\"\"\n    def __init__(self, selector=None):\n        super().__init__()\n        if selector is None:\n            selector = selectors.DefaultSelector()\n        logger.debug('Using selector: %s', selector.__class__.__name__)\n        self._selector = selector",
        "detail": "protobuf.Lib.asyncio.selector_events",
        "documentation": {}
    },
    {
        "label": "_SelectorTransport",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.selector_events",
        "description": "protobuf.Lib.asyncio.selector_events",
        "peekOfCode": "class _SelectorTransport(transports._FlowControlMixin,\n                         transports.Transport):\n    max_size = 256 * 1024  # Buffer size passed to recv().\n    _buffer_factory = bytearray  # Constructs initial value for self._buffer.\n    # Attribute used in the destructor: it must be set even if the constructor\n    # is not called (see _SelectorSslTransport which may start by raising an\n    # exception)\n    _sock = None\n    def __init__(self, loop, sock, protocol, extra=None, server=None):\n        super().__init__(extra, loop)",
        "detail": "protobuf.Lib.asyncio.selector_events",
        "documentation": {}
    },
    {
        "label": "_SelectorSocketTransport",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.selector_events",
        "description": "protobuf.Lib.asyncio.selector_events",
        "peekOfCode": "class _SelectorSocketTransport(_SelectorTransport):\n    _start_tls_compatible = True\n    _sendfile_compatible = constants._SendfileMode.TRY_NATIVE\n    def __init__(self, loop, sock, protocol, waiter=None,\n                 extra=None, server=None):\n        self._read_ready_cb = None\n        super().__init__(loop, sock, protocol, extra, server)\n        self._eof = False\n        self._paused = False\n        self._empty_waiter = None",
        "detail": "protobuf.Lib.asyncio.selector_events",
        "documentation": {}
    },
    {
        "label": "_SelectorDatagramTransport",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.selector_events",
        "description": "protobuf.Lib.asyncio.selector_events",
        "peekOfCode": "class _SelectorDatagramTransport(_SelectorTransport):\n    _buffer_factory = collections.deque\n    def __init__(self, loop, sock, protocol, address=None,\n                 waiter=None, extra=None):\n        super().__init__(loop, sock, protocol, extra)\n        self._address = address\n        self._loop.call_soon(self._protocol.connection_made, self)\n        # only start reading when connection_made() has been called\n        self._loop.call_soon(self._add_reader,\n                             self._sock_fd, self._read_ready)",
        "detail": "protobuf.Lib.asyncio.selector_events",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.selector_events",
        "description": "protobuf.Lib.asyncio.selector_events",
        "peekOfCode": "__all__ = 'BaseSelectorEventLoop',\nimport collections\nimport errno\nimport functools\nimport selectors\nimport socket\nimport warnings\nimport weakref\ntry:\n    import ssl",
        "detail": "protobuf.Lib.asyncio.selector_events",
        "documentation": {}
    },
    {
        "label": "_SSLPipe",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.sslproto",
        "description": "protobuf.Lib.asyncio.sslproto",
        "peekOfCode": "class _SSLPipe(object):\n    \"\"\"An SSL \"Pipe\".\n    An SSL pipe allows you to communicate with an SSL/TLS protocol instance\n    through memory buffers. It can be used to implement a security layer for an\n    existing connection where you don't have access to the connection's file\n    descriptor, or for some reason you don't want to use it.\n    An SSL pipe can be in \"wrapped\" and \"unwrapped\" mode. In unwrapped mode,\n    data is passed through untransformed. In wrapped mode, application level\n    data is encrypted to SSL record level data and vice versa. The SSL record\n    level is the lowest level in the SSL protocol suite and is what travels",
        "detail": "protobuf.Lib.asyncio.sslproto",
        "documentation": {}
    },
    {
        "label": "_SSLProtocolTransport",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.sslproto",
        "description": "protobuf.Lib.asyncio.sslproto",
        "peekOfCode": "class _SSLProtocolTransport(transports._FlowControlMixin,\n                            transports.Transport):\n    _sendfile_compatible = constants._SendfileMode.FALLBACK\n    def __init__(self, loop, ssl_protocol):\n        self._loop = loop\n        # SSLProtocol instance\n        self._ssl_protocol = ssl_protocol\n        self._closed = False\n    def get_extra_info(self, name, default=None):\n        \"\"\"Get optional transport information.\"\"\"",
        "detail": "protobuf.Lib.asyncio.sslproto",
        "documentation": {}
    },
    {
        "label": "SSLProtocol",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.sslproto",
        "description": "protobuf.Lib.asyncio.sslproto",
        "peekOfCode": "class SSLProtocol(protocols.Protocol):\n    \"\"\"SSL protocol.\n    Implementation of SSL on top of a socket using incoming and outgoing\n    buffers which are ssl.MemoryBIO objects.\n    \"\"\"\n    def __init__(self, loop, app_protocol, sslcontext, waiter,\n                 server_side=False, server_hostname=None,\n                 call_connection_made=True,\n                 ssl_handshake_timeout=None):\n        if ssl is None:",
        "detail": "protobuf.Lib.asyncio.sslproto",
        "documentation": {}
    },
    {
        "label": "_UNWRAPPED",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.sslproto",
        "description": "protobuf.Lib.asyncio.sslproto",
        "peekOfCode": "_UNWRAPPED = \"UNWRAPPED\"\n_DO_HANDSHAKE = \"DO_HANDSHAKE\"\n_WRAPPED = \"WRAPPED\"\n_SHUTDOWN = \"SHUTDOWN\"\nclass _SSLPipe(object):\n    \"\"\"An SSL \"Pipe\".\n    An SSL pipe allows you to communicate with an SSL/TLS protocol instance\n    through memory buffers. It can be used to implement a security layer for an\n    existing connection where you don't have access to the connection's file\n    descriptor, or for some reason you don't want to use it.",
        "detail": "protobuf.Lib.asyncio.sslproto",
        "documentation": {}
    },
    {
        "label": "_DO_HANDSHAKE",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.sslproto",
        "description": "protobuf.Lib.asyncio.sslproto",
        "peekOfCode": "_DO_HANDSHAKE = \"DO_HANDSHAKE\"\n_WRAPPED = \"WRAPPED\"\n_SHUTDOWN = \"SHUTDOWN\"\nclass _SSLPipe(object):\n    \"\"\"An SSL \"Pipe\".\n    An SSL pipe allows you to communicate with an SSL/TLS protocol instance\n    through memory buffers. It can be used to implement a security layer for an\n    existing connection where you don't have access to the connection's file\n    descriptor, or for some reason you don't want to use it.\n    An SSL pipe can be in \"wrapped\" and \"unwrapped\" mode. In unwrapped mode,",
        "detail": "protobuf.Lib.asyncio.sslproto",
        "documentation": {}
    },
    {
        "label": "_WRAPPED",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.sslproto",
        "description": "protobuf.Lib.asyncio.sslproto",
        "peekOfCode": "_WRAPPED = \"WRAPPED\"\n_SHUTDOWN = \"SHUTDOWN\"\nclass _SSLPipe(object):\n    \"\"\"An SSL \"Pipe\".\n    An SSL pipe allows you to communicate with an SSL/TLS protocol instance\n    through memory buffers. It can be used to implement a security layer for an\n    existing connection where you don't have access to the connection's file\n    descriptor, or for some reason you don't want to use it.\n    An SSL pipe can be in \"wrapped\" and \"unwrapped\" mode. In unwrapped mode,\n    data is passed through untransformed. In wrapped mode, application level",
        "detail": "protobuf.Lib.asyncio.sslproto",
        "documentation": {}
    },
    {
        "label": "_SHUTDOWN",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.sslproto",
        "description": "protobuf.Lib.asyncio.sslproto",
        "peekOfCode": "_SHUTDOWN = \"SHUTDOWN\"\nclass _SSLPipe(object):\n    \"\"\"An SSL \"Pipe\".\n    An SSL pipe allows you to communicate with an SSL/TLS protocol instance\n    through memory buffers. It can be used to implement a security layer for an\n    existing connection where you don't have access to the connection's file\n    descriptor, or for some reason you don't want to use it.\n    An SSL pipe can be in \"wrapped\" and \"unwrapped\" mode. In unwrapped mode,\n    data is passed through untransformed. In wrapped mode, application level\n    data is encrypted to SSL record level data and vice versa. The SSL record",
        "detail": "protobuf.Lib.asyncio.sslproto",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.staggered",
        "description": "protobuf.Lib.asyncio.staggered",
        "peekOfCode": "__all__ = 'staggered_race',\nimport contextlib\nimport typing\nfrom . import events\nfrom . import exceptions as exceptions_mod\nfrom . import locks\nfrom . import tasks\nasync def staggered_race(\n        coro_fns: typing.Iterable[typing.Callable[[], typing.Awaitable]],\n        delay: typing.Optional[float],",
        "detail": "protobuf.Lib.asyncio.staggered",
        "documentation": {}
    },
    {
        "label": "FlowControlMixin",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.streams",
        "description": "protobuf.Lib.asyncio.streams",
        "peekOfCode": "class FlowControlMixin(protocols.Protocol):\n    \"\"\"Reusable flow control logic for StreamWriter.drain().\n    This implements the protocol methods pause_writing(),\n    resume_writing() and connection_lost().  If the subclass overrides\n    these it must call the super methods.\n    StreamWriter.drain() must wait for _drain_helper() coroutine.\n    \"\"\"\n    def __init__(self, loop=None):\n        if loop is None:\n            self._loop = events._get_event_loop(stacklevel=4)",
        "detail": "protobuf.Lib.asyncio.streams",
        "documentation": {}
    },
    {
        "label": "StreamReaderProtocol",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.streams",
        "description": "protobuf.Lib.asyncio.streams",
        "peekOfCode": "class StreamReaderProtocol(FlowControlMixin, protocols.Protocol):\n    \"\"\"Helper class to adapt between Protocol and StreamReader.\n    (This is a helper class instead of making StreamReader itself a\n    Protocol subclass, because the StreamReader has other potential\n    uses, and to prevent the user of the StreamReader to accidentally\n    call inappropriate methods of the protocol.)\n    \"\"\"\n    _source_traceback = None\n    def __init__(self, stream_reader, client_connected_cb=None, loop=None):\n        super().__init__(loop=loop)",
        "detail": "protobuf.Lib.asyncio.streams",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.streams",
        "description": "protobuf.Lib.asyncio.streams",
        "peekOfCode": "class StreamWriter:\n    \"\"\"Wraps a Transport.\n    This exposes write(), writelines(), [can_]write_eof(),\n    get_extra_info() and close().  It adds drain() which returns an\n    optional Future on which you can wait for flow control.  It also\n    adds a transport property which references the Transport\n    directly.\n    \"\"\"\n    def __init__(self, transport, protocol, reader, loop):\n        self._transport = transport",
        "detail": "protobuf.Lib.asyncio.streams",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.streams",
        "description": "protobuf.Lib.asyncio.streams",
        "peekOfCode": "class StreamReader:\n    _source_traceback = None\n    def __init__(self, limit=_DEFAULT_LIMIT, loop=None):\n        # The line length limit is  a security feature;\n        # it also doubles as half the buffer limit.\n        if limit <= 0:\n            raise ValueError('Limit cannot be <= 0')\n        self._limit = limit\n        if loop is None:\n            self._loop = events._get_event_loop()",
        "detail": "protobuf.Lib.asyncio.streams",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.streams",
        "description": "protobuf.Lib.asyncio.streams",
        "peekOfCode": "__all__ = (\n    'StreamReader', 'StreamWriter', 'StreamReaderProtocol',\n    'open_connection', 'start_server')\nimport collections\nimport socket\nimport sys\nimport warnings\nimport weakref\nif hasattr(socket, 'AF_UNIX'):\n    __all__ += ('open_unix_connection', 'start_unix_server')",
        "detail": "protobuf.Lib.asyncio.streams",
        "documentation": {}
    },
    {
        "label": "_DEFAULT_LIMIT",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.streams",
        "description": "protobuf.Lib.asyncio.streams",
        "peekOfCode": "_DEFAULT_LIMIT = 2 ** 16  # 64 KiB\nasync def open_connection(host=None, port=None, *,\n                          limit=_DEFAULT_LIMIT, **kwds):\n    \"\"\"A wrapper for create_connection() returning a (reader, writer) pair.\n    The reader returned is a StreamReader instance; the writer is a\n    StreamWriter instance.\n    The arguments are all the usual arguments to create_connection()\n    except protocol_factory; most common are positional host and port,\n    with various optional keyword arguments following.\n    Additional optional keyword arguments are loop (to set the event loop",
        "detail": "protobuf.Lib.asyncio.streams",
        "documentation": {}
    },
    {
        "label": "SubprocessStreamProtocol",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.subprocess",
        "description": "protobuf.Lib.asyncio.subprocess",
        "peekOfCode": "class SubprocessStreamProtocol(streams.FlowControlMixin,\n                               protocols.SubprocessProtocol):\n    \"\"\"Like StreamReaderProtocol, but for a subprocess.\"\"\"\n    def __init__(self, limit, loop):\n        super().__init__(loop=loop)\n        self._limit = limit\n        self.stdin = self.stdout = self.stderr = None\n        self._transport = None\n        self._process_exited = False\n        self._pipe_fds = []",
        "detail": "protobuf.Lib.asyncio.subprocess",
        "documentation": {}
    },
    {
        "label": "Process",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.subprocess",
        "description": "protobuf.Lib.asyncio.subprocess",
        "peekOfCode": "class Process:\n    def __init__(self, transport, protocol, loop):\n        self._transport = transport\n        self._protocol = protocol\n        self._loop = loop\n        self.stdin = protocol.stdin\n        self.stdout = protocol.stdout\n        self.stderr = protocol.stderr\n        self.pid = transport.get_pid()\n    def __repr__(self):",
        "detail": "protobuf.Lib.asyncio.subprocess",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.subprocess",
        "description": "protobuf.Lib.asyncio.subprocess",
        "peekOfCode": "__all__ = 'create_subprocess_exec', 'create_subprocess_shell'\nimport subprocess\nfrom . import events\nfrom . import protocols\nfrom . import streams\nfrom . import tasks\nfrom .log import logger\nPIPE = subprocess.PIPE\nSTDOUT = subprocess.STDOUT\nDEVNULL = subprocess.DEVNULL",
        "detail": "protobuf.Lib.asyncio.subprocess",
        "documentation": {}
    },
    {
        "label": "PIPE",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.subprocess",
        "description": "protobuf.Lib.asyncio.subprocess",
        "peekOfCode": "PIPE = subprocess.PIPE\nSTDOUT = subprocess.STDOUT\nDEVNULL = subprocess.DEVNULL\nclass SubprocessStreamProtocol(streams.FlowControlMixin,\n                               protocols.SubprocessProtocol):\n    \"\"\"Like StreamReaderProtocol, but for a subprocess.\"\"\"\n    def __init__(self, limit, loop):\n        super().__init__(loop=loop)\n        self._limit = limit\n        self.stdin = self.stdout = self.stderr = None",
        "detail": "protobuf.Lib.asyncio.subprocess",
        "documentation": {}
    },
    {
        "label": "STDOUT",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.subprocess",
        "description": "protobuf.Lib.asyncio.subprocess",
        "peekOfCode": "STDOUT = subprocess.STDOUT\nDEVNULL = subprocess.DEVNULL\nclass SubprocessStreamProtocol(streams.FlowControlMixin,\n                               protocols.SubprocessProtocol):\n    \"\"\"Like StreamReaderProtocol, but for a subprocess.\"\"\"\n    def __init__(self, limit, loop):\n        super().__init__(loop=loop)\n        self._limit = limit\n        self.stdin = self.stdout = self.stderr = None\n        self._transport = None",
        "detail": "protobuf.Lib.asyncio.subprocess",
        "documentation": {}
    },
    {
        "label": "DEVNULL",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.subprocess",
        "description": "protobuf.Lib.asyncio.subprocess",
        "peekOfCode": "DEVNULL = subprocess.DEVNULL\nclass SubprocessStreamProtocol(streams.FlowControlMixin,\n                               protocols.SubprocessProtocol):\n    \"\"\"Like StreamReaderProtocol, but for a subprocess.\"\"\"\n    def __init__(self, limit, loop):\n        super().__init__(loop=loop)\n        self._limit = limit\n        self.stdin = self.stdout = self.stderr = None\n        self._transport = None\n        self._process_exited = False",
        "detail": "protobuf.Lib.asyncio.subprocess",
        "documentation": {}
    },
    {
        "label": "Task",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.tasks",
        "description": "protobuf.Lib.asyncio.tasks",
        "peekOfCode": "class Task(futures._PyFuture):  # Inherit Python Task implementation\n                                # from a Python Future implementation.\n    \"\"\"A coroutine wrapped in a Future.\"\"\"\n    # An important invariant maintained while a Task not done:\n    #\n    # - Either _fut_waiter is None, and _step() is scheduled;\n    # - or _fut_waiter is some Future, and _step() is *not* scheduled.\n    #\n    # The only transition from the latter to the former is through\n    # _wakeup().  When _fut_waiter is not None, one of its callbacks",
        "detail": "protobuf.Lib.asyncio.tasks",
        "documentation": {}
    },
    {
        "label": "_GatheringFuture",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.tasks",
        "description": "protobuf.Lib.asyncio.tasks",
        "peekOfCode": "class _GatheringFuture(futures.Future):\n    \"\"\"Helper for gather().\n    This overrides cancel() to cancel all the children and act more\n    like Task.cancel(), which doesn't immediately mark itself as\n    cancelled.\n    \"\"\"\n    def __init__(self, children, *, loop):\n        assert loop is not None\n        super().__init__(loop=loop)\n        self._children = children",
        "detail": "protobuf.Lib.asyncio.tasks",
        "documentation": {}
    },
    {
        "label": "current_task",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncio.tasks",
        "description": "protobuf.Lib.asyncio.tasks",
        "peekOfCode": "def current_task(loop=None):\n    \"\"\"Return a currently executed task.\"\"\"\n    if loop is None:\n        loop = events.get_running_loop()\n    return _current_tasks.get(loop)\ndef all_tasks(loop=None):\n    \"\"\"Return a set of all tasks for the loop.\"\"\"\n    if loop is None:\n        loop = events.get_running_loop()\n    # Looping over a WeakSet (_all_tasks) isn't safe as it can be updated from another",
        "detail": "protobuf.Lib.asyncio.tasks",
        "documentation": {}
    },
    {
        "label": "all_tasks",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncio.tasks",
        "description": "protobuf.Lib.asyncio.tasks",
        "peekOfCode": "def all_tasks(loop=None):\n    \"\"\"Return a set of all tasks for the loop.\"\"\"\n    if loop is None:\n        loop = events.get_running_loop()\n    # Looping over a WeakSet (_all_tasks) isn't safe as it can be updated from another\n    # thread while we do so. Therefore we cast it to list prior to filtering. The list\n    # cast itself requires iteration, so we repeat it several times ignoring\n    # RuntimeErrors (which are not very likely to occur). See issues 34970 and 36607 for\n    # details.\n    i = 0",
        "detail": "protobuf.Lib.asyncio.tasks",
        "documentation": {}
    },
    {
        "label": "create_task",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncio.tasks",
        "description": "protobuf.Lib.asyncio.tasks",
        "peekOfCode": "def create_task(coro, *, name=None):\n    \"\"\"Schedule the execution of a coroutine object in a spawn task.\n    Return a Task object.\n    \"\"\"\n    loop = events.get_running_loop()\n    task = loop.create_task(coro)\n    _set_task_name(task, name)\n    return task\n# wait() and as_completed() similar to those in PEP 3148.\nFIRST_COMPLETED = concurrent.futures.FIRST_COMPLETED",
        "detail": "protobuf.Lib.asyncio.tasks",
        "documentation": {}
    },
    {
        "label": "as_completed",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncio.tasks",
        "description": "protobuf.Lib.asyncio.tasks",
        "peekOfCode": "def as_completed(fs, *, timeout=None):\n    \"\"\"Return an iterator whose values are coroutines.\n    When waiting for the yielded coroutines you'll get the results (or\n    exceptions!) of the original Futures (or coroutines), in the order\n    in which and as soon as they complete.\n    This differs from PEP 3148; the proper way to use this is:\n        for f in as_completed(fs):\n            result = await f  # The 'await' may raise.\n            # Use result.\n    If a timeout is specified, the 'await' will raise",
        "detail": "protobuf.Lib.asyncio.tasks",
        "documentation": {}
    },
    {
        "label": "ensure_future",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncio.tasks",
        "description": "protobuf.Lib.asyncio.tasks",
        "peekOfCode": "def ensure_future(coro_or_future, *, loop=None):\n    \"\"\"Wrap a coroutine or an awaitable in a future.\n    If the argument is a Future, it is returned directly.\n    \"\"\"\n    return _ensure_future(coro_or_future, loop=loop)\ndef _ensure_future(coro_or_future, *, loop=None):\n    if futures.isfuture(coro_or_future):\n        if loop is not None and loop is not futures._get_loop(coro_or_future):\n            raise ValueError('The future belongs to a different loop than '\n                            'the one specified as the loop argument')",
        "detail": "protobuf.Lib.asyncio.tasks",
        "documentation": {}
    },
    {
        "label": "gather",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncio.tasks",
        "description": "protobuf.Lib.asyncio.tasks",
        "peekOfCode": "def gather(*coros_or_futures, return_exceptions=False):\n    \"\"\"Return a future aggregating results from the given coroutines/futures.\n    Coroutines will be wrapped in a future and scheduled in the event\n    loop. They will not necessarily be scheduled in the same order as\n    passed in.\n    All futures must share the same event loop.  If all the tasks are\n    done successfully, the returned future's result is the list of\n    results (in the order of the original sequence, not necessarily\n    the order of results arrival).  If *return_exceptions* is True,\n    exceptions in the tasks are treated the same as successful",
        "detail": "protobuf.Lib.asyncio.tasks",
        "documentation": {}
    },
    {
        "label": "shield",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncio.tasks",
        "description": "protobuf.Lib.asyncio.tasks",
        "peekOfCode": "def shield(arg):\n    \"\"\"Wait for a future, shielding it from cancellation.\n    The statement\n        task = asyncio.create_task(something())\n        res = await shield(task)\n    is exactly equivalent to the statement\n        res = await something()\n    *except* that if the coroutine containing it is cancelled, the\n    task running in something() is not cancelled.  From the POV of\n    something(), the cancellation did not happen.  But its caller is",
        "detail": "protobuf.Lib.asyncio.tasks",
        "documentation": {}
    },
    {
        "label": "run_coroutine_threadsafe",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncio.tasks",
        "description": "protobuf.Lib.asyncio.tasks",
        "peekOfCode": "def run_coroutine_threadsafe(coro, loop):\n    \"\"\"Submit a coroutine object to a given event loop.\n    Return a concurrent.futures.Future to access the result.\n    \"\"\"\n    if not coroutines.iscoroutine(coro):\n        raise TypeError('A coroutine object is required')\n    future = concurrent.futures.Future()\n    def callback():\n        try:\n            futures._chain_future(ensure_future(coro, loop=loop), future)",
        "detail": "protobuf.Lib.asyncio.tasks",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.tasks",
        "description": "protobuf.Lib.asyncio.tasks",
        "peekOfCode": "__all__ = (\n    'Task', 'create_task',\n    'FIRST_COMPLETED', 'FIRST_EXCEPTION', 'ALL_COMPLETED',\n    'wait', 'wait_for', 'as_completed', 'sleep',\n    'gather', 'shield', 'ensure_future', 'run_coroutine_threadsafe',\n    'current_task', 'all_tasks',\n    '_register_task', '_unregister_task', '_enter_task', '_leave_task',\n)\nimport concurrent.futures\nimport contextvars",
        "detail": "protobuf.Lib.asyncio.tasks",
        "documentation": {}
    },
    {
        "label": "_task_name_counter",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.tasks",
        "description": "protobuf.Lib.asyncio.tasks",
        "peekOfCode": "_task_name_counter = itertools.count(1).__next__\ndef current_task(loop=None):\n    \"\"\"Return a currently executed task.\"\"\"\n    if loop is None:\n        loop = events.get_running_loop()\n    return _current_tasks.get(loop)\ndef all_tasks(loop=None):\n    \"\"\"Return a set of all tasks for the loop.\"\"\"\n    if loop is None:\n        loop = events.get_running_loop()",
        "detail": "protobuf.Lib.asyncio.tasks",
        "documentation": {}
    },
    {
        "label": "_PyTask",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.tasks",
        "description": "protobuf.Lib.asyncio.tasks",
        "peekOfCode": "_PyTask = Task\ntry:\n    import _asyncio\nexcept ImportError:\n    pass\nelse:\n    # _CTask is needed for tests.\n    Task = _CTask = _asyncio.Task\ndef create_task(coro, *, name=None):\n    \"\"\"Schedule the execution of a coroutine object in a spawn task.",
        "detail": "protobuf.Lib.asyncio.tasks",
        "documentation": {}
    },
    {
        "label": "FIRST_COMPLETED",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.tasks",
        "description": "protobuf.Lib.asyncio.tasks",
        "peekOfCode": "FIRST_COMPLETED = concurrent.futures.FIRST_COMPLETED\nFIRST_EXCEPTION = concurrent.futures.FIRST_EXCEPTION\nALL_COMPLETED = concurrent.futures.ALL_COMPLETED\nasync def wait(fs, *, timeout=None, return_when=ALL_COMPLETED):\n    \"\"\"Wait for the Futures and coroutines given by fs to complete.\n    The fs iterable must not be empty.\n    Coroutines will be wrapped in Tasks.\n    Returns two sets of Future: (done, pending).\n    Usage:\n        done, pending = await asyncio.wait(fs)",
        "detail": "protobuf.Lib.asyncio.tasks",
        "documentation": {}
    },
    {
        "label": "FIRST_EXCEPTION",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.tasks",
        "description": "protobuf.Lib.asyncio.tasks",
        "peekOfCode": "FIRST_EXCEPTION = concurrent.futures.FIRST_EXCEPTION\nALL_COMPLETED = concurrent.futures.ALL_COMPLETED\nasync def wait(fs, *, timeout=None, return_when=ALL_COMPLETED):\n    \"\"\"Wait for the Futures and coroutines given by fs to complete.\n    The fs iterable must not be empty.\n    Coroutines will be wrapped in Tasks.\n    Returns two sets of Future: (done, pending).\n    Usage:\n        done, pending = await asyncio.wait(fs)\n    Note: This does not raise TimeoutError! Futures that aren't done",
        "detail": "protobuf.Lib.asyncio.tasks",
        "documentation": {}
    },
    {
        "label": "ALL_COMPLETED",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.tasks",
        "description": "protobuf.Lib.asyncio.tasks",
        "peekOfCode": "ALL_COMPLETED = concurrent.futures.ALL_COMPLETED\nasync def wait(fs, *, timeout=None, return_when=ALL_COMPLETED):\n    \"\"\"Wait for the Futures and coroutines given by fs to complete.\n    The fs iterable must not be empty.\n    Coroutines will be wrapped in Tasks.\n    Returns two sets of Future: (done, pending).\n    Usage:\n        done, pending = await asyncio.wait(fs)\n    Note: This does not raise TimeoutError! Futures that aren't done\n    when the timeout occurs are returned in the second set.",
        "detail": "protobuf.Lib.asyncio.tasks",
        "documentation": {}
    },
    {
        "label": "_wrap_awaitable._is_coroutine",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.tasks",
        "description": "protobuf.Lib.asyncio.tasks",
        "peekOfCode": "_wrap_awaitable._is_coroutine = _is_coroutine\nclass _GatheringFuture(futures.Future):\n    \"\"\"Helper for gather().\n    This overrides cancel() to cancel all the children and act more\n    like Task.cancel(), which doesn't immediately mark itself as\n    cancelled.\n    \"\"\"\n    def __init__(self, children, *, loop):\n        assert loop is not None\n        super().__init__(loop=loop)",
        "detail": "protobuf.Lib.asyncio.tasks",
        "documentation": {}
    },
    {
        "label": "_all_tasks",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.tasks",
        "description": "protobuf.Lib.asyncio.tasks",
        "peekOfCode": "_all_tasks = weakref.WeakSet()\n# Dictionary containing tasks that are currently active in\n# all running event loops.  {EventLoop: Task}\n_current_tasks = {}\ndef _register_task(task):\n    \"\"\"Register a new task in asyncio as executed by loop.\"\"\"\n    _all_tasks.add(task)\ndef _enter_task(loop, task):\n    current_task = _current_tasks.get(loop)\n    if current_task is not None:",
        "detail": "protobuf.Lib.asyncio.tasks",
        "documentation": {}
    },
    {
        "label": "_current_tasks",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.tasks",
        "description": "protobuf.Lib.asyncio.tasks",
        "peekOfCode": "_current_tasks = {}\ndef _register_task(task):\n    \"\"\"Register a new task in asyncio as executed by loop.\"\"\"\n    _all_tasks.add(task)\ndef _enter_task(loop, task):\n    current_task = _current_tasks.get(loop)\n    if current_task is not None:\n        raise RuntimeError(f\"Cannot enter into task {task!r} while another \"\n                           f\"task {current_task!r} is being executed.\")\n    _current_tasks[loop] = task",
        "detail": "protobuf.Lib.asyncio.tasks",
        "documentation": {}
    },
    {
        "label": "_py_register_task",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.tasks",
        "description": "protobuf.Lib.asyncio.tasks",
        "peekOfCode": "_py_register_task = _register_task\n_py_unregister_task = _unregister_task\n_py_enter_task = _enter_task\n_py_leave_task = _leave_task\ntry:\n    from _asyncio import (_register_task, _unregister_task,\n                          _enter_task, _leave_task,\n                          _all_tasks, _current_tasks)\nexcept ImportError:\n    pass",
        "detail": "protobuf.Lib.asyncio.tasks",
        "documentation": {}
    },
    {
        "label": "_py_unregister_task",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.tasks",
        "description": "protobuf.Lib.asyncio.tasks",
        "peekOfCode": "_py_unregister_task = _unregister_task\n_py_enter_task = _enter_task\n_py_leave_task = _leave_task\ntry:\n    from _asyncio import (_register_task, _unregister_task,\n                          _enter_task, _leave_task,\n                          _all_tasks, _current_tasks)\nexcept ImportError:\n    pass\nelse:",
        "detail": "protobuf.Lib.asyncio.tasks",
        "documentation": {}
    },
    {
        "label": "_py_enter_task",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.tasks",
        "description": "protobuf.Lib.asyncio.tasks",
        "peekOfCode": "_py_enter_task = _enter_task\n_py_leave_task = _leave_task\ntry:\n    from _asyncio import (_register_task, _unregister_task,\n                          _enter_task, _leave_task,\n                          _all_tasks, _current_tasks)\nexcept ImportError:\n    pass\nelse:\n    _c_register_task = _register_task",
        "detail": "protobuf.Lib.asyncio.tasks",
        "documentation": {}
    },
    {
        "label": "_py_leave_task",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.tasks",
        "description": "protobuf.Lib.asyncio.tasks",
        "peekOfCode": "_py_leave_task = _leave_task\ntry:\n    from _asyncio import (_register_task, _unregister_task,\n                          _enter_task, _leave_task,\n                          _all_tasks, _current_tasks)\nexcept ImportError:\n    pass\nelse:\n    _c_register_task = _register_task\n    _c_unregister_task = _unregister_task",
        "detail": "protobuf.Lib.asyncio.tasks",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.threads",
        "description": "protobuf.Lib.asyncio.threads",
        "peekOfCode": "__all__ = \"to_thread\",\nasync def to_thread(func, /, *args, **kwargs):\n    \"\"\"Asynchronously run function *func* in a separate thread.\n    Any *args and **kwargs supplied for this function are directly passed\n    to *func*. Also, the current :class:`contextvars.Context` is propagated,\n    allowing context variables from the main thread to be accessed in the\n    separate thread.\n    Return a coroutine that can be awaited to get the eventual result of *func*.\n    \"\"\"\n    loop = events.get_running_loop()",
        "detail": "protobuf.Lib.asyncio.threads",
        "documentation": {}
    },
    {
        "label": "BaseTransport",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.transports",
        "description": "protobuf.Lib.asyncio.transports",
        "peekOfCode": "class BaseTransport:\n    \"\"\"Base class for transports.\"\"\"\n    __slots__ = ('_extra',)\n    def __init__(self, extra=None):\n        if extra is None:\n            extra = {}\n        self._extra = extra\n    def get_extra_info(self, name, default=None):\n        \"\"\"Get optional transport information.\"\"\"\n        return self._extra.get(name, default)",
        "detail": "protobuf.Lib.asyncio.transports",
        "documentation": {}
    },
    {
        "label": "ReadTransport",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.transports",
        "description": "protobuf.Lib.asyncio.transports",
        "peekOfCode": "class ReadTransport(BaseTransport):\n    \"\"\"Interface for read-only transports.\"\"\"\n    __slots__ = ()\n    def is_reading(self):\n        \"\"\"Return True if the transport is receiving.\"\"\"\n        raise NotImplementedError\n    def pause_reading(self):\n        \"\"\"Pause the receiving end.\n        No data will be passed to the protocol's data_received()\n        method until resume_reading() is called.",
        "detail": "protobuf.Lib.asyncio.transports",
        "documentation": {}
    },
    {
        "label": "WriteTransport",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.transports",
        "description": "protobuf.Lib.asyncio.transports",
        "peekOfCode": "class WriteTransport(BaseTransport):\n    \"\"\"Interface for write-only transports.\"\"\"\n    __slots__ = ()\n    def set_write_buffer_limits(self, high=None, low=None):\n        \"\"\"Set the high- and low-water limits for write flow control.\n        These two values control when to call the protocol's\n        pause_writing() and resume_writing() methods.  If specified,\n        the low-water limit must be less than or equal to the\n        high-water limit.  Neither value can be negative.\n        The defaults are implementation-specific.  If only the",
        "detail": "protobuf.Lib.asyncio.transports",
        "documentation": {}
    },
    {
        "label": "Transport",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.transports",
        "description": "protobuf.Lib.asyncio.transports",
        "peekOfCode": "class Transport(ReadTransport, WriteTransport):\n    \"\"\"Interface representing a bidirectional transport.\n    There may be several implementations, but typically, the user does\n    not implement new transports; rather, the platform provides some\n    useful transports that are implemented using the platform's best\n    practices.\n    The user never instantiates a transport directly; they call a\n    utility function, passing it a protocol factory and other\n    information necessary to create the transport and protocol.  (E.g.\n    EventLoop.create_connection() or EventLoop.create_server().)",
        "detail": "protobuf.Lib.asyncio.transports",
        "documentation": {}
    },
    {
        "label": "DatagramTransport",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.transports",
        "description": "protobuf.Lib.asyncio.transports",
        "peekOfCode": "class DatagramTransport(BaseTransport):\n    \"\"\"Interface for datagram (UDP) transports.\"\"\"\n    __slots__ = ()\n    def sendto(self, data, addr=None):\n        \"\"\"Send data to the transport.\n        This does not block; it buffers the data and arranges for it\n        to be sent out asynchronously.\n        addr is target socket address.\n        If addr is None use target address pointed on transport creation.\n        \"\"\"",
        "detail": "protobuf.Lib.asyncio.transports",
        "documentation": {}
    },
    {
        "label": "SubprocessTransport",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.transports",
        "description": "protobuf.Lib.asyncio.transports",
        "peekOfCode": "class SubprocessTransport(BaseTransport):\n    __slots__ = ()\n    def get_pid(self):\n        \"\"\"Get subprocess id.\"\"\"\n        raise NotImplementedError\n    def get_returncode(self):\n        \"\"\"Get subprocess returncode.\n        See also\n        http://docs.python.org/3/library/subprocess#subprocess.Popen.returncode\n        \"\"\"",
        "detail": "protobuf.Lib.asyncio.transports",
        "documentation": {}
    },
    {
        "label": "_FlowControlMixin",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.transports",
        "description": "protobuf.Lib.asyncio.transports",
        "peekOfCode": "class _FlowControlMixin(Transport):\n    \"\"\"All the logic for (write) flow control in a mix-in base class.\n    The subclass must implement get_write_buffer_size().  It must call\n    _maybe_pause_protocol() whenever the write buffer size increases,\n    and _maybe_resume_protocol() whenever it decreases.  It may also\n    override set_write_buffer_limits() (e.g. to specify different\n    defaults).\n    The subclass constructor must call super().__init__(extra).  This\n    will call set_write_buffer_limits().\n    The user may call set_write_buffer_limits() and",
        "detail": "protobuf.Lib.asyncio.transports",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.transports",
        "description": "protobuf.Lib.asyncio.transports",
        "peekOfCode": "__all__ = (\n    'BaseTransport', 'ReadTransport', 'WriteTransport',\n    'Transport', 'DatagramTransport', 'SubprocessTransport',\n)\nclass BaseTransport:\n    \"\"\"Base class for transports.\"\"\"\n    __slots__ = ('_extra',)\n    def __init__(self, extra=None):\n        if extra is None:\n            extra = {}",
        "detail": "protobuf.Lib.asyncio.transports",
        "documentation": {}
    },
    {
        "label": "TransportSocket",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.trsock",
        "description": "protobuf.Lib.asyncio.trsock",
        "peekOfCode": "class TransportSocket:\n    \"\"\"A socket-like wrapper for exposing real transport sockets.\n    These objects can be safely returned by APIs like\n    `transport.get_extra_info('socket')`.  All potentially disruptive\n    operations (like \"socket.close()\") are banned.\n    \"\"\"\n    __slots__ = ('_sock',)\n    def __init__(self, sock: socket.socket):\n        self._sock = sock\n    def _na(self, what):",
        "detail": "protobuf.Lib.asyncio.trsock",
        "documentation": {}
    },
    {
        "label": "_UnixSelectorEventLoop",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.unix_events",
        "description": "protobuf.Lib.asyncio.unix_events",
        "peekOfCode": "class _UnixSelectorEventLoop(selector_events.BaseSelectorEventLoop):\n    \"\"\"Unix event loop.\n    Adds signal handling and UNIX Domain Socket support to SelectorEventLoop.\n    \"\"\"\n    def __init__(self, selector=None):\n        super().__init__(selector)\n        self._signal_handlers = {}\n    def close(self):\n        super().close()\n        if not sys.is_finalizing():",
        "detail": "protobuf.Lib.asyncio.unix_events",
        "documentation": {}
    },
    {
        "label": "_UnixReadPipeTransport",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.unix_events",
        "description": "protobuf.Lib.asyncio.unix_events",
        "peekOfCode": "class _UnixReadPipeTransport(transports.ReadTransport):\n    max_size = 256 * 1024  # max bytes we read in one event loop iteration\n    def __init__(self, loop, pipe, protocol, waiter=None, extra=None):\n        super().__init__(extra)\n        self._extra['pipe'] = pipe\n        self._loop = loop\n        self._pipe = pipe\n        self._fileno = pipe.fileno()\n        self._protocol = protocol\n        self._closing = False",
        "detail": "protobuf.Lib.asyncio.unix_events",
        "documentation": {}
    },
    {
        "label": "_UnixWritePipeTransport",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.unix_events",
        "description": "protobuf.Lib.asyncio.unix_events",
        "peekOfCode": "class _UnixWritePipeTransport(transports._FlowControlMixin,\n                              transports.WriteTransport):\n    def __init__(self, loop, pipe, protocol, waiter=None, extra=None):\n        super().__init__(extra, loop)\n        self._extra['pipe'] = pipe\n        self._pipe = pipe\n        self._fileno = pipe.fileno()\n        self._protocol = protocol\n        self._buffer = bytearray()\n        self._conn_lost = 0",
        "detail": "protobuf.Lib.asyncio.unix_events",
        "documentation": {}
    },
    {
        "label": "_UnixSubprocessTransport",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.unix_events",
        "description": "protobuf.Lib.asyncio.unix_events",
        "peekOfCode": "class _UnixSubprocessTransport(base_subprocess.BaseSubprocessTransport):\n    def _start(self, args, shell, stdin, stdout, stderr, bufsize, **kwargs):\n        stdin_w = None\n        if stdin == subprocess.PIPE and sys.platform.startswith('aix'):\n            # Use a socket pair for stdin on AIX, since it does not\n            # support selecting read events on the write end of a\n            # socket (which we use in order to detect closing of the\n            # other end).\n            stdin, stdin_w = socket.socketpair()\n        try:",
        "detail": "protobuf.Lib.asyncio.unix_events",
        "documentation": {}
    },
    {
        "label": "AbstractChildWatcher",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.unix_events",
        "description": "protobuf.Lib.asyncio.unix_events",
        "peekOfCode": "class AbstractChildWatcher:\n    \"\"\"Abstract base class for monitoring child processes.\n    Objects derived from this class monitor a collection of subprocesses and\n    report their termination or interruption by a signal.\n    New callbacks are registered with .add_child_handler(). Starting a new\n    process must be done within a 'with' block to allow the watcher to suspend\n    its activity until the new process if fully registered (this is needed to\n    prevent a race condition in some implementations).\n    Example:\n        with watcher:",
        "detail": "protobuf.Lib.asyncio.unix_events",
        "documentation": {}
    },
    {
        "label": "PidfdChildWatcher",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.unix_events",
        "description": "protobuf.Lib.asyncio.unix_events",
        "peekOfCode": "class PidfdChildWatcher(AbstractChildWatcher):\n    \"\"\"Child watcher implementation using Linux's pid file descriptors.\n    This child watcher polls process file descriptors (pidfds) to await child\n    process termination. In some respects, PidfdChildWatcher is a \"Goldilocks\"\n    child watcher implementation. It doesn't require signals or threads, doesn't\n    interfere with any processes launched outside the event loop, and scales\n    linearly with the number of subprocesses launched by the event loop. The\n    main disadvantage is that pidfds are specific to Linux, and only work on\n    recent (5.3+) kernels.\n    \"\"\"",
        "detail": "protobuf.Lib.asyncio.unix_events",
        "documentation": {}
    },
    {
        "label": "BaseChildWatcher",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.unix_events",
        "description": "protobuf.Lib.asyncio.unix_events",
        "peekOfCode": "class BaseChildWatcher(AbstractChildWatcher):\n    def __init__(self):\n        self._loop = None\n        self._callbacks = {}\n    def close(self):\n        self.attach_loop(None)\n    def is_active(self):\n        return self._loop is not None and self._loop.is_running()\n    def _do_waitpid(self, expected_pid):\n        raise NotImplementedError()",
        "detail": "protobuf.Lib.asyncio.unix_events",
        "documentation": {}
    },
    {
        "label": "SafeChildWatcher",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.unix_events",
        "description": "protobuf.Lib.asyncio.unix_events",
        "peekOfCode": "class SafeChildWatcher(BaseChildWatcher):\n    \"\"\"'Safe' child watcher implementation.\n    This implementation avoids disrupting other code spawning processes by\n    polling explicitly each process in the SIGCHLD handler instead of calling\n    os.waitpid(-1).\n    This is a safe solution but it has a significant overhead when handling a\n    big number of children (O(n) each time SIGCHLD is raised)\n    \"\"\"\n    def close(self):\n        self._callbacks.clear()",
        "detail": "protobuf.Lib.asyncio.unix_events",
        "documentation": {}
    },
    {
        "label": "FastChildWatcher",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.unix_events",
        "description": "protobuf.Lib.asyncio.unix_events",
        "peekOfCode": "class FastChildWatcher(BaseChildWatcher):\n    \"\"\"'Fast' child watcher implementation.\n    This implementation reaps every terminated processes by calling\n    os.waitpid(-1) directly, possibly breaking other code spawning processes\n    and waiting for their termination.\n    There is no noticeable overhead when handling a big number of children\n    (O(1) each time a child terminates).\n    \"\"\"\n    def __init__(self):\n        super().__init__()",
        "detail": "protobuf.Lib.asyncio.unix_events",
        "documentation": {}
    },
    {
        "label": "MultiLoopChildWatcher",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.unix_events",
        "description": "protobuf.Lib.asyncio.unix_events",
        "peekOfCode": "class MultiLoopChildWatcher(AbstractChildWatcher):\n    \"\"\"A watcher that doesn't require running loop in the main thread.\n    This implementation registers a SIGCHLD signal handler on\n    instantiation (which may conflict with other code that\n    install own handler for this signal).\n    The solution is safe but it has a significant overhead when\n    handling a big number of processes (*O(n)* each time a\n    SIGCHLD is received).\n    \"\"\"\n    # Implementation note:",
        "detail": "protobuf.Lib.asyncio.unix_events",
        "documentation": {}
    },
    {
        "label": "ThreadedChildWatcher",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.unix_events",
        "description": "protobuf.Lib.asyncio.unix_events",
        "peekOfCode": "class ThreadedChildWatcher(AbstractChildWatcher):\n    \"\"\"Threaded child watcher implementation.\n    The watcher uses a thread per process\n    for waiting for the process finish.\n    It doesn't require subscription on POSIX signal\n    but a thread creation is not free.\n    The watcher has O(1) complexity, its performance doesn't depend\n    on amount of spawn processes.\n    \"\"\"\n    def __init__(self):",
        "detail": "protobuf.Lib.asyncio.unix_events",
        "documentation": {}
    },
    {
        "label": "_UnixDefaultEventLoopPolicy",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.unix_events",
        "description": "protobuf.Lib.asyncio.unix_events",
        "peekOfCode": "class _UnixDefaultEventLoopPolicy(events.BaseDefaultEventLoopPolicy):\n    \"\"\"UNIX event loop policy with a watcher for child processes.\"\"\"\n    _loop_factory = _UnixSelectorEventLoop\n    def __init__(self):\n        super().__init__()\n        self._watcher = None\n    def _init_watcher(self):\n        with events._lock:\n            if self._watcher is None:  # pragma: no branch\n                self._watcher = ThreadedChildWatcher()",
        "detail": "protobuf.Lib.asyncio.unix_events",
        "documentation": {}
    },
    {
        "label": "waitstatus_to_exitcode",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncio.unix_events",
        "description": "protobuf.Lib.asyncio.unix_events",
        "peekOfCode": "def waitstatus_to_exitcode(status):\n    try:\n        return os.waitstatus_to_exitcode(status)\n    except ValueError:\n        # The child exited, but we don't understand its status.\n        # This shouldn't happen, but if it does, let's just\n        # return that status; perhaps that helps debug it.\n        return status\nclass _UnixSelectorEventLoop(selector_events.BaseSelectorEventLoop):\n    \"\"\"Unix event loop.",
        "detail": "protobuf.Lib.asyncio.unix_events",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.unix_events",
        "description": "protobuf.Lib.asyncio.unix_events",
        "peekOfCode": "__all__ = (\n    'SelectorEventLoop',\n    'AbstractChildWatcher', 'SafeChildWatcher',\n    'FastChildWatcher', 'PidfdChildWatcher',\n    'MultiLoopChildWatcher', 'ThreadedChildWatcher',\n    'DefaultEventLoopPolicy',\n)\nif sys.platform == 'win32':  # pragma: no cover\n    raise ImportError('Signals are not really supported on Windows')\ndef _sighandler_noop(signum, frame):",
        "detail": "protobuf.Lib.asyncio.unix_events",
        "documentation": {}
    },
    {
        "label": "SelectorEventLoop",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.unix_events",
        "description": "protobuf.Lib.asyncio.unix_events",
        "peekOfCode": "SelectorEventLoop = _UnixSelectorEventLoop\nDefaultEventLoopPolicy = _UnixDefaultEventLoopPolicy",
        "detail": "protobuf.Lib.asyncio.unix_events",
        "documentation": {}
    },
    {
        "label": "DefaultEventLoopPolicy",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.unix_events",
        "description": "protobuf.Lib.asyncio.unix_events",
        "peekOfCode": "DefaultEventLoopPolicy = _UnixDefaultEventLoopPolicy",
        "detail": "protobuf.Lib.asyncio.unix_events",
        "documentation": {}
    },
    {
        "label": "_OverlappedFuture",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.windows_events",
        "description": "protobuf.Lib.asyncio.windows_events",
        "peekOfCode": "class _OverlappedFuture(futures.Future):\n    \"\"\"Subclass of Future which represents an overlapped operation.\n    Cancelling it will immediately cancel the overlapped operation.\n    \"\"\"\n    def __init__(self, ov, *, loop=None):\n        super().__init__(loop=loop)\n        if self._source_traceback:\n            del self._source_traceback[-1]\n        self._ov = ov\n    def _repr_info(self):",
        "detail": "protobuf.Lib.asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "_BaseWaitHandleFuture",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.windows_events",
        "description": "protobuf.Lib.asyncio.windows_events",
        "peekOfCode": "class _BaseWaitHandleFuture(futures.Future):\n    \"\"\"Subclass of Future which represents a wait handle.\"\"\"\n    def __init__(self, ov, handle, wait_handle, *, loop=None):\n        super().__init__(loop=loop)\n        if self._source_traceback:\n            del self._source_traceback[-1]\n        # Keep a reference to the Overlapped object to keep it alive until the\n        # wait is unregistered\n        self._ov = ov\n        self._handle = handle",
        "detail": "protobuf.Lib.asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "_WaitCancelFuture",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.windows_events",
        "description": "protobuf.Lib.asyncio.windows_events",
        "peekOfCode": "class _WaitCancelFuture(_BaseWaitHandleFuture):\n    \"\"\"Subclass of Future which represents a wait for the cancellation of a\n    _WaitHandleFuture using an event.\n    \"\"\"\n    def __init__(self, ov, event, wait_handle, *, loop=None):\n        super().__init__(ov, event, wait_handle, loop=loop)\n        self._done_callback = None\n    def cancel(self):\n        raise RuntimeError(\"_WaitCancelFuture must not be cancelled\")\n    def set_result(self, result):",
        "detail": "protobuf.Lib.asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "_WaitHandleFuture",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.windows_events",
        "description": "protobuf.Lib.asyncio.windows_events",
        "peekOfCode": "class _WaitHandleFuture(_BaseWaitHandleFuture):\n    def __init__(self, ov, handle, wait_handle, proactor, *, loop=None):\n        super().__init__(ov, handle, wait_handle, loop=loop)\n        self._proactor = proactor\n        self._unregister_proactor = True\n        self._event = _overlapped.CreateEvent(None, True, False, None)\n        self._event_fut = None\n    def _unregister_wait_cb(self, fut):\n        if self._event is not None:\n            _winapi.CloseHandle(self._event)",
        "detail": "protobuf.Lib.asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "PipeServer",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.windows_events",
        "description": "protobuf.Lib.asyncio.windows_events",
        "peekOfCode": "class PipeServer(object):\n    \"\"\"Class representing a pipe server.\n    This is much like a bound, listening socket.\n    \"\"\"\n    def __init__(self, address):\n        self._address = address\n        self._free_instances = weakref.WeakSet()\n        # initialize the pipe attribute before calling _server_pipe_handle()\n        # because this function can raise an exception and the destructor calls\n        # the close() method",
        "detail": "protobuf.Lib.asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "_WindowsSelectorEventLoop",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.windows_events",
        "description": "protobuf.Lib.asyncio.windows_events",
        "peekOfCode": "class _WindowsSelectorEventLoop(selector_events.BaseSelectorEventLoop):\n    \"\"\"Windows version of selector event loop.\"\"\"\nclass ProactorEventLoop(proactor_events.BaseProactorEventLoop):\n    \"\"\"Windows version of proactor event loop using IOCP.\"\"\"\n    def __init__(self, proactor=None):\n        if proactor is None:\n            proactor = IocpProactor()\n        super().__init__(proactor)\n    def run_forever(self):\n        try:",
        "detail": "protobuf.Lib.asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "ProactorEventLoop",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.windows_events",
        "description": "protobuf.Lib.asyncio.windows_events",
        "peekOfCode": "class ProactorEventLoop(proactor_events.BaseProactorEventLoop):\n    \"\"\"Windows version of proactor event loop using IOCP.\"\"\"\n    def __init__(self, proactor=None):\n        if proactor is None:\n            proactor = IocpProactor()\n        super().__init__(proactor)\n    def run_forever(self):\n        try:\n            assert self._self_reading_future is None\n            self.call_soon(self._loop_self_reading)",
        "detail": "protobuf.Lib.asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "IocpProactor",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.windows_events",
        "description": "protobuf.Lib.asyncio.windows_events",
        "peekOfCode": "class IocpProactor:\n    \"\"\"Proactor implementation using IOCP.\"\"\"\n    def __init__(self, concurrency=0xffffffff):\n        self._loop = None\n        self._results = []\n        self._iocp = _overlapped.CreateIoCompletionPort(\n            _overlapped.INVALID_HANDLE_VALUE, NULL, 0, concurrency)\n        self._cache = {}\n        self._registered = weakref.WeakSet()\n        self._unregistered = []",
        "detail": "protobuf.Lib.asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "_WindowsSubprocessTransport",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.windows_events",
        "description": "protobuf.Lib.asyncio.windows_events",
        "peekOfCode": "class _WindowsSubprocessTransport(base_subprocess.BaseSubprocessTransport):\n    def _start(self, args, shell, stdin, stdout, stderr, bufsize, **kwargs):\n        self._proc = windows_utils.Popen(\n            args, shell=shell, stdin=stdin, stdout=stdout, stderr=stderr,\n            bufsize=bufsize, **kwargs)\n        def callback(f):\n            returncode = self._proc.poll()\n            self._process_exited(returncode)\n        f = self._loop._proactor.wait_for_handle(int(self._proc._handle))\n        f.add_done_callback(callback)",
        "detail": "protobuf.Lib.asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "WindowsSelectorEventLoopPolicy",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.windows_events",
        "description": "protobuf.Lib.asyncio.windows_events",
        "peekOfCode": "class WindowsSelectorEventLoopPolicy(events.BaseDefaultEventLoopPolicy):\n    _loop_factory = SelectorEventLoop\nclass WindowsProactorEventLoopPolicy(events.BaseDefaultEventLoopPolicy):\n    _loop_factory = ProactorEventLoop\nDefaultEventLoopPolicy = WindowsProactorEventLoopPolicy",
        "detail": "protobuf.Lib.asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "WindowsProactorEventLoopPolicy",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.windows_events",
        "description": "protobuf.Lib.asyncio.windows_events",
        "peekOfCode": "class WindowsProactorEventLoopPolicy(events.BaseDefaultEventLoopPolicy):\n    _loop_factory = ProactorEventLoop\nDefaultEventLoopPolicy = WindowsProactorEventLoopPolicy",
        "detail": "protobuf.Lib.asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.windows_events",
        "description": "protobuf.Lib.asyncio.windows_events",
        "peekOfCode": "__all__ = (\n    'SelectorEventLoop', 'ProactorEventLoop', 'IocpProactor',\n    'DefaultEventLoopPolicy', 'WindowsSelectorEventLoopPolicy',\n    'WindowsProactorEventLoopPolicy',\n)\nNULL = 0\nINFINITE = 0xffffffff\nERROR_CONNECTION_REFUSED = 1225\nERROR_CONNECTION_ABORTED = 1236\n# Initial delay in seconds for connect_pipe() before retrying to connect",
        "detail": "protobuf.Lib.asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "NULL",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.windows_events",
        "description": "protobuf.Lib.asyncio.windows_events",
        "peekOfCode": "NULL = 0\nINFINITE = 0xffffffff\nERROR_CONNECTION_REFUSED = 1225\nERROR_CONNECTION_ABORTED = 1236\n# Initial delay in seconds for connect_pipe() before retrying to connect\nCONNECT_PIPE_INIT_DELAY = 0.001\n# Maximum delay in seconds for connect_pipe() before retrying to connect\nCONNECT_PIPE_MAX_DELAY = 0.100\nclass _OverlappedFuture(futures.Future):\n    \"\"\"Subclass of Future which represents an overlapped operation.",
        "detail": "protobuf.Lib.asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "INFINITE",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.windows_events",
        "description": "protobuf.Lib.asyncio.windows_events",
        "peekOfCode": "INFINITE = 0xffffffff\nERROR_CONNECTION_REFUSED = 1225\nERROR_CONNECTION_ABORTED = 1236\n# Initial delay in seconds for connect_pipe() before retrying to connect\nCONNECT_PIPE_INIT_DELAY = 0.001\n# Maximum delay in seconds for connect_pipe() before retrying to connect\nCONNECT_PIPE_MAX_DELAY = 0.100\nclass _OverlappedFuture(futures.Future):\n    \"\"\"Subclass of Future which represents an overlapped operation.\n    Cancelling it will immediately cancel the overlapped operation.",
        "detail": "protobuf.Lib.asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "ERROR_CONNECTION_REFUSED",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.windows_events",
        "description": "protobuf.Lib.asyncio.windows_events",
        "peekOfCode": "ERROR_CONNECTION_REFUSED = 1225\nERROR_CONNECTION_ABORTED = 1236\n# Initial delay in seconds for connect_pipe() before retrying to connect\nCONNECT_PIPE_INIT_DELAY = 0.001\n# Maximum delay in seconds for connect_pipe() before retrying to connect\nCONNECT_PIPE_MAX_DELAY = 0.100\nclass _OverlappedFuture(futures.Future):\n    \"\"\"Subclass of Future which represents an overlapped operation.\n    Cancelling it will immediately cancel the overlapped operation.\n    \"\"\"",
        "detail": "protobuf.Lib.asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "ERROR_CONNECTION_ABORTED",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.windows_events",
        "description": "protobuf.Lib.asyncio.windows_events",
        "peekOfCode": "ERROR_CONNECTION_ABORTED = 1236\n# Initial delay in seconds for connect_pipe() before retrying to connect\nCONNECT_PIPE_INIT_DELAY = 0.001\n# Maximum delay in seconds for connect_pipe() before retrying to connect\nCONNECT_PIPE_MAX_DELAY = 0.100\nclass _OverlappedFuture(futures.Future):\n    \"\"\"Subclass of Future which represents an overlapped operation.\n    Cancelling it will immediately cancel the overlapped operation.\n    \"\"\"\n    def __init__(self, ov, *, loop=None):",
        "detail": "protobuf.Lib.asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "CONNECT_PIPE_INIT_DELAY",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.windows_events",
        "description": "protobuf.Lib.asyncio.windows_events",
        "peekOfCode": "CONNECT_PIPE_INIT_DELAY = 0.001\n# Maximum delay in seconds for connect_pipe() before retrying to connect\nCONNECT_PIPE_MAX_DELAY = 0.100\nclass _OverlappedFuture(futures.Future):\n    \"\"\"Subclass of Future which represents an overlapped operation.\n    Cancelling it will immediately cancel the overlapped operation.\n    \"\"\"\n    def __init__(self, ov, *, loop=None):\n        super().__init__(loop=loop)\n        if self._source_traceback:",
        "detail": "protobuf.Lib.asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "CONNECT_PIPE_MAX_DELAY",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.windows_events",
        "description": "protobuf.Lib.asyncio.windows_events",
        "peekOfCode": "CONNECT_PIPE_MAX_DELAY = 0.100\nclass _OverlappedFuture(futures.Future):\n    \"\"\"Subclass of Future which represents an overlapped operation.\n    Cancelling it will immediately cancel the overlapped operation.\n    \"\"\"\n    def __init__(self, ov, *, loop=None):\n        super().__init__(loop=loop)\n        if self._source_traceback:\n            del self._source_traceback[-1]\n        self._ov = ov",
        "detail": "protobuf.Lib.asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "SelectorEventLoop",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.windows_events",
        "description": "protobuf.Lib.asyncio.windows_events",
        "peekOfCode": "SelectorEventLoop = _WindowsSelectorEventLoop\nclass WindowsSelectorEventLoopPolicy(events.BaseDefaultEventLoopPolicy):\n    _loop_factory = SelectorEventLoop\nclass WindowsProactorEventLoopPolicy(events.BaseDefaultEventLoopPolicy):\n    _loop_factory = ProactorEventLoop\nDefaultEventLoopPolicy = WindowsProactorEventLoopPolicy",
        "detail": "protobuf.Lib.asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "DefaultEventLoopPolicy",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.windows_events",
        "description": "protobuf.Lib.asyncio.windows_events",
        "peekOfCode": "DefaultEventLoopPolicy = WindowsProactorEventLoopPolicy",
        "detail": "protobuf.Lib.asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "PipeHandle",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.windows_utils",
        "description": "protobuf.Lib.asyncio.windows_utils",
        "peekOfCode": "class PipeHandle:\n    \"\"\"Wrapper for an overlapped pipe handle which is vaguely file-object like.\n    The IOCP event loop can use these instead of socket objects.\n    \"\"\"\n    def __init__(self, handle):\n        self._handle = handle\n    def __repr__(self):\n        if self._handle is not None:\n            handle = f'handle={self._handle!r}'\n        else:",
        "detail": "protobuf.Lib.asyncio.windows_utils",
        "documentation": {}
    },
    {
        "label": "Popen",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncio.windows_utils",
        "description": "protobuf.Lib.asyncio.windows_utils",
        "peekOfCode": "class Popen(subprocess.Popen):\n    \"\"\"Replacement for subprocess.Popen using overlapped pipe handles.\n    The stdin, stdout, stderr are None or instances of PipeHandle.\n    \"\"\"\n    def __init__(self, args, stdin=None, stdout=None, stderr=None, **kwds):\n        assert not kwds.get('universal_newlines')\n        assert kwds.get('bufsize', 0) == 0\n        stdin_rfd = stdout_wfd = stderr_wfd = None\n        stdin_wh = stdout_rh = stderr_rh = None\n        if stdin == PIPE:",
        "detail": "protobuf.Lib.asyncio.windows_utils",
        "documentation": {}
    },
    {
        "label": "pipe",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncio.windows_utils",
        "description": "protobuf.Lib.asyncio.windows_utils",
        "peekOfCode": "def pipe(*, duplex=False, overlapped=(True, True), bufsize=BUFSIZE):\n    \"\"\"Like os.pipe() but with overlapped support and using handles not fds.\"\"\"\n    address = tempfile.mktemp(\n        prefix=r'\\\\.\\pipe\\python-pipe-{:d}-{:d}-'.format(\n            os.getpid(), next(_mmap_counter)))\n    if duplex:\n        openmode = _winapi.PIPE_ACCESS_DUPLEX\n        access = _winapi.GENERIC_READ | _winapi.GENERIC_WRITE\n        obsize, ibsize = bufsize, bufsize\n    else:",
        "detail": "protobuf.Lib.asyncio.windows_utils",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.windows_utils",
        "description": "protobuf.Lib.asyncio.windows_utils",
        "peekOfCode": "__all__ = 'pipe', 'Popen', 'PIPE', 'PipeHandle'\n# Constants/globals\nBUFSIZE = 8192\nPIPE = subprocess.PIPE\nSTDOUT = subprocess.STDOUT\n_mmap_counter = itertools.count()\n# Replacement for os.pipe() using handles instead of fds\ndef pipe(*, duplex=False, overlapped=(True, True), bufsize=BUFSIZE):\n    \"\"\"Like os.pipe() but with overlapped support and using handles not fds.\"\"\"\n    address = tempfile.mktemp(",
        "detail": "protobuf.Lib.asyncio.windows_utils",
        "documentation": {}
    },
    {
        "label": "BUFSIZE",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.windows_utils",
        "description": "protobuf.Lib.asyncio.windows_utils",
        "peekOfCode": "BUFSIZE = 8192\nPIPE = subprocess.PIPE\nSTDOUT = subprocess.STDOUT\n_mmap_counter = itertools.count()\n# Replacement for os.pipe() using handles instead of fds\ndef pipe(*, duplex=False, overlapped=(True, True), bufsize=BUFSIZE):\n    \"\"\"Like os.pipe() but with overlapped support and using handles not fds.\"\"\"\n    address = tempfile.mktemp(\n        prefix=r'\\\\.\\pipe\\python-pipe-{:d}-{:d}-'.format(\n            os.getpid(), next(_mmap_counter)))",
        "detail": "protobuf.Lib.asyncio.windows_utils",
        "documentation": {}
    },
    {
        "label": "PIPE",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.windows_utils",
        "description": "protobuf.Lib.asyncio.windows_utils",
        "peekOfCode": "PIPE = subprocess.PIPE\nSTDOUT = subprocess.STDOUT\n_mmap_counter = itertools.count()\n# Replacement for os.pipe() using handles instead of fds\ndef pipe(*, duplex=False, overlapped=(True, True), bufsize=BUFSIZE):\n    \"\"\"Like os.pipe() but with overlapped support and using handles not fds.\"\"\"\n    address = tempfile.mktemp(\n        prefix=r'\\\\.\\pipe\\python-pipe-{:d}-{:d}-'.format(\n            os.getpid(), next(_mmap_counter)))\n    if duplex:",
        "detail": "protobuf.Lib.asyncio.windows_utils",
        "documentation": {}
    },
    {
        "label": "STDOUT",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.windows_utils",
        "description": "protobuf.Lib.asyncio.windows_utils",
        "peekOfCode": "STDOUT = subprocess.STDOUT\n_mmap_counter = itertools.count()\n# Replacement for os.pipe() using handles instead of fds\ndef pipe(*, duplex=False, overlapped=(True, True), bufsize=BUFSIZE):\n    \"\"\"Like os.pipe() but with overlapped support and using handles not fds.\"\"\"\n    address = tempfile.mktemp(\n        prefix=r'\\\\.\\pipe\\python-pipe-{:d}-{:d}-'.format(\n            os.getpid(), next(_mmap_counter)))\n    if duplex:\n        openmode = _winapi.PIPE_ACCESS_DUPLEX",
        "detail": "protobuf.Lib.asyncio.windows_utils",
        "documentation": {}
    },
    {
        "label": "_mmap_counter",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncio.windows_utils",
        "description": "protobuf.Lib.asyncio.windows_utils",
        "peekOfCode": "_mmap_counter = itertools.count()\n# Replacement for os.pipe() using handles instead of fds\ndef pipe(*, duplex=False, overlapped=(True, True), bufsize=BUFSIZE):\n    \"\"\"Like os.pipe() but with overlapped support and using handles not fds.\"\"\"\n    address = tempfile.mktemp(\n        prefix=r'\\\\.\\pipe\\python-pipe-{:d}-{:d}-'.format(\n            os.getpid(), next(_mmap_counter)))\n    if duplex:\n        openmode = _winapi.PIPE_ACCESS_DUPLEX\n        access = _winapi.GENERIC_READ | _winapi.GENERIC_WRITE",
        "detail": "protobuf.Lib.asyncio.windows_utils",
        "documentation": {}
    },
    {
        "label": "_ThreadWakeup",
        "kind": 6,
        "importPath": "protobuf.Lib.concurrent.futures.process",
        "description": "protobuf.Lib.concurrent.futures.process",
        "peekOfCode": "class _ThreadWakeup:\n    def __init__(self):\n        self._closed = False\n        self._reader, self._writer = mp.Pipe(duplex=False)\n    def close(self):\n        if not self._closed:\n            self._closed = True\n            self._writer.close()\n            self._reader.close()\n    def wakeup(self):",
        "detail": "protobuf.Lib.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "_RemoteTraceback",
        "kind": 6,
        "importPath": "protobuf.Lib.concurrent.futures.process",
        "description": "protobuf.Lib.concurrent.futures.process",
        "peekOfCode": "class _RemoteTraceback(Exception):\n    def __init__(self, tb):\n        self.tb = tb\n    def __str__(self):\n        return self.tb\nclass _ExceptionWithTraceback:\n    def __init__(self, exc, tb):\n        tb = traceback.format_exception(type(exc), exc, tb)\n        tb = ''.join(tb)\n        self.exc = exc",
        "detail": "protobuf.Lib.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "_ExceptionWithTraceback",
        "kind": 6,
        "importPath": "protobuf.Lib.concurrent.futures.process",
        "description": "protobuf.Lib.concurrent.futures.process",
        "peekOfCode": "class _ExceptionWithTraceback:\n    def __init__(self, exc, tb):\n        tb = traceback.format_exception(type(exc), exc, tb)\n        tb = ''.join(tb)\n        self.exc = exc\n        # Traceback object needs to be garbage-collected as its frames\n        # contain references to all the objects in the exception scope\n        self.exc.__traceback__ = None\n        self.tb = '\\n\"\"\"\\n%s\"\"\"' % tb\n    def __reduce__(self):",
        "detail": "protobuf.Lib.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "_WorkItem",
        "kind": 6,
        "importPath": "protobuf.Lib.concurrent.futures.process",
        "description": "protobuf.Lib.concurrent.futures.process",
        "peekOfCode": "class _WorkItem(object):\n    def __init__(self, future, fn, args, kwargs):\n        self.future = future\n        self.fn = fn\n        self.args = args\n        self.kwargs = kwargs\nclass _ResultItem(object):\n    def __init__(self, work_id, exception=None, result=None):\n        self.work_id = work_id\n        self.exception = exception",
        "detail": "protobuf.Lib.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "_ResultItem",
        "kind": 6,
        "importPath": "protobuf.Lib.concurrent.futures.process",
        "description": "protobuf.Lib.concurrent.futures.process",
        "peekOfCode": "class _ResultItem(object):\n    def __init__(self, work_id, exception=None, result=None):\n        self.work_id = work_id\n        self.exception = exception\n        self.result = result\nclass _CallItem(object):\n    def __init__(self, work_id, fn, args, kwargs):\n        self.work_id = work_id\n        self.fn = fn\n        self.args = args",
        "detail": "protobuf.Lib.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "_CallItem",
        "kind": 6,
        "importPath": "protobuf.Lib.concurrent.futures.process",
        "description": "protobuf.Lib.concurrent.futures.process",
        "peekOfCode": "class _CallItem(object):\n    def __init__(self, work_id, fn, args, kwargs):\n        self.work_id = work_id\n        self.fn = fn\n        self.args = args\n        self.kwargs = kwargs\nclass _SafeQueue(Queue):\n    \"\"\"Safe Queue set exception to the future object linked to a job\"\"\"\n    def __init__(self, max_size=0, *, ctx, pending_work_items, shutdown_lock,\n                 thread_wakeup):",
        "detail": "protobuf.Lib.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "_SafeQueue",
        "kind": 6,
        "importPath": "protobuf.Lib.concurrent.futures.process",
        "description": "protobuf.Lib.concurrent.futures.process",
        "peekOfCode": "class _SafeQueue(Queue):\n    \"\"\"Safe Queue set exception to the future object linked to a job\"\"\"\n    def __init__(self, max_size=0, *, ctx, pending_work_items, shutdown_lock,\n                 thread_wakeup):\n        self.pending_work_items = pending_work_items\n        self.shutdown_lock = shutdown_lock\n        self.thread_wakeup = thread_wakeup\n        super().__init__(max_size, ctx=ctx)\n    def _on_queue_feeder_error(self, e, obj):\n        if isinstance(obj, _CallItem):",
        "detail": "protobuf.Lib.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "_ExecutorManagerThread",
        "kind": 6,
        "importPath": "protobuf.Lib.concurrent.futures.process",
        "description": "protobuf.Lib.concurrent.futures.process",
        "peekOfCode": "class _ExecutorManagerThread(threading.Thread):\n    \"\"\"Manages the communication between this process and the worker processes.\n    The manager is run in a local thread.\n    Args:\n        executor: A reference to the ProcessPoolExecutor that owns\n            this thread. A weakref will be own by the manager as well as\n            references to internal objects used to introspect the state of\n            the executor.\n    \"\"\"\n    def __init__(self, executor):",
        "detail": "protobuf.Lib.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "BrokenProcessPool",
        "kind": 6,
        "importPath": "protobuf.Lib.concurrent.futures.process",
        "description": "protobuf.Lib.concurrent.futures.process",
        "peekOfCode": "class BrokenProcessPool(_base.BrokenExecutor):\n    \"\"\"\n    Raised when a process in a ProcessPoolExecutor terminated abruptly\n    while a future was in the running state.\n    \"\"\"\nclass ProcessPoolExecutor(_base.Executor):\n    def __init__(self, max_workers=None, mp_context=None,\n                 initializer=None, initargs=()):\n        \"\"\"Initializes a new ProcessPoolExecutor instance.\n        Args:",
        "detail": "protobuf.Lib.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "ProcessPoolExecutor",
        "kind": 6,
        "importPath": "protobuf.Lib.concurrent.futures.process",
        "description": "protobuf.Lib.concurrent.futures.process",
        "peekOfCode": "class ProcessPoolExecutor(_base.Executor):\n    def __init__(self, max_workers=None, mp_context=None,\n                 initializer=None, initargs=()):\n        \"\"\"Initializes a new ProcessPoolExecutor instance.\n        Args:\n            max_workers: The maximum number of processes that can be used to\n                execute the given calls. If None or not given then as many\n                worker processes will be created as the machine has processors.\n            mp_context: A multiprocessing context to launch the workers. This\n                object should provide SimpleQueue, Queue and Process.",
        "detail": "protobuf.Lib.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "protobuf.Lib.concurrent.futures.process",
        "description": "protobuf.Lib.concurrent.futures.process",
        "peekOfCode": "__author__ = 'Brian Quinlan (brian@sweetapp.com)'\nimport os\nfrom concurrent.futures import _base\nimport queue\nimport multiprocessing as mp\nimport multiprocessing.connection\nfrom multiprocessing.queues import Queue\nimport threading\nimport weakref\nfrom functools import partial",
        "detail": "protobuf.Lib.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "_threads_wakeups",
        "kind": 5,
        "importPath": "protobuf.Lib.concurrent.futures.process",
        "description": "protobuf.Lib.concurrent.futures.process",
        "peekOfCode": "_threads_wakeups = weakref.WeakKeyDictionary()\n_global_shutdown = False\nclass _ThreadWakeup:\n    def __init__(self):\n        self._closed = False\n        self._reader, self._writer = mp.Pipe(duplex=False)\n    def close(self):\n        if not self._closed:\n            self._closed = True\n            self._writer.close()",
        "detail": "protobuf.Lib.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "_global_shutdown",
        "kind": 5,
        "importPath": "protobuf.Lib.concurrent.futures.process",
        "description": "protobuf.Lib.concurrent.futures.process",
        "peekOfCode": "_global_shutdown = False\nclass _ThreadWakeup:\n    def __init__(self):\n        self._closed = False\n        self._reader, self._writer = mp.Pipe(duplex=False)\n    def close(self):\n        if not self._closed:\n            self._closed = True\n            self._writer.close()\n            self._reader.close()",
        "detail": "protobuf.Lib.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "EXTRA_QUEUED_CALLS",
        "kind": 5,
        "importPath": "protobuf.Lib.concurrent.futures.process",
        "description": "protobuf.Lib.concurrent.futures.process",
        "peekOfCode": "EXTRA_QUEUED_CALLS = 1\n# On Windows, WaitForMultipleObjects is used to wait for processes to finish.\n# It can wait on, at most, 63 objects. There is an overhead of two objects:\n# - the result queue reader\n# - the thread wakeup reader\n_MAX_WINDOWS_WORKERS = 63 - 2\n# Hack to embed stringification of remote traceback in local traceback\nclass _RemoteTraceback(Exception):\n    def __init__(self, tb):\n        self.tb = tb",
        "detail": "protobuf.Lib.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "_MAX_WINDOWS_WORKERS",
        "kind": 5,
        "importPath": "protobuf.Lib.concurrent.futures.process",
        "description": "protobuf.Lib.concurrent.futures.process",
        "peekOfCode": "_MAX_WINDOWS_WORKERS = 63 - 2\n# Hack to embed stringification of remote traceback in local traceback\nclass _RemoteTraceback(Exception):\n    def __init__(self, tb):\n        self.tb = tb\n    def __str__(self):\n        return self.tb\nclass _ExceptionWithTraceback:\n    def __init__(self, exc, tb):\n        tb = traceback.format_exception(type(exc), exc, tb)",
        "detail": "protobuf.Lib.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "_system_limits_checked",
        "kind": 5,
        "importPath": "protobuf.Lib.concurrent.futures.process",
        "description": "protobuf.Lib.concurrent.futures.process",
        "peekOfCode": "_system_limits_checked = False\n_system_limited = None\ndef _check_system_limits():\n    global _system_limits_checked, _system_limited\n    if _system_limits_checked:\n        if _system_limited:\n            raise NotImplementedError(_system_limited)\n    _system_limits_checked = True\n    try:\n        import multiprocessing.synchronize",
        "detail": "protobuf.Lib.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "_system_limited",
        "kind": 5,
        "importPath": "protobuf.Lib.concurrent.futures.process",
        "description": "protobuf.Lib.concurrent.futures.process",
        "peekOfCode": "_system_limited = None\ndef _check_system_limits():\n    global _system_limits_checked, _system_limited\n    if _system_limits_checked:\n        if _system_limited:\n            raise NotImplementedError(_system_limited)\n    _system_limits_checked = True\n    try:\n        import multiprocessing.synchronize\n    except ImportError:",
        "detail": "protobuf.Lib.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "_WorkItem",
        "kind": 6,
        "importPath": "protobuf.Lib.concurrent.futures.thread",
        "description": "protobuf.Lib.concurrent.futures.thread",
        "peekOfCode": "class _WorkItem(object):\n    def __init__(self, future, fn, args, kwargs):\n        self.future = future\n        self.fn = fn\n        self.args = args\n        self.kwargs = kwargs\n    def run(self):\n        if not self.future.set_running_or_notify_cancel():\n            return\n        try:",
        "detail": "protobuf.Lib.concurrent.futures.thread",
        "documentation": {}
    },
    {
        "label": "BrokenThreadPool",
        "kind": 6,
        "importPath": "protobuf.Lib.concurrent.futures.thread",
        "description": "protobuf.Lib.concurrent.futures.thread",
        "peekOfCode": "class BrokenThreadPool(_base.BrokenExecutor):\n    \"\"\"\n    Raised when a worker thread in a ThreadPoolExecutor failed initializing.\n    \"\"\"\nclass ThreadPoolExecutor(_base.Executor):\n    # Used to assign unique thread names when thread_name_prefix is not supplied.\n    _counter = itertools.count().__next__\n    def __init__(self, max_workers=None, thread_name_prefix='',\n                 initializer=None, initargs=()):\n        \"\"\"Initializes a new ThreadPoolExecutor instance.",
        "detail": "protobuf.Lib.concurrent.futures.thread",
        "documentation": {}
    },
    {
        "label": "ThreadPoolExecutor",
        "kind": 6,
        "importPath": "protobuf.Lib.concurrent.futures.thread",
        "description": "protobuf.Lib.concurrent.futures.thread",
        "peekOfCode": "class ThreadPoolExecutor(_base.Executor):\n    # Used to assign unique thread names when thread_name_prefix is not supplied.\n    _counter = itertools.count().__next__\n    def __init__(self, max_workers=None, thread_name_prefix='',\n                 initializer=None, initargs=()):\n        \"\"\"Initializes a new ThreadPoolExecutor instance.\n        Args:\n            max_workers: The maximum number of threads that can be used to\n                execute the given calls.\n            thread_name_prefix: An optional name prefix to give our threads.",
        "detail": "protobuf.Lib.concurrent.futures.thread",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "protobuf.Lib.concurrent.futures.thread",
        "description": "protobuf.Lib.concurrent.futures.thread",
        "peekOfCode": "__author__ = 'Brian Quinlan (brian@sweetapp.com)'\nfrom concurrent.futures import _base\nimport itertools\nimport queue\nimport threading\nimport types\nimport weakref\nimport os\n_threads_queues = weakref.WeakKeyDictionary()\n_shutdown = False",
        "detail": "protobuf.Lib.concurrent.futures.thread",
        "documentation": {}
    },
    {
        "label": "_threads_queues",
        "kind": 5,
        "importPath": "protobuf.Lib.concurrent.futures.thread",
        "description": "protobuf.Lib.concurrent.futures.thread",
        "peekOfCode": "_threads_queues = weakref.WeakKeyDictionary()\n_shutdown = False\n# Lock that ensures that new workers are not created while the interpreter is\n# shutting down. Must be held while mutating _threads_queues and _shutdown.\n_global_shutdown_lock = threading.Lock()\ndef _python_exit():\n    global _shutdown\n    with _global_shutdown_lock:\n        _shutdown = True\n    items = list(_threads_queues.items())",
        "detail": "protobuf.Lib.concurrent.futures.thread",
        "documentation": {}
    },
    {
        "label": "_shutdown",
        "kind": 5,
        "importPath": "protobuf.Lib.concurrent.futures.thread",
        "description": "protobuf.Lib.concurrent.futures.thread",
        "peekOfCode": "_shutdown = False\n# Lock that ensures that new workers are not created while the interpreter is\n# shutting down. Must be held while mutating _threads_queues and _shutdown.\n_global_shutdown_lock = threading.Lock()\ndef _python_exit():\n    global _shutdown\n    with _global_shutdown_lock:\n        _shutdown = True\n    items = list(_threads_queues.items())\n    for t, q in items:",
        "detail": "protobuf.Lib.concurrent.futures.thread",
        "documentation": {}
    },
    {
        "label": "_global_shutdown_lock",
        "kind": 5,
        "importPath": "protobuf.Lib.concurrent.futures.thread",
        "description": "protobuf.Lib.concurrent.futures.thread",
        "peekOfCode": "_global_shutdown_lock = threading.Lock()\ndef _python_exit():\n    global _shutdown\n    with _global_shutdown_lock:\n        _shutdown = True\n    items = list(_threads_queues.items())\n    for t, q in items:\n        q.put(None)\n    for t, q in items:\n        t.join()",
        "detail": "protobuf.Lib.concurrent.futures.thread",
        "documentation": {}
    },
    {
        "label": "Error",
        "kind": 6,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "class Error(Exception):\n    \"\"\"Base class for all future-related exceptions.\"\"\"\n    pass\nclass CancelledError(Error):\n    \"\"\"The Future was cancelled.\"\"\"\n    pass\nclass TimeoutError(Error):\n    \"\"\"The operation exceeded the given deadline.\"\"\"\n    pass\nclass InvalidStateError(Error):",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "CancelledError",
        "kind": 6,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "class CancelledError(Error):\n    \"\"\"The Future was cancelled.\"\"\"\n    pass\nclass TimeoutError(Error):\n    \"\"\"The operation exceeded the given deadline.\"\"\"\n    pass\nclass InvalidStateError(Error):\n    \"\"\"The operation is not allowed in this state.\"\"\"\n    pass\nclass _Waiter(object):",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "TimeoutError",
        "kind": 6,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "class TimeoutError(Error):\n    \"\"\"The operation exceeded the given deadline.\"\"\"\n    pass\nclass InvalidStateError(Error):\n    \"\"\"The operation is not allowed in this state.\"\"\"\n    pass\nclass _Waiter(object):\n    \"\"\"Provides the event that wait() and as_completed() block on.\"\"\"\n    def __init__(self):\n        self.event = threading.Event()",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "InvalidStateError",
        "kind": 6,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "class InvalidStateError(Error):\n    \"\"\"The operation is not allowed in this state.\"\"\"\n    pass\nclass _Waiter(object):\n    \"\"\"Provides the event that wait() and as_completed() block on.\"\"\"\n    def __init__(self):\n        self.event = threading.Event()\n        self.finished_futures = []\n    def add_result(self, future):\n        self.finished_futures.append(future)",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "_Waiter",
        "kind": 6,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "class _Waiter(object):\n    \"\"\"Provides the event that wait() and as_completed() block on.\"\"\"\n    def __init__(self):\n        self.event = threading.Event()\n        self.finished_futures = []\n    def add_result(self, future):\n        self.finished_futures.append(future)\n    def add_exception(self, future):\n        self.finished_futures.append(future)\n    def add_cancelled(self, future):",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "_AsCompletedWaiter",
        "kind": 6,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "class _AsCompletedWaiter(_Waiter):\n    \"\"\"Used by as_completed().\"\"\"\n    def __init__(self):\n        super(_AsCompletedWaiter, self).__init__()\n        self.lock = threading.Lock()\n    def add_result(self, future):\n        with self.lock:\n            super(_AsCompletedWaiter, self).add_result(future)\n            self.event.set()\n    def add_exception(self, future):",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "_FirstCompletedWaiter",
        "kind": 6,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "class _FirstCompletedWaiter(_Waiter):\n    \"\"\"Used by wait(return_when=FIRST_COMPLETED).\"\"\"\n    def add_result(self, future):\n        super().add_result(future)\n        self.event.set()\n    def add_exception(self, future):\n        super().add_exception(future)\n        self.event.set()\n    def add_cancelled(self, future):\n        super().add_cancelled(future)",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "_AllCompletedWaiter",
        "kind": 6,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "class _AllCompletedWaiter(_Waiter):\n    \"\"\"Used by wait(return_when=FIRST_EXCEPTION and ALL_COMPLETED).\"\"\"\n    def __init__(self, num_pending_calls, stop_on_exception):\n        self.num_pending_calls = num_pending_calls\n        self.stop_on_exception = stop_on_exception\n        self.lock = threading.Lock()\n        super().__init__()\n    def _decrement_pending_calls(self):\n        with self.lock:\n            self.num_pending_calls -= 1",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "_AcquireFutures",
        "kind": 6,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "class _AcquireFutures(object):\n    \"\"\"A context manager that does an ordered acquire of Future conditions.\"\"\"\n    def __init__(self, futures):\n        self.futures = sorted(futures, key=id)\n    def __enter__(self):\n        for future in self.futures:\n            future._condition.acquire()\n    def __exit__(self, *args):\n        for future in self.futures:\n            future._condition.release()",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "Future",
        "kind": 6,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "class Future(object):\n    \"\"\"Represents the result of an asynchronous computation.\"\"\"\n    def __init__(self):\n        \"\"\"Initializes the future. Should not be called by clients.\"\"\"\n        self._condition = threading.Condition()\n        self._state = PENDING\n        self._result = None\n        self._exception = None\n        self._waiters = []\n        self._done_callbacks = []",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "Executor",
        "kind": 6,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "class Executor(object):\n    \"\"\"This is an abstract base class for concrete asynchronous executors.\"\"\"\n    def submit(self, fn, /, *args, **kwargs):\n        \"\"\"Submits a callable to be executed with the given arguments.\n        Schedules the callable to be executed as fn(*args, **kwargs) and returns\n        a Future instance representing the execution of the callable.\n        Returns:\n            A Future representing the given call.\n        \"\"\"\n        raise NotImplementedError()",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "BrokenExecutor",
        "kind": 6,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "class BrokenExecutor(RuntimeError):\n    \"\"\"\n    Raised when a executor has become non-functional after a severe failure.\n    \"\"\"",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "as_completed",
        "kind": 2,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "def as_completed(fs, timeout=None):\n    \"\"\"An iterator over the given futures that yields each as it completes.\n    Args:\n        fs: The sequence of Futures (possibly created by different Executors) to\n            iterate over.\n        timeout: The maximum number of seconds to wait. If None, then there\n            is no limit on the wait time.\n    Returns:\n        An iterator that yields the given Futures as they complete (finished or\n        cancelled). If any given Futures are duplicated, they will be returned",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "wait",
        "kind": 2,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "def wait(fs, timeout=None, return_when=ALL_COMPLETED):\n    \"\"\"Wait for the futures in the given sequence to complete.\n    Args:\n        fs: The sequence of Futures (possibly created by different Executors) to\n            wait upon.\n        timeout: The maximum number of seconds to wait. If None, then there\n            is no limit on the wait time.\n        return_when: Indicates when this function should return. The options\n            are:\n            FIRST_COMPLETED - Return when any future finishes or is",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "__author__ = 'Brian Quinlan (brian@sweetapp.com)'\nimport collections\nimport logging\nimport threading\nimport time\nimport types\nFIRST_COMPLETED = 'FIRST_COMPLETED'\nFIRST_EXCEPTION = 'FIRST_EXCEPTION'\nALL_COMPLETED = 'ALL_COMPLETED'\n_AS_COMPLETED = '_AS_COMPLETED'",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "FIRST_COMPLETED",
        "kind": 5,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "FIRST_COMPLETED = 'FIRST_COMPLETED'\nFIRST_EXCEPTION = 'FIRST_EXCEPTION'\nALL_COMPLETED = 'ALL_COMPLETED'\n_AS_COMPLETED = '_AS_COMPLETED'\n# Possible future states (for internal use by the futures package).\nPENDING = 'PENDING'\nRUNNING = 'RUNNING'\n# The future was cancelled by the user...\nCANCELLED = 'CANCELLED'\n# ...and _Waiter.add_cancelled() was called by a worker.",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "FIRST_EXCEPTION",
        "kind": 5,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "FIRST_EXCEPTION = 'FIRST_EXCEPTION'\nALL_COMPLETED = 'ALL_COMPLETED'\n_AS_COMPLETED = '_AS_COMPLETED'\n# Possible future states (for internal use by the futures package).\nPENDING = 'PENDING'\nRUNNING = 'RUNNING'\n# The future was cancelled by the user...\nCANCELLED = 'CANCELLED'\n# ...and _Waiter.add_cancelled() was called by a worker.\nCANCELLED_AND_NOTIFIED = 'CANCELLED_AND_NOTIFIED'",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "ALL_COMPLETED",
        "kind": 5,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "ALL_COMPLETED = 'ALL_COMPLETED'\n_AS_COMPLETED = '_AS_COMPLETED'\n# Possible future states (for internal use by the futures package).\nPENDING = 'PENDING'\nRUNNING = 'RUNNING'\n# The future was cancelled by the user...\nCANCELLED = 'CANCELLED'\n# ...and _Waiter.add_cancelled() was called by a worker.\nCANCELLED_AND_NOTIFIED = 'CANCELLED_AND_NOTIFIED'\nFINISHED = 'FINISHED'",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "_AS_COMPLETED",
        "kind": 5,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "_AS_COMPLETED = '_AS_COMPLETED'\n# Possible future states (for internal use by the futures package).\nPENDING = 'PENDING'\nRUNNING = 'RUNNING'\n# The future was cancelled by the user...\nCANCELLED = 'CANCELLED'\n# ...and _Waiter.add_cancelled() was called by a worker.\nCANCELLED_AND_NOTIFIED = 'CANCELLED_AND_NOTIFIED'\nFINISHED = 'FINISHED'\n_FUTURE_STATES = [",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "PENDING",
        "kind": 5,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "PENDING = 'PENDING'\nRUNNING = 'RUNNING'\n# The future was cancelled by the user...\nCANCELLED = 'CANCELLED'\n# ...and _Waiter.add_cancelled() was called by a worker.\nCANCELLED_AND_NOTIFIED = 'CANCELLED_AND_NOTIFIED'\nFINISHED = 'FINISHED'\n_FUTURE_STATES = [\n    PENDING,\n    RUNNING,",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "RUNNING",
        "kind": 5,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "RUNNING = 'RUNNING'\n# The future was cancelled by the user...\nCANCELLED = 'CANCELLED'\n# ...and _Waiter.add_cancelled() was called by a worker.\nCANCELLED_AND_NOTIFIED = 'CANCELLED_AND_NOTIFIED'\nFINISHED = 'FINISHED'\n_FUTURE_STATES = [\n    PENDING,\n    RUNNING,\n    CANCELLED,",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "CANCELLED",
        "kind": 5,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "CANCELLED = 'CANCELLED'\n# ...and _Waiter.add_cancelled() was called by a worker.\nCANCELLED_AND_NOTIFIED = 'CANCELLED_AND_NOTIFIED'\nFINISHED = 'FINISHED'\n_FUTURE_STATES = [\n    PENDING,\n    RUNNING,\n    CANCELLED,\n    CANCELLED_AND_NOTIFIED,\n    FINISHED",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "CANCELLED_AND_NOTIFIED",
        "kind": 5,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "CANCELLED_AND_NOTIFIED = 'CANCELLED_AND_NOTIFIED'\nFINISHED = 'FINISHED'\n_FUTURE_STATES = [\n    PENDING,\n    RUNNING,\n    CANCELLED,\n    CANCELLED_AND_NOTIFIED,\n    FINISHED\n]\n_STATE_TO_DESCRIPTION_MAP = {",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "FINISHED",
        "kind": 5,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "FINISHED = 'FINISHED'\n_FUTURE_STATES = [\n    PENDING,\n    RUNNING,\n    CANCELLED,\n    CANCELLED_AND_NOTIFIED,\n    FINISHED\n]\n_STATE_TO_DESCRIPTION_MAP = {\n    PENDING: \"pending\",",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "_FUTURE_STATES",
        "kind": 5,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "_FUTURE_STATES = [\n    PENDING,\n    RUNNING,\n    CANCELLED,\n    CANCELLED_AND_NOTIFIED,\n    FINISHED\n]\n_STATE_TO_DESCRIPTION_MAP = {\n    PENDING: \"pending\",\n    RUNNING: \"running\",",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "_STATE_TO_DESCRIPTION_MAP",
        "kind": 5,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "_STATE_TO_DESCRIPTION_MAP = {\n    PENDING: \"pending\",\n    RUNNING: \"running\",\n    CANCELLED: \"cancelled\",\n    CANCELLED_AND_NOTIFIED: \"cancelled\",\n    FINISHED: \"finished\"\n}\n# Logger for internal use by the futures package.\nLOGGER = logging.getLogger(\"concurrent.futures\")\nclass Error(Exception):",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "kind": 5,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "LOGGER = logging.getLogger(\"concurrent.futures\")\nclass Error(Exception):\n    \"\"\"Base class for all future-related exceptions.\"\"\"\n    pass\nclass CancelledError(Error):\n    \"\"\"The Future was cancelled.\"\"\"\n    pass\nclass TimeoutError(Error):\n    \"\"\"The operation exceeded the given deadline.\"\"\"\n    pass",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "DoneAndNotDoneFutures",
        "kind": 5,
        "importPath": "protobuf.Lib.concurrent.futures._base",
        "description": "protobuf.Lib.concurrent.futures._base",
        "peekOfCode": "DoneAndNotDoneFutures = collections.namedtuple(\n        'DoneAndNotDoneFutures', 'done not_done')\ndef wait(fs, timeout=None, return_when=ALL_COMPLETED):\n    \"\"\"Wait for the futures in the given sequence to complete.\n    Args:\n        fs: The sequence of Futures (possibly created by different Executors) to\n            wait upon.\n        timeout: The maximum number of seconds to wait. If None, then there\n            is no limit on the wait time.\n        return_when: Indicates when this function should return. The options",
        "detail": "protobuf.Lib.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "dyld_env",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.macholib.dyld",
        "description": "protobuf.Lib.ctypes.macholib.dyld",
        "peekOfCode": "def dyld_env(env, var):\n    if env is None:\n        env = os.environ\n    rval = env.get(var)\n    if rval is None:\n        return []\n    return rval.split(':')\ndef dyld_image_suffix(env=None):\n    if env is None:\n        env = os.environ",
        "detail": "protobuf.Lib.ctypes.macholib.dyld",
        "documentation": {}
    },
    {
        "label": "dyld_image_suffix",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.macholib.dyld",
        "description": "protobuf.Lib.ctypes.macholib.dyld",
        "peekOfCode": "def dyld_image_suffix(env=None):\n    if env is None:\n        env = os.environ\n    return env.get('DYLD_IMAGE_SUFFIX')\ndef dyld_framework_path(env=None):\n    return dyld_env(env, 'DYLD_FRAMEWORK_PATH')\ndef dyld_library_path(env=None):\n    return dyld_env(env, 'DYLD_LIBRARY_PATH')\ndef dyld_fallback_framework_path(env=None):\n    return dyld_env(env, 'DYLD_FALLBACK_FRAMEWORK_PATH')",
        "detail": "protobuf.Lib.ctypes.macholib.dyld",
        "documentation": {}
    },
    {
        "label": "dyld_framework_path",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.macholib.dyld",
        "description": "protobuf.Lib.ctypes.macholib.dyld",
        "peekOfCode": "def dyld_framework_path(env=None):\n    return dyld_env(env, 'DYLD_FRAMEWORK_PATH')\ndef dyld_library_path(env=None):\n    return dyld_env(env, 'DYLD_LIBRARY_PATH')\ndef dyld_fallback_framework_path(env=None):\n    return dyld_env(env, 'DYLD_FALLBACK_FRAMEWORK_PATH')\ndef dyld_fallback_library_path(env=None):\n    return dyld_env(env, 'DYLD_FALLBACK_LIBRARY_PATH')\ndef dyld_image_suffix_search(iterator, env=None):\n    \"\"\"For a potential path iterator, add DYLD_IMAGE_SUFFIX semantics\"\"\"",
        "detail": "protobuf.Lib.ctypes.macholib.dyld",
        "documentation": {}
    },
    {
        "label": "dyld_library_path",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.macholib.dyld",
        "description": "protobuf.Lib.ctypes.macholib.dyld",
        "peekOfCode": "def dyld_library_path(env=None):\n    return dyld_env(env, 'DYLD_LIBRARY_PATH')\ndef dyld_fallback_framework_path(env=None):\n    return dyld_env(env, 'DYLD_FALLBACK_FRAMEWORK_PATH')\ndef dyld_fallback_library_path(env=None):\n    return dyld_env(env, 'DYLD_FALLBACK_LIBRARY_PATH')\ndef dyld_image_suffix_search(iterator, env=None):\n    \"\"\"For a potential path iterator, add DYLD_IMAGE_SUFFIX semantics\"\"\"\n    suffix = dyld_image_suffix(env)\n    if suffix is None:",
        "detail": "protobuf.Lib.ctypes.macholib.dyld",
        "documentation": {}
    },
    {
        "label": "dyld_fallback_framework_path",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.macholib.dyld",
        "description": "protobuf.Lib.ctypes.macholib.dyld",
        "peekOfCode": "def dyld_fallback_framework_path(env=None):\n    return dyld_env(env, 'DYLD_FALLBACK_FRAMEWORK_PATH')\ndef dyld_fallback_library_path(env=None):\n    return dyld_env(env, 'DYLD_FALLBACK_LIBRARY_PATH')\ndef dyld_image_suffix_search(iterator, env=None):\n    \"\"\"For a potential path iterator, add DYLD_IMAGE_SUFFIX semantics\"\"\"\n    suffix = dyld_image_suffix(env)\n    if suffix is None:\n        return iterator\n    def _inject(iterator=iterator, suffix=suffix):",
        "detail": "protobuf.Lib.ctypes.macholib.dyld",
        "documentation": {}
    },
    {
        "label": "dyld_fallback_library_path",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.macholib.dyld",
        "description": "protobuf.Lib.ctypes.macholib.dyld",
        "peekOfCode": "def dyld_fallback_library_path(env=None):\n    return dyld_env(env, 'DYLD_FALLBACK_LIBRARY_PATH')\ndef dyld_image_suffix_search(iterator, env=None):\n    \"\"\"For a potential path iterator, add DYLD_IMAGE_SUFFIX semantics\"\"\"\n    suffix = dyld_image_suffix(env)\n    if suffix is None:\n        return iterator\n    def _inject(iterator=iterator, suffix=suffix):\n        for path in iterator:\n            if path.endswith('.dylib'):",
        "detail": "protobuf.Lib.ctypes.macholib.dyld",
        "documentation": {}
    },
    {
        "label": "dyld_image_suffix_search",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.macholib.dyld",
        "description": "protobuf.Lib.ctypes.macholib.dyld",
        "peekOfCode": "def dyld_image_suffix_search(iterator, env=None):\n    \"\"\"For a potential path iterator, add DYLD_IMAGE_SUFFIX semantics\"\"\"\n    suffix = dyld_image_suffix(env)\n    if suffix is None:\n        return iterator\n    def _inject(iterator=iterator, suffix=suffix):\n        for path in iterator:\n            if path.endswith('.dylib'):\n                yield path[:-len('.dylib')] + suffix + '.dylib'\n            else:",
        "detail": "protobuf.Lib.ctypes.macholib.dyld",
        "documentation": {}
    },
    {
        "label": "dyld_override_search",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.macholib.dyld",
        "description": "protobuf.Lib.ctypes.macholib.dyld",
        "peekOfCode": "def dyld_override_search(name, env=None):\n    # If DYLD_FRAMEWORK_PATH is set and this dylib_name is a\n    # framework name, use the first file that exists in the framework\n    # path if any.  If there is none go on to search the DYLD_LIBRARY_PATH\n    # if any.\n    framework = framework_info(name)\n    if framework is not None:\n        for path in dyld_framework_path(env):\n            yield os.path.join(path, framework['name'])\n    # If DYLD_LIBRARY_PATH is set then use the first file that exists",
        "detail": "protobuf.Lib.ctypes.macholib.dyld",
        "documentation": {}
    },
    {
        "label": "dyld_executable_path_search",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.macholib.dyld",
        "description": "protobuf.Lib.ctypes.macholib.dyld",
        "peekOfCode": "def dyld_executable_path_search(name, executable_path=None):\n    # If we haven't done any searching and found a library and the\n    # dylib_name starts with \"@executable_path/\" then construct the\n    # library name.\n    if not executable_path:\n        import sys\n        if sys.prefix:\n            executable_path = os.path.join(sys.prefix, 'bin')\n    if name.startswith('@executable_path/') and executable_path is not None:\n        yield os.path.join(executable_path, name[len('@executable_path/'):])",
        "detail": "protobuf.Lib.ctypes.macholib.dyld",
        "documentation": {}
    },
    {
        "label": "dyld_default_search",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.macholib.dyld",
        "description": "protobuf.Lib.ctypes.macholib.dyld",
        "peekOfCode": "def dyld_default_search(name, env=None):\n    yield name\n    framework = framework_info(name)\n    if framework is not None:\n        fallback_framework_path = dyld_fallback_framework_path(env)\n        for path in fallback_framework_path:\n            yield os.path.join(path, framework['name'])\n    fallback_library_path = dyld_fallback_library_path(env)\n    for path in fallback_library_path:\n        yield os.path.join(path, os.path.basename(name))",
        "detail": "protobuf.Lib.ctypes.macholib.dyld",
        "documentation": {}
    },
    {
        "label": "dyld_find",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.macholib.dyld",
        "description": "protobuf.Lib.ctypes.macholib.dyld",
        "peekOfCode": "def dyld_find(name, executable_path=None, env=None):\n    \"\"\"\n    Find a library or framework using dyld semantics\n    \"\"\"\n    for path in dyld_image_suffix_search(chain(\n                dyld_override_search(name, env),\n                dyld_executable_path_search(name, executable_path),\n                dyld_default_search(name, env),\n            ), env):\n        if os.path.isfile(path):",
        "detail": "protobuf.Lib.ctypes.macholib.dyld",
        "documentation": {}
    },
    {
        "label": "framework_find",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.macholib.dyld",
        "description": "protobuf.Lib.ctypes.macholib.dyld",
        "peekOfCode": "def framework_find(fn, executable_path=None, env=None):\n    \"\"\"\n    Find a framework using dyld semantics in a very loose manner.\n    Will take input such as:\n        Python\n        Python.framework\n        Python.framework/Versions/Current\n    \"\"\"\n    error = None\n    try:",
        "detail": "protobuf.Lib.ctypes.macholib.dyld",
        "documentation": {}
    },
    {
        "label": "test_dyld_find",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.macholib.dyld",
        "description": "protobuf.Lib.ctypes.macholib.dyld",
        "peekOfCode": "def test_dyld_find():\n    env = {}\n    assert dyld_find('libSystem.dylib') == '/usr/lib/libSystem.dylib'\n    assert dyld_find('System.framework/System') == '/System/Library/Frameworks/System.framework/System'\nif __name__ == '__main__':\n    test_dyld_find()",
        "detail": "protobuf.Lib.ctypes.macholib.dyld",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.macholib.dyld",
        "description": "protobuf.Lib.ctypes.macholib.dyld",
        "peekOfCode": "__all__ = [\n    'dyld_find', 'framework_find',\n    'framework_info', 'dylib_info',\n]\n# These are the defaults as per man dyld(1)\n#\nDEFAULT_FRAMEWORK_FALLBACK = [\n    os.path.expanduser(\"~/Library/Frameworks\"),\n    \"/Library/Frameworks\",\n    \"/Network/Library/Frameworks\",",
        "detail": "protobuf.Lib.ctypes.macholib.dyld",
        "documentation": {}
    },
    {
        "label": "DEFAULT_FRAMEWORK_FALLBACK",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.macholib.dyld",
        "description": "protobuf.Lib.ctypes.macholib.dyld",
        "peekOfCode": "DEFAULT_FRAMEWORK_FALLBACK = [\n    os.path.expanduser(\"~/Library/Frameworks\"),\n    \"/Library/Frameworks\",\n    \"/Network/Library/Frameworks\",\n    \"/System/Library/Frameworks\",\n]\nDEFAULT_LIBRARY_FALLBACK = [\n    os.path.expanduser(\"~/lib\"),\n    \"/usr/local/lib\",\n    \"/lib\",",
        "detail": "protobuf.Lib.ctypes.macholib.dyld",
        "documentation": {}
    },
    {
        "label": "DEFAULT_LIBRARY_FALLBACK",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.macholib.dyld",
        "description": "protobuf.Lib.ctypes.macholib.dyld",
        "peekOfCode": "DEFAULT_LIBRARY_FALLBACK = [\n    os.path.expanduser(\"~/lib\"),\n    \"/usr/local/lib\",\n    \"/lib\",\n    \"/usr/lib\",\n]\ndef dyld_env(env, var):\n    if env is None:\n        env = os.environ\n    rval = env.get(var)",
        "detail": "protobuf.Lib.ctypes.macholib.dyld",
        "documentation": {}
    },
    {
        "label": "dylib_info",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.macholib.dylib",
        "description": "protobuf.Lib.ctypes.macholib.dylib",
        "peekOfCode": "def dylib_info(filename):\n    \"\"\"\n    A dylib name can take one of the following four forms:\n        Location/Name.SomeVersion_Suffix.dylib\n        Location/Name.SomeVersion.dylib\n        Location/Name_Suffix.dylib\n        Location/Name.dylib\n    returns None if not found or a mapping equivalent to:\n        dict(\n            location='Location',",
        "detail": "protobuf.Lib.ctypes.macholib.dylib",
        "documentation": {}
    },
    {
        "label": "test_dylib_info",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.macholib.dylib",
        "description": "protobuf.Lib.ctypes.macholib.dylib",
        "peekOfCode": "def test_dylib_info():\n    def d(location=None, name=None, shortname=None, version=None, suffix=None):\n        return dict(\n            location=location,\n            name=name,\n            shortname=shortname,\n            version=version,\n            suffix=suffix\n        )\n    assert dylib_info('completely/invalid') is None",
        "detail": "protobuf.Lib.ctypes.macholib.dylib",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.macholib.dylib",
        "description": "protobuf.Lib.ctypes.macholib.dylib",
        "peekOfCode": "__all__ = ['dylib_info']\nDYLIB_RE = re.compile(r\"\"\"(?x)\n(?P<location>^.*)(?:^|/)\n(?P<name>\n    (?P<shortname>\\w+?)\n    (?:\\.(?P<version>[^._]+))?\n    (?:_(?P<suffix>[^._]+))?\n    \\.dylib$\n)\n\"\"\")",
        "detail": "protobuf.Lib.ctypes.macholib.dylib",
        "documentation": {}
    },
    {
        "label": "DYLIB_RE",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.macholib.dylib",
        "description": "protobuf.Lib.ctypes.macholib.dylib",
        "peekOfCode": "DYLIB_RE = re.compile(r\"\"\"(?x)\n(?P<location>^.*)(?:^|/)\n(?P<name>\n    (?P<shortname>\\w+?)\n    (?:\\.(?P<version>[^._]+))?\n    (?:_(?P<suffix>[^._]+))?\n    \\.dylib$\n)\n\"\"\")\ndef dylib_info(filename):",
        "detail": "protobuf.Lib.ctypes.macholib.dylib",
        "documentation": {}
    },
    {
        "label": "framework_info",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.macholib.framework",
        "description": "protobuf.Lib.ctypes.macholib.framework",
        "peekOfCode": "def framework_info(filename):\n    \"\"\"\n    A framework name can take one of the following four forms:\n        Location/Name.framework/Versions/SomeVersion/Name_Suffix\n        Location/Name.framework/Versions/SomeVersion/Name\n        Location/Name.framework/Name_Suffix\n        Location/Name.framework/Name\n    returns None if not found, or a mapping equivalent to:\n        dict(\n            location='Location',",
        "detail": "protobuf.Lib.ctypes.macholib.framework",
        "documentation": {}
    },
    {
        "label": "test_framework_info",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.macholib.framework",
        "description": "protobuf.Lib.ctypes.macholib.framework",
        "peekOfCode": "def test_framework_info():\n    def d(location=None, name=None, shortname=None, version=None, suffix=None):\n        return dict(\n            location=location,\n            name=name,\n            shortname=shortname,\n            version=version,\n            suffix=suffix\n        )\n    assert framework_info('completely/invalid') is None",
        "detail": "protobuf.Lib.ctypes.macholib.framework",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.macholib.framework",
        "description": "protobuf.Lib.ctypes.macholib.framework",
        "peekOfCode": "__all__ = ['framework_info']\nSTRICT_FRAMEWORK_RE = re.compile(r\"\"\"(?x)\n(?P<location>^.*)(?:^|/)\n(?P<name>\n    (?P<shortname>\\w+).framework/\n    (?:Versions/(?P<version>[^/]+)/)?\n    (?P=shortname)\n    (?:_(?P<suffix>[^_]+))?\n)$\n\"\"\")",
        "detail": "protobuf.Lib.ctypes.macholib.framework",
        "documentation": {}
    },
    {
        "label": "STRICT_FRAMEWORK_RE",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.macholib.framework",
        "description": "protobuf.Lib.ctypes.macholib.framework",
        "peekOfCode": "STRICT_FRAMEWORK_RE = re.compile(r\"\"\"(?x)\n(?P<location>^.*)(?:^|/)\n(?P<name>\n    (?P<shortname>\\w+).framework/\n    (?:Versions/(?P<version>[^/]+)/)?\n    (?P=shortname)\n    (?:_(?P<suffix>[^_]+))?\n)$\n\"\"\")\ndef framework_info(filename):",
        "detail": "protobuf.Lib.ctypes.macholib.framework",
        "documentation": {}
    },
    {
        "label": "AnonTest",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_anon",
        "description": "protobuf.Lib.ctypes.test.test_anon",
        "peekOfCode": "class AnonTest(unittest.TestCase):\n    def test_anon(self):\n        class ANON(Union):\n            _fields_ = [(\"a\", c_int),\n                        (\"b\", c_int)]\n        class Y(Structure):\n            _fields_ = [(\"x\", c_int),\n                        (\"_\", ANON),\n                        (\"y\", c_int)]\n            _anonymous_ = [\"_\"]",
        "detail": "protobuf.Lib.ctypes.test.test_anon",
        "documentation": {}
    },
    {
        "label": "ArrayTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_arrays",
        "description": "protobuf.Lib.ctypes.test.test_arrays",
        "peekOfCode": "class ArrayTestCase(unittest.TestCase):\n    def test_simple(self):\n        # create classes holding simple numeric types, and check\n        # various properties.\n        init = list(range(15, 25))\n        for fmt in formats:\n            alen = len(init)\n            int_array = ARRAY(fmt, alen)\n            ia = int_array(*init)\n            # length of instance ok?",
        "detail": "protobuf.Lib.ctypes.test.test_arrays",
        "documentation": {}
    },
    {
        "label": "formats",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_arrays",
        "description": "protobuf.Lib.ctypes.test.test_arrays",
        "peekOfCode": "formats = \"bBhHiIlLqQfd\"\nformats = c_byte, c_ubyte, c_short, c_ushort, c_int, c_uint, \\\n          c_long, c_ulonglong, c_float, c_double, c_longdouble\nclass ArrayTestCase(unittest.TestCase):\n    def test_simple(self):\n        # create classes holding simple numeric types, and check\n        # various properties.\n        init = list(range(15, 25))\n        for fmt in formats:\n            alen = len(init)",
        "detail": "protobuf.Lib.ctypes.test.test_arrays",
        "documentation": {}
    },
    {
        "label": "formats",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_arrays",
        "description": "protobuf.Lib.ctypes.test.test_arrays",
        "peekOfCode": "formats = c_byte, c_ubyte, c_short, c_ushort, c_int, c_uint, \\\n          c_long, c_ulonglong, c_float, c_double, c_longdouble\nclass ArrayTestCase(unittest.TestCase):\n    def test_simple(self):\n        # create classes holding simple numeric types, and check\n        # various properties.\n        init = list(range(15, 25))\n        for fmt in formats:\n            alen = len(init)\n            int_array = ARRAY(fmt, alen)",
        "detail": "protobuf.Lib.ctypes.test.test_arrays",
        "documentation": {}
    },
    {
        "label": "Value",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_array_in_pointer",
        "description": "protobuf.Lib.ctypes.test.test_array_in_pointer",
        "peekOfCode": "class Value(Structure):\n    _fields_ = [(\"val\", c_byte)]\nclass Container(Structure):\n    _fields_ = [(\"pvalues\", POINTER(Value))]\nclass Test(unittest.TestCase):\n    def test(self):\n        # create an array of 4 values\n        val_array = (Value * 4)()\n        # create a container, which holds a pointer to the pvalues array.\n        c = Container()",
        "detail": "protobuf.Lib.ctypes.test.test_array_in_pointer",
        "documentation": {}
    },
    {
        "label": "Container",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_array_in_pointer",
        "description": "protobuf.Lib.ctypes.test.test_array_in_pointer",
        "peekOfCode": "class Container(Structure):\n    _fields_ = [(\"pvalues\", POINTER(Value))]\nclass Test(unittest.TestCase):\n    def test(self):\n        # create an array of 4 values\n        val_array = (Value * 4)()\n        # create a container, which holds a pointer to the pvalues array.\n        c = Container()\n        c.pvalues = val_array\n        # memory contains 4 NUL bytes now, that's correct",
        "detail": "protobuf.Lib.ctypes.test.test_array_in_pointer",
        "documentation": {}
    },
    {
        "label": "Test",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_array_in_pointer",
        "description": "protobuf.Lib.ctypes.test.test_array_in_pointer",
        "peekOfCode": "class Test(unittest.TestCase):\n    def test(self):\n        # create an array of 4 values\n        val_array = (Value * 4)()\n        # create a container, which holds a pointer to the pvalues array.\n        c = Container()\n        c.pvalues = val_array\n        # memory contains 4 NUL bytes now, that's correct\n        self.assertEqual(\"00-00-00-00\", dump(val_array))\n        # set the values of the array through the pointer:",
        "detail": "protobuf.Lib.ctypes.test.test_array_in_pointer",
        "documentation": {}
    },
    {
        "label": "dump",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.test.test_array_in_pointer",
        "description": "protobuf.Lib.ctypes.test.test_array_in_pointer",
        "peekOfCode": "def dump(obj):\n    # helper function to dump memory contents in hex, with a hyphen\n    # between the bytes.\n    h = hexlify(memoryview(obj)).decode()\n    return re.sub(r\"(..)\", r\"\\1-\", h)[:-1]\nclass Value(Structure):\n    _fields_ = [(\"val\", c_byte)]\nclass Container(Structure):\n    _fields_ = [(\"pvalues\", POINTER(Value))]\nclass Test(unittest.TestCase):",
        "detail": "protobuf.Lib.ctypes.test.test_array_in_pointer",
        "documentation": {}
    },
    {
        "label": "POINT",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_as_parameter",
        "description": "protobuf.Lib.ctypes.test.test_as_parameter",
        "peekOfCode": "class POINT(Structure):\n    _fields_ = [(\"x\", c_int), (\"y\", c_int)]\nclass BasicWrapTestCase(unittest.TestCase):\n    def wrap(self, param):\n        return param\n    @need_symbol('c_wchar')\n    def test_wchar_parm(self):\n        f = dll._testfunc_i_bhilfd\n        f.argtypes = [c_byte, c_wchar, c_int, c_long, c_float, c_double]\n        result = f(self.wrap(1), self.wrap(\"x\"), self.wrap(3), self.wrap(4), self.wrap(5.0), self.wrap(6.0))",
        "detail": "protobuf.Lib.ctypes.test.test_as_parameter",
        "documentation": {}
    },
    {
        "label": "BasicWrapTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_as_parameter",
        "description": "protobuf.Lib.ctypes.test.test_as_parameter",
        "peekOfCode": "class BasicWrapTestCase(unittest.TestCase):\n    def wrap(self, param):\n        return param\n    @need_symbol('c_wchar')\n    def test_wchar_parm(self):\n        f = dll._testfunc_i_bhilfd\n        f.argtypes = [c_byte, c_wchar, c_int, c_long, c_float, c_double]\n        result = f(self.wrap(1), self.wrap(\"x\"), self.wrap(3), self.wrap(4), self.wrap(5.0), self.wrap(6.0))\n        self.assertEqual(result, 139)\n        self.assertIs(type(result), int)",
        "detail": "protobuf.Lib.ctypes.test.test_as_parameter",
        "documentation": {}
    },
    {
        "label": "AsParamWrapper",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_as_parameter",
        "description": "protobuf.Lib.ctypes.test.test_as_parameter",
        "peekOfCode": "class AsParamWrapper(object):\n    def __init__(self, param):\n        self._as_parameter_ = param\nclass AsParamWrapperTestCase(BasicWrapTestCase):\n    wrap = AsParamWrapper\n#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nclass AsParamPropertyWrapper(object):\n    def __init__(self, param):\n        self._param = param\n    def getParameter(self):",
        "detail": "protobuf.Lib.ctypes.test.test_as_parameter",
        "documentation": {}
    },
    {
        "label": "AsParamWrapperTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_as_parameter",
        "description": "protobuf.Lib.ctypes.test.test_as_parameter",
        "peekOfCode": "class AsParamWrapperTestCase(BasicWrapTestCase):\n    wrap = AsParamWrapper\n#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nclass AsParamPropertyWrapper(object):\n    def __init__(self, param):\n        self._param = param\n    def getParameter(self):\n        return self._param\n    _as_parameter_ = property(getParameter)\nclass AsParamPropertyWrapperTestCase(BasicWrapTestCase):",
        "detail": "protobuf.Lib.ctypes.test.test_as_parameter",
        "documentation": {}
    },
    {
        "label": "AsParamPropertyWrapper",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_as_parameter",
        "description": "protobuf.Lib.ctypes.test.test_as_parameter",
        "peekOfCode": "class AsParamPropertyWrapper(object):\n    def __init__(self, param):\n        self._param = param\n    def getParameter(self):\n        return self._param\n    _as_parameter_ = property(getParameter)\nclass AsParamPropertyWrapperTestCase(BasicWrapTestCase):\n    wrap = AsParamPropertyWrapper\n#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nif __name__ == '__main__':",
        "detail": "protobuf.Lib.ctypes.test.test_as_parameter",
        "documentation": {}
    },
    {
        "label": "AsParamPropertyWrapperTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_as_parameter",
        "description": "protobuf.Lib.ctypes.test.test_as_parameter",
        "peekOfCode": "class AsParamPropertyWrapperTestCase(BasicWrapTestCase):\n    wrap = AsParamPropertyWrapper\n#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nif __name__ == '__main__':\n    unittest.main()",
        "detail": "protobuf.Lib.ctypes.test.test_as_parameter",
        "documentation": {}
    },
    {
        "label": "dll",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_as_parameter",
        "description": "protobuf.Lib.ctypes.test.test_as_parameter",
        "peekOfCode": "dll = CDLL(_ctypes_test.__file__)\ntry:\n    CALLBACK_FUNCTYPE = WINFUNCTYPE\nexcept NameError:\n    # fake to enable this test on Linux\n    CALLBACK_FUNCTYPE = CFUNCTYPE\nclass POINT(Structure):\n    _fields_ = [(\"x\", c_int), (\"y\", c_int)]\nclass BasicWrapTestCase(unittest.TestCase):\n    def wrap(self, param):",
        "detail": "protobuf.Lib.ctypes.test.test_as_parameter",
        "documentation": {}
    },
    {
        "label": "BITS",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_bitfields",
        "description": "protobuf.Lib.ctypes.test.test_bitfields",
        "peekOfCode": "class BITS(Structure):\n    _fields_ = [(\"A\", c_int, 1),\n                (\"B\", c_int, 2),\n                (\"C\", c_int, 3),\n                (\"D\", c_int, 4),\n                (\"E\", c_int, 5),\n                (\"F\", c_int, 6),\n                (\"G\", c_int, 7),\n                (\"H\", c_int, 8),\n                (\"I\", c_int, 9),",
        "detail": "protobuf.Lib.ctypes.test.test_bitfields",
        "documentation": {}
    },
    {
        "label": "C_Test",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_bitfields",
        "description": "protobuf.Lib.ctypes.test.test_bitfields",
        "peekOfCode": "class C_Test(unittest.TestCase):\n    def test_ints(self):\n        for i in range(512):\n            for name in \"ABCDEFGHI\":\n                b = BITS()\n                setattr(b, name, i)\n                self.assertEqual(getattr(b, name), func(byref(b), name.encode('ascii')))\n    # bpo-46913: _ctypes/cfield.c h_get() has an undefined behavior\n    @support.skip_if_sanitizer(ub=True)\n    def test_shorts(self):",
        "detail": "protobuf.Lib.ctypes.test.test_bitfields",
        "documentation": {}
    },
    {
        "label": "BitFieldTest",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_bitfields",
        "description": "protobuf.Lib.ctypes.test.test_bitfields",
        "peekOfCode": "class BitFieldTest(unittest.TestCase):\n    def test_longlong(self):\n        class X(Structure):\n            _fields_ = [(\"a\", c_longlong, 1),\n                        (\"b\", c_longlong, 62),\n                        (\"c\", c_longlong, 1)]\n        self.assertEqual(sizeof(X), sizeof(c_longlong))\n        x = X()\n        x.a, x.b, x.c = -1, 7, -1\n        self.assertEqual((x.a, x.b, x.c), (-1, 7, -1))",
        "detail": "protobuf.Lib.ctypes.test.test_bitfields",
        "documentation": {}
    },
    {
        "label": "func",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_bitfields",
        "description": "protobuf.Lib.ctypes.test.test_bitfields",
        "peekOfCode": "func = CDLL(_ctypes_test.__file__).unpack_bitfields\nfunc.argtypes = POINTER(BITS), c_char\n##for n in \"ABCDEFGHIMNOPQRS\":\n##    print n, hex(getattr(BITS, n).size), getattr(BITS, n).offset\nclass C_Test(unittest.TestCase):\n    def test_ints(self):\n        for i in range(512):\n            for name in \"ABCDEFGHI\":\n                b = BITS()\n                setattr(b, name, i)",
        "detail": "protobuf.Lib.ctypes.test.test_bitfields",
        "documentation": {}
    },
    {
        "label": "func.argtypes",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_bitfields",
        "description": "protobuf.Lib.ctypes.test.test_bitfields",
        "peekOfCode": "func.argtypes = POINTER(BITS), c_char\n##for n in \"ABCDEFGHIMNOPQRS\":\n##    print n, hex(getattr(BITS, n).size), getattr(BITS, n).offset\nclass C_Test(unittest.TestCase):\n    def test_ints(self):\n        for i in range(512):\n            for name in \"ABCDEFGHI\":\n                b = BITS()\n                setattr(b, name, i)\n                self.assertEqual(getattr(b, name), func(byref(b), name.encode('ascii')))",
        "detail": "protobuf.Lib.ctypes.test.test_bitfields",
        "documentation": {}
    },
    {
        "label": "signed_int_types",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_bitfields",
        "description": "protobuf.Lib.ctypes.test.test_bitfields",
        "peekOfCode": "signed_int_types = (c_byte, c_short, c_int, c_long, c_longlong)\nunsigned_int_types = (c_ubyte, c_ushort, c_uint, c_ulong, c_ulonglong)\nint_types = unsigned_int_types + signed_int_types\nclass BitFieldTest(unittest.TestCase):\n    def test_longlong(self):\n        class X(Structure):\n            _fields_ = [(\"a\", c_longlong, 1),\n                        (\"b\", c_longlong, 62),\n                        (\"c\", c_longlong, 1)]\n        self.assertEqual(sizeof(X), sizeof(c_longlong))",
        "detail": "protobuf.Lib.ctypes.test.test_bitfields",
        "documentation": {}
    },
    {
        "label": "unsigned_int_types",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_bitfields",
        "description": "protobuf.Lib.ctypes.test.test_bitfields",
        "peekOfCode": "unsigned_int_types = (c_ubyte, c_ushort, c_uint, c_ulong, c_ulonglong)\nint_types = unsigned_int_types + signed_int_types\nclass BitFieldTest(unittest.TestCase):\n    def test_longlong(self):\n        class X(Structure):\n            _fields_ = [(\"a\", c_longlong, 1),\n                        (\"b\", c_longlong, 62),\n                        (\"c\", c_longlong, 1)]\n        self.assertEqual(sizeof(X), sizeof(c_longlong))\n        x = X()",
        "detail": "protobuf.Lib.ctypes.test.test_bitfields",
        "documentation": {}
    },
    {
        "label": "int_types",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_bitfields",
        "description": "protobuf.Lib.ctypes.test.test_bitfields",
        "peekOfCode": "int_types = unsigned_int_types + signed_int_types\nclass BitFieldTest(unittest.TestCase):\n    def test_longlong(self):\n        class X(Structure):\n            _fields_ = [(\"a\", c_longlong, 1),\n                        (\"b\", c_longlong, 62),\n                        (\"c\", c_longlong, 1)]\n        self.assertEqual(sizeof(X), sizeof(c_longlong))\n        x = X()\n        x.a, x.b, x.c = -1, 7, -1",
        "detail": "protobuf.Lib.ctypes.test.test_bitfields",
        "documentation": {}
    },
    {
        "label": "StringBufferTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_buffers",
        "description": "protobuf.Lib.ctypes.test.test_buffers",
        "peekOfCode": "class StringBufferTestCase(unittest.TestCase):\n    def test_buffer(self):\n        b = create_string_buffer(32)\n        self.assertEqual(len(b), 32)\n        self.assertEqual(sizeof(b), 32 * sizeof(c_char))\n        self.assertIs(type(b[0]), bytes)\n        b = create_string_buffer(b\"abc\")\n        self.assertEqual(len(b), 4) # trailing nul char\n        self.assertEqual(sizeof(b), 4 * sizeof(c_char))\n        self.assertIs(type(b[0]), bytes)",
        "detail": "protobuf.Lib.ctypes.test.test_buffers",
        "documentation": {}
    },
    {
        "label": "BytesTest",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_bytes",
        "description": "protobuf.Lib.ctypes.test.test_bytes",
        "peekOfCode": "class BytesTest(unittest.TestCase):\n    def test_c_char(self):\n        x = c_char(b\"x\")\n        self.assertRaises(TypeError, c_char, \"x\")\n        x.value = b\"y\"\n        with self.assertRaises(TypeError):\n            x.value = \"y\"\n        c_char.from_param(b\"x\")\n        self.assertRaises(TypeError, c_char.from_param, \"x\")\n        self.assertIn('xbd', repr(c_char.from_param(b\"\\xbd\")))",
        "detail": "protobuf.Lib.ctypes.test.test_bytes",
        "documentation": {}
    },
    {
        "label": "Test",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_byteswap",
        "description": "protobuf.Lib.ctypes.test.test_byteswap",
        "peekOfCode": "class Test(unittest.TestCase):\n    @unittest.skip('test disabled')\n    def test_X(self):\n        print(sys.byteorder, file=sys.stderr)\n        for i in range(32):\n            bits = BITS()\n            setattr(bits, \"i%s\" % i, 1)\n            dump(bits)\n    def test_slots(self):\n        class BigPoint(BigEndianStructure):",
        "detail": "protobuf.Lib.ctypes.test.test_byteswap",
        "documentation": {}
    },
    {
        "label": "bin",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.test.test_byteswap",
        "description": "protobuf.Lib.ctypes.test.test_byteswap",
        "peekOfCode": "def bin(s):\n    return hexlify(memoryview(s)).decode().upper()\n# Each *simple* type that supports different byte orders has an\n# __ctype_be__ attribute that specifies the same type in BIG ENDIAN\n# byte order, and a __ctype_le__ attribute that is the same type in\n# LITTLE ENDIAN byte order.\n#\n# For Structures and Unions, these types are created on demand.\nclass Test(unittest.TestCase):\n    @unittest.skip('test disabled')",
        "detail": "protobuf.Lib.ctypes.test.test_byteswap",
        "documentation": {}
    },
    {
        "label": "Callbacks",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_callbacks",
        "description": "protobuf.Lib.ctypes.test.test_callbacks",
        "peekOfCode": "class Callbacks(unittest.TestCase):\n    functype = CFUNCTYPE\n##    def tearDown(self):\n##        import gc\n##        gc.collect()\n    def callback(self, *args):\n        self.got_args = args\n        return args[-1]\n    def check_type(self, typ, arg):\n        PROTO = self.functype.__func__(typ, typ)",
        "detail": "protobuf.Lib.ctypes.test.test_callbacks",
        "documentation": {}
    },
    {
        "label": "StdcallCallbacks",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_callbacks",
        "description": "protobuf.Lib.ctypes.test.test_callbacks",
        "peekOfCode": "class StdcallCallbacks(Callbacks):\n    try:\n        functype = WINFUNCTYPE\n    except NameError:\n        pass\n################################################################\nclass SampleCallbacksTestCase(unittest.TestCase):\n    def test_integrate(self):\n        # Derived from some then non-working code, posted by David Foster\n        dll = CDLL(_ctypes_test.__file__)",
        "detail": "protobuf.Lib.ctypes.test.test_callbacks",
        "documentation": {}
    },
    {
        "label": "SampleCallbacksTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_callbacks",
        "description": "protobuf.Lib.ctypes.test.test_callbacks",
        "peekOfCode": "class SampleCallbacksTestCase(unittest.TestCase):\n    def test_integrate(self):\n        # Derived from some then non-working code, posted by David Foster\n        dll = CDLL(_ctypes_test.__file__)\n        # The function prototype called by 'integrate': double func(double);\n        CALLBACK = CFUNCTYPE(c_double, c_double)\n        # The integrate function itself, exposed from the _ctypes_test dll\n        integrate = dll.integrate\n        integrate.argtypes = (c_double, c_double, CALLBACK, c_long)\n        integrate.restype = c_double",
        "detail": "protobuf.Lib.ctypes.test.test_callbacks",
        "documentation": {}
    },
    {
        "label": "Test",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_cast",
        "description": "protobuf.Lib.ctypes.test.test_cast",
        "peekOfCode": "class Test(unittest.TestCase):\n    def test_array2pointer(self):\n        array = (c_int * 3)(42, 17, 2)\n        # casting an array to a pointer works.\n        ptr = cast(array, POINTER(c_int))\n        self.assertEqual([ptr[i] for i in range(3)], [42, 17, 2])\n        if 2*sizeof(c_short) == sizeof(c_int):\n            ptr = cast(array, POINTER(c_short))\n            if sys.byteorder == \"little\":\n                self.assertEqual([ptr[i] for i in range(6)],",
        "detail": "protobuf.Lib.ctypes.test.test_cast",
        "documentation": {}
    },
    {
        "label": "CFunctions",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_cfuncs",
        "description": "protobuf.Lib.ctypes.test.test_cfuncs",
        "peekOfCode": "class CFunctions(unittest.TestCase):\n    _dll = CDLL(_ctypes_test.__file__)\n    def S(self):\n        return c_longlong.in_dll(self._dll, \"last_tf_arg_s\").value\n    def U(self):\n        return c_ulonglong.in_dll(self._dll, \"last_tf_arg_u\").value\n    def test_byte(self):\n        self._dll.tf_b.restype = c_byte\n        self._dll.tf_b.argtypes = (c_byte,)\n        self.assertEqual(self._dll.tf_b(-126), -42)",
        "detail": "protobuf.Lib.ctypes.test.test_cfuncs",
        "documentation": {}
    },
    {
        "label": "stdcallCFunctions",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_cfuncs",
        "description": "protobuf.Lib.ctypes.test.test_cfuncs",
        "peekOfCode": "class stdcallCFunctions(CFunctions):\n    _dll = stdcall_dll(_ctypes_test.__file__)\nif __name__ == '__main__':\n    unittest.main()",
        "detail": "protobuf.Lib.ctypes.test.test_cfuncs",
        "documentation": {}
    },
    {
        "label": "CHECKED",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_checkretval",
        "description": "protobuf.Lib.ctypes.test.test_checkretval",
        "peekOfCode": "class CHECKED(c_int):\n    def _check_retval_(value):\n        # Receives a CHECKED instance.\n        return str(value.value)\n    _check_retval_ = staticmethod(_check_retval_)\nclass Test(unittest.TestCase):\n    def test_checkretval(self):\n        import _ctypes_test\n        dll = CDLL(_ctypes_test.__file__)\n        self.assertEqual(42, dll._testfunc_p_p(42))",
        "detail": "protobuf.Lib.ctypes.test.test_checkretval",
        "documentation": {}
    },
    {
        "label": "Test",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_checkretval",
        "description": "protobuf.Lib.ctypes.test.test_checkretval",
        "peekOfCode": "class Test(unittest.TestCase):\n    def test_checkretval(self):\n        import _ctypes_test\n        dll = CDLL(_ctypes_test.__file__)\n        self.assertEqual(42, dll._testfunc_p_p(42))\n        dll._testfunc_p_p.restype = CHECKED\n        self.assertEqual(\"42\", dll._testfunc_p_p(42))\n        dll._testfunc_p_p.restype = None\n        self.assertEqual(None, dll._testfunc_p_p(42))\n        del dll._testfunc_p_p.restype",
        "detail": "protobuf.Lib.ctypes.test.test_checkretval",
        "documentation": {}
    },
    {
        "label": "X",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_delattr",
        "description": "protobuf.Lib.ctypes.test.test_delattr",
        "peekOfCode": "class X(Structure):\n    _fields_ = [(\"foo\", c_int)]\nclass TestCase(unittest.TestCase):\n    def test_simple(self):\n        self.assertRaises(TypeError,\n                          delattr, c_int(42), \"value\")\n    def test_chararray(self):\n        self.assertRaises(TypeError,\n                          delattr, (c_char * 5)(), \"value\")\n    def test_struct(self):",
        "detail": "protobuf.Lib.ctypes.test.test_delattr",
        "documentation": {}
    },
    {
        "label": "TestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_delattr",
        "description": "protobuf.Lib.ctypes.test.test_delattr",
        "peekOfCode": "class TestCase(unittest.TestCase):\n    def test_simple(self):\n        self.assertRaises(TypeError,\n                          delattr, c_int(42), \"value\")\n    def test_chararray(self):\n        self.assertRaises(TypeError,\n                          delattr, (c_char * 5)(), \"value\")\n    def test_struct(self):\n        self.assertRaises(TypeError,\n                          delattr, X(), \"foo\")",
        "detail": "protobuf.Lib.ctypes.test.test_delattr",
        "documentation": {}
    },
    {
        "label": "Test",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_errno",
        "description": "protobuf.Lib.ctypes.test.test_errno",
        "peekOfCode": "class Test(unittest.TestCase):\n    def test_open(self):\n        libc_name = find_library(\"c\")\n        if libc_name is None:\n            raise unittest.SkipTest(\"Unable to find C library\")\n        libc = CDLL(libc_name, use_errno=True)\n        if os.name == \"nt\":\n            libc_open = libc._open\n        else:\n            libc_open = libc.open",
        "detail": "protobuf.Lib.ctypes.test.test_errno",
        "documentation": {}
    },
    {
        "label": "Test_OpenGL_libs",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_find",
        "description": "protobuf.Lib.ctypes.test.test_find",
        "peekOfCode": "class Test_OpenGL_libs(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        lib_gl = lib_glu = lib_gle = None\n        if sys.platform == \"win32\":\n            lib_gl = find_library(\"OpenGL32\")\n            lib_glu = find_library(\"Glu32\")\n        elif sys.platform == \"darwin\":\n            lib_gl = lib_glu = find_library(\"OpenGL\")\n        else:",
        "detail": "protobuf.Lib.ctypes.test.test_find",
        "documentation": {}
    },
    {
        "label": "FindLibraryLinux",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_find",
        "description": "protobuf.Lib.ctypes.test.test_find",
        "peekOfCode": "class FindLibraryLinux(unittest.TestCase):\n    def test_find_on_libpath(self):\n        import subprocess\n        import tempfile\n        try:\n            p = subprocess.Popen(['gcc', '--version'], stdout=subprocess.PIPE,\n                                 stderr=subprocess.DEVNULL)\n            out, _ = p.communicate()\n        except OSError:\n            raise unittest.SkipTest('gcc, needed for test, not available')",
        "detail": "protobuf.Lib.ctypes.test.test_find",
        "documentation": {}
    },
    {
        "label": "X",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_frombuffer",
        "description": "protobuf.Lib.ctypes.test.test_frombuffer",
        "peekOfCode": "class X(Structure):\n    _fields_ = [(\"c_int\", c_int)]\n    init_called = False\n    def __init__(self):\n        self._init_called = True\nclass Test(unittest.TestCase):\n    def test_from_buffer(self):\n        a = array.array(\"i\", range(16))\n        x = (c_int * 16).from_buffer(a)\n        y = X.from_buffer(a)",
        "detail": "protobuf.Lib.ctypes.test.test_frombuffer",
        "documentation": {}
    },
    {
        "label": "Test",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_frombuffer",
        "description": "protobuf.Lib.ctypes.test.test_frombuffer",
        "peekOfCode": "class Test(unittest.TestCase):\n    def test_from_buffer(self):\n        a = array.array(\"i\", range(16))\n        x = (c_int * 16).from_buffer(a)\n        y = X.from_buffer(a)\n        self.assertEqual(y.c_int, a[0])\n        self.assertFalse(y.init_called)\n        self.assertEqual(x[:], a.tolist())\n        a[0], a[-1] = 200, -200\n        self.assertEqual(x[:], a.tolist())",
        "detail": "protobuf.Lib.ctypes.test.test_frombuffer",
        "documentation": {}
    },
    {
        "label": "CFuncPtrTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_funcptr",
        "description": "protobuf.Lib.ctypes.test.test_funcptr",
        "peekOfCode": "class CFuncPtrTestCase(unittest.TestCase):\n    def test_basic(self):\n        X = WINFUNCTYPE(c_int, c_int, c_int)\n        def func(*args):\n            return len(args)\n        x = X(func)\n        self.assertEqual(x.restype, c_int)\n        self.assertEqual(x.argtypes, (c_int, c_int))\n        self.assertEqual(sizeof(x), sizeof(c_voidp))\n        self.assertEqual(sizeof(X), sizeof(c_voidp))",
        "detail": "protobuf.Lib.ctypes.test.test_funcptr",
        "documentation": {}
    },
    {
        "label": "lib",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_funcptr",
        "description": "protobuf.Lib.ctypes.test.test_funcptr",
        "peekOfCode": "lib = CDLL(_ctypes_test.__file__)\nclass CFuncPtrTestCase(unittest.TestCase):\n    def test_basic(self):\n        X = WINFUNCTYPE(c_int, c_int, c_int)\n        def func(*args):\n            return len(args)\n        x = X(func)\n        self.assertEqual(x.restype, c_int)\n        self.assertEqual(x.argtypes, (c_int, c_int))\n        self.assertEqual(sizeof(x), sizeof(c_voidp))",
        "detail": "protobuf.Lib.ctypes.test.test_funcptr",
        "documentation": {}
    },
    {
        "label": "POINT",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_functions",
        "description": "protobuf.Lib.ctypes.test.test_functions",
        "peekOfCode": "class POINT(Structure):\n    _fields_ = [(\"x\", c_int), (\"y\", c_int)]\nclass RECT(Structure):\n    _fields_ = [(\"left\", c_int), (\"top\", c_int),\n                (\"right\", c_int), (\"bottom\", c_int)]\nclass FunctionTestCase(unittest.TestCase):\n    def test_mro(self):\n        # in Python 2.3, this raises TypeError: MRO conflict among bases classes,\n        # in Python 2.2 it works.\n        #",
        "detail": "protobuf.Lib.ctypes.test.test_functions",
        "documentation": {}
    },
    {
        "label": "RECT",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_functions",
        "description": "protobuf.Lib.ctypes.test.test_functions",
        "peekOfCode": "class RECT(Structure):\n    _fields_ = [(\"left\", c_int), (\"top\", c_int),\n                (\"right\", c_int), (\"bottom\", c_int)]\nclass FunctionTestCase(unittest.TestCase):\n    def test_mro(self):\n        # in Python 2.3, this raises TypeError: MRO conflict among bases classes,\n        # in Python 2.2 it works.\n        #\n        # But in early versions of _ctypes.c, the result of tp_new\n        # wasn't checked, and it even crashed Python.",
        "detail": "protobuf.Lib.ctypes.test.test_functions",
        "documentation": {}
    },
    {
        "label": "FunctionTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_functions",
        "description": "protobuf.Lib.ctypes.test.test_functions",
        "peekOfCode": "class FunctionTestCase(unittest.TestCase):\n    def test_mro(self):\n        # in Python 2.3, this raises TypeError: MRO conflict among bases classes,\n        # in Python 2.2 it works.\n        #\n        # But in early versions of _ctypes.c, the result of tp_new\n        # wasn't checked, and it even crashed Python.\n        # Found by Greg Chapman.\n        with self.assertRaises(TypeError):\n            class X(object, Array):",
        "detail": "protobuf.Lib.ctypes.test.test_functions",
        "documentation": {}
    },
    {
        "label": "dll",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_functions",
        "description": "protobuf.Lib.ctypes.test.test_functions",
        "peekOfCode": "dll = CDLL(_ctypes_test.__file__)\nif sys.platform == \"win32\":\n    windll = WinDLL(_ctypes_test.__file__)\nclass POINT(Structure):\n    _fields_ = [(\"x\", c_int), (\"y\", c_int)]\nclass RECT(Structure):\n    _fields_ = [(\"left\", c_int), (\"top\", c_int),\n                (\"right\", c_int), (\"bottom\", c_int)]\nclass FunctionTestCase(unittest.TestCase):\n    def test_mro(self):",
        "detail": "protobuf.Lib.ctypes.test.test_functions",
        "documentation": {}
    },
    {
        "label": "MyTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_incomplete",
        "description": "protobuf.Lib.ctypes.test.test_incomplete",
        "peekOfCode": "class MyTestCase(unittest.TestCase):\n    def test_incomplete_example(self):\n        lpcell = POINTER(\"cell\")\n        class cell(Structure):\n            _fields_ = [(\"name\", c_char_p),\n                        (\"next\", lpcell)]\n        SetPointerType(lpcell, cell)\n        c1 = cell()\n        c1.name = b\"foo\"\n        c2 = cell()",
        "detail": "protobuf.Lib.ctypes.test.test_incomplete",
        "documentation": {}
    },
    {
        "label": "X",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_init",
        "description": "protobuf.Lib.ctypes.test.test_init",
        "peekOfCode": "class X(Structure):\n    _fields_ = [(\"a\", c_int),\n                (\"b\", c_int)]\n    new_was_called = False\n    def __new__(cls):\n        result = super().__new__(cls)\n        result.new_was_called = True\n        return result\n    def __init__(self):\n        self.a = 9",
        "detail": "protobuf.Lib.ctypes.test.test_init",
        "documentation": {}
    },
    {
        "label": "Y",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_init",
        "description": "protobuf.Lib.ctypes.test.test_init",
        "peekOfCode": "class Y(Structure):\n    _fields_ = [(\"x\", X)]\nclass InitTest(unittest.TestCase):\n    def test_get(self):\n        # make sure the only accessing a nested structure\n        # doesn't call the structure's __new__ and __init__\n        y = Y()\n        self.assertEqual((y.x.a, y.x.b), (0, 0))\n        self.assertEqual(y.x.new_was_called, False)\n        # But explicitly creating an X structure calls __new__ and __init__, of course.",
        "detail": "protobuf.Lib.ctypes.test.test_init",
        "documentation": {}
    },
    {
        "label": "InitTest",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_init",
        "description": "protobuf.Lib.ctypes.test.test_init",
        "peekOfCode": "class InitTest(unittest.TestCase):\n    def test_get(self):\n        # make sure the only accessing a nested structure\n        # doesn't call the structure's __new__ and __init__\n        y = Y()\n        self.assertEqual((y.x.a, y.x.b), (0, 0))\n        self.assertEqual(y.x.new_was_called, False)\n        # But explicitly creating an X structure calls __new__ and __init__, of course.\n        x = X()\n        self.assertEqual((x.a, x.b), (9, 12))",
        "detail": "protobuf.Lib.ctypes.test.test_init",
        "documentation": {}
    },
    {
        "label": "ObjectsTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_internals",
        "description": "protobuf.Lib.ctypes.test.test_internals",
        "peekOfCode": "class ObjectsTestCase(unittest.TestCase):\n    def assertSame(self, a, b):\n        self.assertEqual(id(a), id(b))\n    def test_ints(self):\n        i = 42000123\n        refcnt = grc(i)\n        ci = c_int(i)\n        self.assertEqual(refcnt, grc(i))\n        self.assertEqual(ci._objects, None)\n    def test_c_char_p(self):",
        "detail": "protobuf.Lib.ctypes.test.test_internals",
        "documentation": {}
    },
    {
        "label": "SimpleTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_keeprefs",
        "description": "protobuf.Lib.ctypes.test.test_keeprefs",
        "peekOfCode": "class SimpleTestCase(unittest.TestCase):\n    def test_cint(self):\n        x = c_int()\n        self.assertEqual(x._objects, None)\n        x.value = 42\n        self.assertEqual(x._objects, None)\n        x = c_int(99)\n        self.assertEqual(x._objects, None)\n    def test_ccharp(self):\n        x = c_char_p()",
        "detail": "protobuf.Lib.ctypes.test.test_keeprefs",
        "documentation": {}
    },
    {
        "label": "StructureTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_keeprefs",
        "description": "protobuf.Lib.ctypes.test.test_keeprefs",
        "peekOfCode": "class StructureTestCase(unittest.TestCase):\n    def test_cint_struct(self):\n        class X(Structure):\n            _fields_ = [(\"a\", c_int),\n                        (\"b\", c_int)]\n        x = X()\n        self.assertEqual(x._objects, None)\n        x.a = 42\n        x.b = 99\n        self.assertEqual(x._objects, None)",
        "detail": "protobuf.Lib.ctypes.test.test_keeprefs",
        "documentation": {}
    },
    {
        "label": "ArrayTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_keeprefs",
        "description": "protobuf.Lib.ctypes.test.test_keeprefs",
        "peekOfCode": "class ArrayTestCase(unittest.TestCase):\n    def test_cint_array(self):\n        INTARR = c_int * 3\n        ia = INTARR()\n        self.assertEqual(ia._objects, None)\n        ia[0] = 1\n        ia[1] = 2\n        ia[2] = 3\n        self.assertEqual(ia._objects, None)\n        class X(Structure):",
        "detail": "protobuf.Lib.ctypes.test.test_keeprefs",
        "documentation": {}
    },
    {
        "label": "PointerTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_keeprefs",
        "description": "protobuf.Lib.ctypes.test.test_keeprefs",
        "peekOfCode": "class PointerTestCase(unittest.TestCase):\n    def test_p_cint(self):\n        i = c_int(42)\n        x = pointer(i)\n        self.assertEqual(x._objects, {'1': i})\nclass DeletePointerTestCase(unittest.TestCase):\n    @unittest.skip('test disabled')\n    def test_X(self):\n        class X(Structure):\n            _fields_ = [(\"p\", POINTER(c_char_p))]",
        "detail": "protobuf.Lib.ctypes.test.test_keeprefs",
        "documentation": {}
    },
    {
        "label": "DeletePointerTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_keeprefs",
        "description": "protobuf.Lib.ctypes.test.test_keeprefs",
        "peekOfCode": "class DeletePointerTestCase(unittest.TestCase):\n    @unittest.skip('test disabled')\n    def test_X(self):\n        class X(Structure):\n            _fields_ = [(\"p\", POINTER(c_char_p))]\n        x = X()\n        i = c_char_p(\"abc def\")\n        from sys import getrefcount as grc\n        print(\"2?\", grc(i))\n        x.p = pointer(i)",
        "detail": "protobuf.Lib.ctypes.test.test_keeprefs",
        "documentation": {}
    },
    {
        "label": "PointerToStructure",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_keeprefs",
        "description": "protobuf.Lib.ctypes.test.test_keeprefs",
        "peekOfCode": "class PointerToStructure(unittest.TestCase):\n    def test(self):\n        class POINT(Structure):\n            _fields_ = [(\"x\", c_int), (\"y\", c_int)]\n        class RECT(Structure):\n            _fields_ = [(\"a\", POINTER(POINT)),\n                        (\"b\", POINTER(POINT))]\n        r = RECT()\n        p1 = POINT(1, 2)\n        r.a = pointer(p1)",
        "detail": "protobuf.Lib.ctypes.test.test_keeprefs",
        "documentation": {}
    },
    {
        "label": "LibTest",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_libc",
        "description": "protobuf.Lib.ctypes.test.test_libc",
        "peekOfCode": "class LibTest(unittest.TestCase):\n    def test_sqrt(self):\n        lib.my_sqrt.argtypes = c_double,\n        lib.my_sqrt.restype = c_double\n        self.assertEqual(lib.my_sqrt(4.0), 2.0)\n        import math\n        self.assertEqual(lib.my_sqrt(2.0), math.sqrt(2.0))\n    def test_qsort(self):\n        comparefunc = CFUNCTYPE(c_int, POINTER(c_char), POINTER(c_char))\n        lib.my_qsort.argtypes = c_void_p, c_size_t, c_size_t, comparefunc",
        "detail": "protobuf.Lib.ctypes.test.test_libc",
        "documentation": {}
    },
    {
        "label": "three_way_cmp",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.test.test_libc",
        "description": "protobuf.Lib.ctypes.test.test_libc",
        "peekOfCode": "def three_way_cmp(x, y):\n    \"\"\"Return -1 if x < y, 0 if x == y and 1 if x > y\"\"\"\n    return (x > y) - (x < y)\nclass LibTest(unittest.TestCase):\n    def test_sqrt(self):\n        lib.my_sqrt.argtypes = c_double,\n        lib.my_sqrt.restype = c_double\n        self.assertEqual(lib.my_sqrt(4.0), 2.0)\n        import math\n        self.assertEqual(lib.my_sqrt(2.0), math.sqrt(2.0))",
        "detail": "protobuf.Lib.ctypes.test.test_libc",
        "documentation": {}
    },
    {
        "label": "lib",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_libc",
        "description": "protobuf.Lib.ctypes.test.test_libc",
        "peekOfCode": "lib = CDLL(_ctypes_test.__file__)\ndef three_way_cmp(x, y):\n    \"\"\"Return -1 if x < y, 0 if x == y and 1 if x > y\"\"\"\n    return (x > y) - (x < y)\nclass LibTest(unittest.TestCase):\n    def test_sqrt(self):\n        lib.my_sqrt.argtypes = c_double,\n        lib.my_sqrt.restype = c_double\n        self.assertEqual(lib.my_sqrt(4.0), 2.0)\n        import math",
        "detail": "protobuf.Lib.ctypes.test.test_libc",
        "documentation": {}
    },
    {
        "label": "LoaderTest",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_loading",
        "description": "protobuf.Lib.ctypes.test.test_loading",
        "peekOfCode": "class LoaderTest(unittest.TestCase):\n    unknowndll = \"xxrandomnamexx\"\n    def test_load(self):\n        if libc_name is None:\n            self.skipTest('could not find libc')\n        CDLL(libc_name)\n        CDLL(os.path.basename(libc_name))\n        self.assertRaises(OSError, CDLL, self.unknowndll)\n    def test_load_version(self):\n        if libc_name is None:",
        "detail": "protobuf.Lib.ctypes.test.test_loading",
        "documentation": {}
    },
    {
        "label": "setUpModule",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.test.test_loading",
        "description": "protobuf.Lib.ctypes.test.test_loading",
        "peekOfCode": "def setUpModule():\n    global libc_name\n    if os.name == \"nt\":\n        libc_name = find_library(\"c\")\n    elif sys.platform == \"cygwin\":\n        libc_name = \"cygwin1.dll\"\n    else:\n        libc_name = find_library(\"c\")\n    if test.support.verbose:\n        print(\"libc_name is\", libc_name)",
        "detail": "protobuf.Lib.ctypes.test.test_loading",
        "documentation": {}
    },
    {
        "label": "libc_name",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_loading",
        "description": "protobuf.Lib.ctypes.test.test_loading",
        "peekOfCode": "libc_name = None\ndef setUpModule():\n    global libc_name\n    if os.name == \"nt\":\n        libc_name = find_library(\"c\")\n    elif sys.platform == \"cygwin\":\n        libc_name = \"cygwin1.dll\"\n    else:\n        libc_name = find_library(\"c\")\n    if test.support.verbose:",
        "detail": "protobuf.Lib.ctypes.test.test_loading",
        "documentation": {}
    },
    {
        "label": "MachOTest",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_macholib",
        "description": "protobuf.Lib.ctypes.test.test_macholib",
        "peekOfCode": "class MachOTest(unittest.TestCase):\n    @unittest.skipUnless(sys.platform == \"darwin\", 'OSX-specific test')\n    def test_find(self):\n        # On Mac OS 11, system dylibs are only present in the shared cache,\n        # so symlinks like libpthread.dylib -> libSystem.B.dylib will not\n        # be resolved by dyld_find\n        self.assertIn(find_lib('pthread'),\n                              ('/usr/lib/libSystem.B.dylib', '/usr/lib/libpthread.dylib'))\n        result = find_lib('z')\n        # Issue #21093: dyld default search path includes $HOME/lib and",
        "detail": "protobuf.Lib.ctypes.test.test_macholib",
        "documentation": {}
    },
    {
        "label": "find_lib",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.test.test_macholib",
        "description": "protobuf.Lib.ctypes.test.test_macholib",
        "peekOfCode": "def find_lib(name):\n    possible = ['lib'+name+'.dylib', name+'.dylib', name+'.framework/'+name]\n    for dylib in possible:\n        try:\n            return os.path.realpath(dyld_find(dylib))\n        except ValueError:\n            pass\n    raise ValueError(\"%s not found\" % (name,))\nclass MachOTest(unittest.TestCase):\n    @unittest.skipUnless(sys.platform == \"darwin\", 'OSX-specific test')",
        "detail": "protobuf.Lib.ctypes.test.test_macholib",
        "documentation": {}
    },
    {
        "label": "MemFunctionsTest",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_memfunctions",
        "description": "protobuf.Lib.ctypes.test.test_memfunctions",
        "peekOfCode": "class MemFunctionsTest(unittest.TestCase):\n    @unittest.skip('test disabled')\n    def test_overflow(self):\n        # string_at and wstring_at must use the Python calling\n        # convention (which acquires the GIL and checks the Python\n        # error flag).  Provoke an error and catch it; see also issue\n        # #3554: <http://bugs.python.org/issue3554>\n        self.assertRaises((OverflowError, MemoryError, SystemError),\n                          lambda: wstring_at(u\"foo\", sys.maxint - 1))\n        self.assertRaises((OverflowError, MemoryError, SystemError),",
        "detail": "protobuf.Lib.ctypes.test.test_memfunctions",
        "documentation": {}
    },
    {
        "label": "NumberTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_numbers",
        "description": "protobuf.Lib.ctypes.test.test_numbers",
        "peekOfCode": "class NumberTestCase(unittest.TestCase):\n    def test_default_init(self):\n        # default values are set to zero\n        for t in signed_types + unsigned_types + float_types:\n            self.assertEqual(t().value, 0)\n    def test_unsigned_values(self):\n        # the value given to the constructor is available\n        # as the 'value' attribute\n        for t, (l, h) in zip(unsigned_types, unsigned_ranges):\n            self.assertEqual(t(l).value, l)",
        "detail": "protobuf.Lib.ctypes.test.test_numbers",
        "documentation": {}
    },
    {
        "label": "c_int_S",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_numbers",
        "description": "protobuf.Lib.ctypes.test.test_numbers",
        "peekOfCode": "class c_int_S(_SimpleCData):\n    _type_ = \"i\"\n    __slots__ = []\ndef run_test(rep, msg, func, arg=None):\n##    items = [None] * rep\n    items = range(rep)\n    from time import perf_counter as clock\n    if arg is not None:\n        start = clock()\n        for i in items:",
        "detail": "protobuf.Lib.ctypes.test.test_numbers",
        "documentation": {}
    },
    {
        "label": "valid_ranges",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.test.test_numbers",
        "description": "protobuf.Lib.ctypes.test.test_numbers",
        "peekOfCode": "def valid_ranges(*types):\n    # given a sequence of numeric types, collect their _type_\n    # attribute, which is a single format character compatible with\n    # the struct module, use the struct module to calculate the\n    # minimum and maximum value allowed for this format.\n    # Returns a list of (min, max) values.\n    result = []\n    for t in types:\n        fmt = t._type_\n        size = struct.calcsize(fmt)",
        "detail": "protobuf.Lib.ctypes.test.test_numbers",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.test.test_numbers",
        "description": "protobuf.Lib.ctypes.test.test_numbers",
        "peekOfCode": "def run_test(rep, msg, func, arg=None):\n##    items = [None] * rep\n    items = range(rep)\n    from time import perf_counter as clock\n    if arg is not None:\n        start = clock()\n        for i in items:\n            func(arg); func(arg); func(arg); func(arg); func(arg)\n        stop = clock()\n    else:",
        "detail": "protobuf.Lib.ctypes.test.test_numbers",
        "documentation": {}
    },
    {
        "label": "check_perf",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.test.test_numbers",
        "description": "protobuf.Lib.ctypes.test.test_numbers",
        "peekOfCode": "def check_perf():\n    # Construct 5 objects\n    from ctypes import c_int\n    REP = 200000\n    run_test(REP, \"int()\", int)\n    run_test(REP, \"int(999)\", int)\n    run_test(REP, \"c_int()\", c_int)\n    run_test(REP, \"c_int(999)\", c_int)\n    run_test(REP, \"c_int_S()\", c_int_S)\n    run_test(REP, \"c_int_S(999)\", c_int_S)",
        "detail": "protobuf.Lib.ctypes.test.test_numbers",
        "documentation": {}
    },
    {
        "label": "ArgType",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_numbers",
        "description": "protobuf.Lib.ctypes.test.test_numbers",
        "peekOfCode": "ArgType = type(byref(c_int(0)))\nunsigned_types = [c_ubyte, c_ushort, c_uint, c_ulong]\nsigned_types = [c_byte, c_short, c_int, c_long, c_longlong]\nbool_types = []\nfloat_types = [c_double, c_float]\ntry:\n    c_ulonglong\n    c_longlong\nexcept NameError:\n    pass",
        "detail": "protobuf.Lib.ctypes.test.test_numbers",
        "documentation": {}
    },
    {
        "label": "unsigned_types",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_numbers",
        "description": "protobuf.Lib.ctypes.test.test_numbers",
        "peekOfCode": "unsigned_types = [c_ubyte, c_ushort, c_uint, c_ulong]\nsigned_types = [c_byte, c_short, c_int, c_long, c_longlong]\nbool_types = []\nfloat_types = [c_double, c_float]\ntry:\n    c_ulonglong\n    c_longlong\nexcept NameError:\n    pass\nelse:",
        "detail": "protobuf.Lib.ctypes.test.test_numbers",
        "documentation": {}
    },
    {
        "label": "signed_types",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_numbers",
        "description": "protobuf.Lib.ctypes.test.test_numbers",
        "peekOfCode": "signed_types = [c_byte, c_short, c_int, c_long, c_longlong]\nbool_types = []\nfloat_types = [c_double, c_float]\ntry:\n    c_ulonglong\n    c_longlong\nexcept NameError:\n    pass\nelse:\n    unsigned_types.append(c_ulonglong)",
        "detail": "protobuf.Lib.ctypes.test.test_numbers",
        "documentation": {}
    },
    {
        "label": "bool_types",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_numbers",
        "description": "protobuf.Lib.ctypes.test.test_numbers",
        "peekOfCode": "bool_types = []\nfloat_types = [c_double, c_float]\ntry:\n    c_ulonglong\n    c_longlong\nexcept NameError:\n    pass\nelse:\n    unsigned_types.append(c_ulonglong)\n    signed_types.append(c_longlong)",
        "detail": "protobuf.Lib.ctypes.test.test_numbers",
        "documentation": {}
    },
    {
        "label": "float_types",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_numbers",
        "description": "protobuf.Lib.ctypes.test.test_numbers",
        "peekOfCode": "float_types = [c_double, c_float]\ntry:\n    c_ulonglong\n    c_longlong\nexcept NameError:\n    pass\nelse:\n    unsigned_types.append(c_ulonglong)\n    signed_types.append(c_longlong)\ntry:",
        "detail": "protobuf.Lib.ctypes.test.test_numbers",
        "documentation": {}
    },
    {
        "label": "unsigned_ranges",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_numbers",
        "description": "protobuf.Lib.ctypes.test.test_numbers",
        "peekOfCode": "unsigned_ranges = valid_ranges(*unsigned_types)\nsigned_ranges = valid_ranges(*signed_types)\nbool_values = [True, False, 0, 1, -1, 5000, 'test', [], [1]]\n################################################################\nclass NumberTestCase(unittest.TestCase):\n    def test_default_init(self):\n        # default values are set to zero\n        for t in signed_types + unsigned_types + float_types:\n            self.assertEqual(t().value, 0)\n    def test_unsigned_values(self):",
        "detail": "protobuf.Lib.ctypes.test.test_numbers",
        "documentation": {}
    },
    {
        "label": "signed_ranges",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_numbers",
        "description": "protobuf.Lib.ctypes.test.test_numbers",
        "peekOfCode": "signed_ranges = valid_ranges(*signed_types)\nbool_values = [True, False, 0, 1, -1, 5000, 'test', [], [1]]\n################################################################\nclass NumberTestCase(unittest.TestCase):\n    def test_default_init(self):\n        # default values are set to zero\n        for t in signed_types + unsigned_types + float_types:\n            self.assertEqual(t().value, 0)\n    def test_unsigned_values(self):\n        # the value given to the constructor is available",
        "detail": "protobuf.Lib.ctypes.test.test_numbers",
        "documentation": {}
    },
    {
        "label": "bool_values",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_numbers",
        "description": "protobuf.Lib.ctypes.test.test_numbers",
        "peekOfCode": "bool_values = [True, False, 0, 1, -1, 5000, 'test', [], [1]]\n################################################################\nclass NumberTestCase(unittest.TestCase):\n    def test_default_init(self):\n        # default values are set to zero\n        for t in signed_types + unsigned_types + float_types:\n            self.assertEqual(t().value, 0)\n    def test_unsigned_values(self):\n        # the value given to the constructor is available\n        # as the 'value' attribute",
        "detail": "protobuf.Lib.ctypes.test.test_numbers",
        "documentation": {}
    },
    {
        "label": "TestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_objects",
        "description": "protobuf.Lib.ctypes.test.test_objects",
        "peekOfCode": "class TestCase(unittest.TestCase):\n    def test(self):\n        failures, tests = doctest.testmod(ctypes.test.test_objects)\n        self.assertFalse(failures, 'doctests failed, see output above')\nif __name__ == '__main__':\n    doctest.testmod(ctypes.test.test_objects)",
        "detail": "protobuf.Lib.ctypes.test.test_objects",
        "documentation": {}
    },
    {
        "label": "SimpleTypesTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_parameters",
        "description": "protobuf.Lib.ctypes.test.test_parameters",
        "peekOfCode": "class SimpleTypesTestCase(unittest.TestCase):\n    def setUp(self):\n        import ctypes\n        try:\n            from _ctypes import set_conversion_mode\n        except ImportError:\n            pass\n        else:\n            self.prev_conv_mode = set_conversion_mode(\"ascii\", \"strict\")\n    def tearDown(self):",
        "detail": "protobuf.Lib.ctypes.test.test_parameters",
        "documentation": {}
    },
    {
        "label": "Test",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "class Test(unittest.TestCase):\n    def test_native_types(self):\n        for tp, fmt, shape, itemtp in native_types:\n            ob = tp()\n            v = memoryview(ob)\n            try:\n                self.assertEqual(normalize(v.format), normalize(fmt))\n                if shape:\n                    self.assertEqual(len(v), shape[0])\n                else:",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "Point",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "class Point(Structure):\n    _fields_ = [(\"x\", c_long), (\"y\", c_long)]\nclass PackedPoint(Structure):\n    _pack_ = 2\n    _fields_ = [(\"x\", c_long), (\"y\", c_long)]\nclass Point2(Structure):\n    pass\nPoint2._fields_ = [(\"x\", c_long), (\"y\", c_long)]\nclass EmptyStruct(Structure):\n    _fields_ = []",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "PackedPoint",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "class PackedPoint(Structure):\n    _pack_ = 2\n    _fields_ = [(\"x\", c_long), (\"y\", c_long)]\nclass Point2(Structure):\n    pass\nPoint2._fields_ = [(\"x\", c_long), (\"y\", c_long)]\nclass EmptyStruct(Structure):\n    _fields_ = []\nclass aUnion(Union):\n    _fields_ = [(\"a\", c_int)]",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "Point2",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "class Point2(Structure):\n    pass\nPoint2._fields_ = [(\"x\", c_long), (\"y\", c_long)]\nclass EmptyStruct(Structure):\n    _fields_ = []\nclass aUnion(Union):\n    _fields_ = [(\"a\", c_int)]\nclass StructWithArrays(Structure):\n    _fields_ = [(\"x\", c_long * 3 * 2), (\"y\", Point * 4)]\nclass Incomplete(Structure):",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "EmptyStruct",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "class EmptyStruct(Structure):\n    _fields_ = []\nclass aUnion(Union):\n    _fields_ = [(\"a\", c_int)]\nclass StructWithArrays(Structure):\n    _fields_ = [(\"x\", c_long * 3 * 2), (\"y\", Point * 4)]\nclass Incomplete(Structure):\n    pass\nclass Complete(Structure):\n    pass",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "aUnion",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "class aUnion(Union):\n    _fields_ = [(\"a\", c_int)]\nclass StructWithArrays(Structure):\n    _fields_ = [(\"x\", c_long * 3 * 2), (\"y\", Point * 4)]\nclass Incomplete(Structure):\n    pass\nclass Complete(Structure):\n    pass\nPComplete = POINTER(Complete)\nComplete._fields_ = [(\"a\", c_long)]",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "StructWithArrays",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "class StructWithArrays(Structure):\n    _fields_ = [(\"x\", c_long * 3 * 2), (\"y\", Point * 4)]\nclass Incomplete(Structure):\n    pass\nclass Complete(Structure):\n    pass\nPComplete = POINTER(Complete)\nComplete._fields_ = [(\"a\", c_long)]\n################################################################\n#",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "Incomplete",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "class Incomplete(Structure):\n    pass\nclass Complete(Structure):\n    pass\nPComplete = POINTER(Complete)\nComplete._fields_ = [(\"a\", c_long)]\n################################################################\n#\n# This table contains format strings as they look on little endian\n# machines.  The test replaces '<' with '>' on big endian machines.",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "Complete",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "class Complete(Structure):\n    pass\nPComplete = POINTER(Complete)\nComplete._fields_ = [(\"a\", c_long)]\n################################################################\n#\n# This table contains format strings as they look on little endian\n# machines.  The test replaces '<' with '>' on big endian machines.\n#\n# Platform-specific type codes",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "BEPoint",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "class BEPoint(BigEndianStructure):\n    _fields_ = [(\"x\", c_long), (\"y\", c_long)]\nclass LEPoint(LittleEndianStructure):\n    _fields_ = [(\"x\", c_long), (\"y\", c_long)]\n################################################################\n#\n# This table contains format strings as they really look, on both big\n# and little endian machines.\n#\nendian_types = [",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "LEPoint",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "class LEPoint(LittleEndianStructure):\n    _fields_ = [(\"x\", c_long), (\"y\", c_long)]\n################################################################\n#\n# This table contains format strings as they really look, on both big\n# and little endian machines.\n#\nendian_types = [\n    (BEPoint, \"T{>l:x:>l:y:}\".replace('l', s_long), (), BEPoint),\n    (LEPoint, \"T{<l:x:<l:y:}\".replace('l', s_long), (), LEPoint),",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "normalize",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "def normalize(format):\n    # Remove current endian specifier and white space from a format\n    # string\n    if format is None:\n        return \"\"\n    format = format.replace(OTHER_ENDIAN, THIS_ENDIAN)\n    return re.sub(r\"\\s\", \"\", format)\nclass Test(unittest.TestCase):\n    def test_native_types(self):\n        for tp, fmt, shape, itemtp in native_types:",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "Point2._fields_",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "Point2._fields_ = [(\"x\", c_long), (\"y\", c_long)]\nclass EmptyStruct(Structure):\n    _fields_ = []\nclass aUnion(Union):\n    _fields_ = [(\"a\", c_int)]\nclass StructWithArrays(Structure):\n    _fields_ = [(\"x\", c_long * 3 * 2), (\"y\", Point * 4)]\nclass Incomplete(Structure):\n    pass\nclass Complete(Structure):",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "PComplete",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "PComplete = POINTER(Complete)\nComplete._fields_ = [(\"a\", c_long)]\n################################################################\n#\n# This table contains format strings as they look on little endian\n# machines.  The test replaces '<' with '>' on big endian machines.\n#\n# Platform-specific type codes\ns_bool = {1: '?', 2: 'H', 4: 'L', 8: 'Q'}[sizeof(c_bool)]\ns_short = {2: 'h', 4: 'l', 8: 'q'}[sizeof(c_short)]",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "Complete._fields_",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "Complete._fields_ = [(\"a\", c_long)]\n################################################################\n#\n# This table contains format strings as they look on little endian\n# machines.  The test replaces '<' with '>' on big endian machines.\n#\n# Platform-specific type codes\ns_bool = {1: '?', 2: 'H', 4: 'L', 8: 'Q'}[sizeof(c_bool)]\ns_short = {2: 'h', 4: 'l', 8: 'q'}[sizeof(c_short)]\ns_ushort = {2: 'H', 4: 'L', 8: 'Q'}[sizeof(c_ushort)]",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "s_bool",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "s_bool = {1: '?', 2: 'H', 4: 'L', 8: 'Q'}[sizeof(c_bool)]\ns_short = {2: 'h', 4: 'l', 8: 'q'}[sizeof(c_short)]\ns_ushort = {2: 'H', 4: 'L', 8: 'Q'}[sizeof(c_ushort)]\ns_int = {2: 'h', 4: 'i', 8: 'q'}[sizeof(c_int)]\ns_uint = {2: 'H', 4: 'I', 8: 'Q'}[sizeof(c_uint)]\ns_long = {4: 'l', 8: 'q'}[sizeof(c_long)]\ns_ulong = {4: 'L', 8: 'Q'}[sizeof(c_ulong)]\ns_longlong = \"q\"\ns_ulonglong = \"Q\"\ns_float = \"f\"",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "s_short",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "s_short = {2: 'h', 4: 'l', 8: 'q'}[sizeof(c_short)]\ns_ushort = {2: 'H', 4: 'L', 8: 'Q'}[sizeof(c_ushort)]\ns_int = {2: 'h', 4: 'i', 8: 'q'}[sizeof(c_int)]\ns_uint = {2: 'H', 4: 'I', 8: 'Q'}[sizeof(c_uint)]\ns_long = {4: 'l', 8: 'q'}[sizeof(c_long)]\ns_ulong = {4: 'L', 8: 'Q'}[sizeof(c_ulong)]\ns_longlong = \"q\"\ns_ulonglong = \"Q\"\ns_float = \"f\"\ns_double = \"d\"",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "s_ushort",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "s_ushort = {2: 'H', 4: 'L', 8: 'Q'}[sizeof(c_ushort)]\ns_int = {2: 'h', 4: 'i', 8: 'q'}[sizeof(c_int)]\ns_uint = {2: 'H', 4: 'I', 8: 'Q'}[sizeof(c_uint)]\ns_long = {4: 'l', 8: 'q'}[sizeof(c_long)]\ns_ulong = {4: 'L', 8: 'Q'}[sizeof(c_ulong)]\ns_longlong = \"q\"\ns_ulonglong = \"Q\"\ns_float = \"f\"\ns_double = \"d\"\ns_longdouble = \"g\"",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "s_int",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "s_int = {2: 'h', 4: 'i', 8: 'q'}[sizeof(c_int)]\ns_uint = {2: 'H', 4: 'I', 8: 'Q'}[sizeof(c_uint)]\ns_long = {4: 'l', 8: 'q'}[sizeof(c_long)]\ns_ulong = {4: 'L', 8: 'Q'}[sizeof(c_ulong)]\ns_longlong = \"q\"\ns_ulonglong = \"Q\"\ns_float = \"f\"\ns_double = \"d\"\ns_longdouble = \"g\"\n# Alias definitions in ctypes/__init__.py",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "s_uint",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "s_uint = {2: 'H', 4: 'I', 8: 'Q'}[sizeof(c_uint)]\ns_long = {4: 'l', 8: 'q'}[sizeof(c_long)]\ns_ulong = {4: 'L', 8: 'Q'}[sizeof(c_ulong)]\ns_longlong = \"q\"\ns_ulonglong = \"Q\"\ns_float = \"f\"\ns_double = \"d\"\ns_longdouble = \"g\"\n# Alias definitions in ctypes/__init__.py\nif c_int is c_long:",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "s_long",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "s_long = {4: 'l', 8: 'q'}[sizeof(c_long)]\ns_ulong = {4: 'L', 8: 'Q'}[sizeof(c_ulong)]\ns_longlong = \"q\"\ns_ulonglong = \"Q\"\ns_float = \"f\"\ns_double = \"d\"\ns_longdouble = \"g\"\n# Alias definitions in ctypes/__init__.py\nif c_int is c_long:\n    s_int = s_long",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "s_ulong",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "s_ulong = {4: 'L', 8: 'Q'}[sizeof(c_ulong)]\ns_longlong = \"q\"\ns_ulonglong = \"Q\"\ns_float = \"f\"\ns_double = \"d\"\ns_longdouble = \"g\"\n# Alias definitions in ctypes/__init__.py\nif c_int is c_long:\n    s_int = s_long\nif c_uint is c_ulong:",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "s_longlong",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "s_longlong = \"q\"\ns_ulonglong = \"Q\"\ns_float = \"f\"\ns_double = \"d\"\ns_longdouble = \"g\"\n# Alias definitions in ctypes/__init__.py\nif c_int is c_long:\n    s_int = s_long\nif c_uint is c_ulong:\n    s_uint = s_ulong",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "s_ulonglong",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "s_ulonglong = \"Q\"\ns_float = \"f\"\ns_double = \"d\"\ns_longdouble = \"g\"\n# Alias definitions in ctypes/__init__.py\nif c_int is c_long:\n    s_int = s_long\nif c_uint is c_ulong:\n    s_uint = s_ulong\nif c_longlong is c_long:",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "s_float",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "s_float = \"f\"\ns_double = \"d\"\ns_longdouble = \"g\"\n# Alias definitions in ctypes/__init__.py\nif c_int is c_long:\n    s_int = s_long\nif c_uint is c_ulong:\n    s_uint = s_ulong\nif c_longlong is c_long:\n    s_longlong = s_long",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "s_double",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "s_double = \"d\"\ns_longdouble = \"g\"\n# Alias definitions in ctypes/__init__.py\nif c_int is c_long:\n    s_int = s_long\nif c_uint is c_ulong:\n    s_uint = s_ulong\nif c_longlong is c_long:\n    s_longlong = s_long\nif c_ulonglong is c_ulong:",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "s_longdouble",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "s_longdouble = \"g\"\n# Alias definitions in ctypes/__init__.py\nif c_int is c_long:\n    s_int = s_long\nif c_uint is c_ulong:\n    s_uint = s_ulong\nif c_longlong is c_long:\n    s_longlong = s_long\nif c_ulonglong is c_ulong:\n    s_ulonglong = s_ulong",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "native_types",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "native_types = [\n    # type                      format                  shape           calc itemsize\n    ## simple types\n    (c_char,                    \"<c\",                   (),           c_char),\n    (c_byte,                    \"<b\",                   (),           c_byte),\n    (c_ubyte,                   \"<B\",                   (),           c_ubyte),\n    (c_short,                   \"<\" + s_short,          (),           c_short),\n    (c_ushort,                  \"<\" + s_ushort,         (),           c_ushort),\n    (c_int,                     \"<\" + s_int,            (),           c_int),\n    (c_uint,                    \"<\" + s_uint,           (),           c_uint),",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "endian_types",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_pep3118",
        "description": "protobuf.Lib.ctypes.test.test_pep3118",
        "peekOfCode": "endian_types = [\n    (BEPoint, \"T{>l:x:>l:y:}\".replace('l', s_long), (), BEPoint),\n    (LEPoint, \"T{<l:x:<l:y:}\".replace('l', s_long), (), LEPoint),\n    (POINTER(BEPoint), \"&T{>l:x:>l:y:}\".replace('l', s_long), (), POINTER(BEPoint)),\n    (POINTER(LEPoint), \"&T{<l:x:<l:y:}\".replace('l', s_long), (), POINTER(LEPoint)),\n    ]\nif __name__ == \"__main__\":\n    unittest.main()",
        "detail": "protobuf.Lib.ctypes.test.test_pep3118",
        "documentation": {}
    },
    {
        "label": "X",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_pickling",
        "description": "protobuf.Lib.ctypes.test.test_pickling",
        "peekOfCode": "class X(Structure):\n    _fields_ = [(\"a\", c_int), (\"b\", c_double)]\n    init_called = 0\n    def __init__(self, *args, **kw):\n        X.init_called += 1\n        self.x = 42\nclass Y(X):\n    _fields_ = [(\"str\", c_char_p)]\nclass PickleTest:\n    def dumps(self, item):",
        "detail": "protobuf.Lib.ctypes.test.test_pickling",
        "documentation": {}
    },
    {
        "label": "Y",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_pickling",
        "description": "protobuf.Lib.ctypes.test.test_pickling",
        "peekOfCode": "class Y(X):\n    _fields_ = [(\"str\", c_char_p)]\nclass PickleTest:\n    def dumps(self, item):\n        return pickle.dumps(item, self.proto)\n    def loads(self, item):\n        return pickle.loads(item)\n    def test_simple(self):\n        for src in [\n            c_int(42),",
        "detail": "protobuf.Lib.ctypes.test.test_pickling",
        "documentation": {}
    },
    {
        "label": "PickleTest",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_pickling",
        "description": "protobuf.Lib.ctypes.test.test_pickling",
        "peekOfCode": "class PickleTest:\n    def dumps(self, item):\n        return pickle.dumps(item, self.proto)\n    def loads(self, item):\n        return pickle.loads(item)\n    def test_simple(self):\n        for src in [\n            c_int(42),\n            c_double(3.14),\n            ]:",
        "detail": "protobuf.Lib.ctypes.test.test_pickling",
        "documentation": {}
    },
    {
        "label": "dll",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_pickling",
        "description": "protobuf.Lib.ctypes.test.test_pickling",
        "peekOfCode": "dll = CDLL(_ctypes_test.__file__)\nclass X(Structure):\n    _fields_ = [(\"a\", c_int), (\"b\", c_double)]\n    init_called = 0\n    def __init__(self, *args, **kw):\n        X.init_called += 1\n        self.x = 42\nclass Y(X):\n    _fields_ = [(\"str\", c_char_p)]\nclass PickleTest:",
        "detail": "protobuf.Lib.ctypes.test.test_pickling",
        "documentation": {}
    },
    {
        "label": "PointersTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_pointers",
        "description": "protobuf.Lib.ctypes.test.test_pointers",
        "peekOfCode": "class PointersTestCase(unittest.TestCase):\n    def test_pointer_crash(self):\n        class A(POINTER(c_ulong)):\n            pass\n        POINTER(c_ulong)(c_ulong(22))\n        # Pointer can't set contents: has no _type_\n        self.assertRaises(TypeError, A, c_ulong(33))\n    def test_pass_pointers(self):\n        dll = CDLL(_ctypes_test.__file__)\n        func = dll._testfunc_p_p",
        "detail": "protobuf.Lib.ctypes.test.test_pointers",
        "documentation": {}
    },
    {
        "label": "ctype_types",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_pointers",
        "description": "protobuf.Lib.ctypes.test.test_pointers",
        "peekOfCode": "ctype_types = [c_byte, c_ubyte, c_short, c_ushort, c_int, c_uint,\n                 c_long, c_ulong, c_longlong, c_ulonglong, c_double, c_float]\npython_types = [int, int, int, int, int, int,\n                int, int, int, int, float, float]\nclass PointersTestCase(unittest.TestCase):\n    def test_pointer_crash(self):\n        class A(POINTER(c_ulong)):\n            pass\n        POINTER(c_ulong)(c_ulong(22))\n        # Pointer can't set contents: has no _type_",
        "detail": "protobuf.Lib.ctypes.test.test_pointers",
        "documentation": {}
    },
    {
        "label": "python_types",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_pointers",
        "description": "protobuf.Lib.ctypes.test.test_pointers",
        "peekOfCode": "python_types = [int, int, int, int, int, int,\n                int, int, int, int, float, float]\nclass PointersTestCase(unittest.TestCase):\n    def test_pointer_crash(self):\n        class A(POINTER(c_ulong)):\n            pass\n        POINTER(c_ulong)(c_ulong(22))\n        # Pointer can't set contents: has no _type_\n        self.assertRaises(TypeError, A, c_ulong(33))\n    def test_pass_pointers(self):",
        "detail": "protobuf.Lib.ctypes.test.test_pointers",
        "documentation": {}
    },
    {
        "label": "CharPointersTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_prototypes",
        "description": "protobuf.Lib.ctypes.test.test_prototypes",
        "peekOfCode": "class CharPointersTestCase(unittest.TestCase):\n    def setUp(self):\n        func = testdll._testfunc_p_p\n        func.restype = c_long\n        func.argtypes = None\n    def test_paramflags(self):\n        # function returns c_void_p result,\n        # and has a required parameter named 'input'\n        prototype = CFUNCTYPE(c_void_p, c_void_p)\n        func = prototype((\"_testfunc_p_p\", testdll),",
        "detail": "protobuf.Lib.ctypes.test.test_prototypes",
        "documentation": {}
    },
    {
        "label": "WCharPointersTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_prototypes",
        "description": "protobuf.Lib.ctypes.test.test_prototypes",
        "peekOfCode": "class WCharPointersTestCase(unittest.TestCase):\n    def setUp(self):\n        func = testdll._testfunc_p_p\n        func.restype = c_int\n        func.argtypes = None\n    def test_POINTER_c_wchar_arg(self):\n        func = testdll._testfunc_p_p\n        func.restype = c_wchar_p\n        func.argtypes = POINTER(c_wchar),\n        self.assertEqual(None, func(None))",
        "detail": "protobuf.Lib.ctypes.test.test_prototypes",
        "documentation": {}
    },
    {
        "label": "ArrayTest",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_prototypes",
        "description": "protobuf.Lib.ctypes.test.test_prototypes",
        "peekOfCode": "class ArrayTest(unittest.TestCase):\n    def test(self):\n        func = testdll._testfunc_ai8\n        func.restype = POINTER(c_int)\n        func.argtypes = c_int * 8,\n        func((c_int * 8)(1, 2, 3, 4, 5, 6, 7, 8))\n        # This did crash before:\n        def func(): pass\n        CFUNCTYPE(None, c_int * 3)(func)\n################################################################",
        "detail": "protobuf.Lib.ctypes.test.test_prototypes",
        "documentation": {}
    },
    {
        "label": "positive_address",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.test.test_prototypes",
        "description": "protobuf.Lib.ctypes.test.test_prototypes",
        "peekOfCode": "def positive_address(a):\n    if a >= 0:\n        return a\n    # View the bits in `a` as unsigned instead.\n    import struct\n    num_bits = struct.calcsize(\"P\") * 8 # num bits in native machine address\n    a += 1 << num_bits\n    assert a >= 0\n    return a\ndef c_wbuffer(init):",
        "detail": "protobuf.Lib.ctypes.test.test_prototypes",
        "documentation": {}
    },
    {
        "label": "c_wbuffer",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.test.test_prototypes",
        "description": "protobuf.Lib.ctypes.test.test_prototypes",
        "peekOfCode": "def c_wbuffer(init):\n    n = len(init) + 1\n    return (c_wchar * n)(*init)\nclass CharPointersTestCase(unittest.TestCase):\n    def setUp(self):\n        func = testdll._testfunc_p_p\n        func.restype = c_long\n        func.argtypes = None\n    def test_paramflags(self):\n        # function returns c_void_p result,",
        "detail": "protobuf.Lib.ctypes.test.test_prototypes",
        "documentation": {}
    },
    {
        "label": "testdll",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_prototypes",
        "description": "protobuf.Lib.ctypes.test.test_prototypes",
        "peekOfCode": "testdll = CDLL(_ctypes_test.__file__)\n# Return machine address `a` as a (possibly long) non-negative integer.\n# Starting with Python 2.5, id(anything) is always non-negative, and\n# the ctypes addressof() inherits that via PyLong_FromVoidPtr().\ndef positive_address(a):\n    if a >= 0:\n        return a\n    # View the bits in `a` as unsigned instead.\n    import struct\n    num_bits = struct.calcsize(\"P\") * 8 # num bits in native machine address",
        "detail": "protobuf.Lib.ctypes.test.test_prototypes",
        "documentation": {}
    },
    {
        "label": "PythonAPITestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_python_api",
        "description": "protobuf.Lib.ctypes.test.test_python_api",
        "peekOfCode": "class PythonAPITestCase(unittest.TestCase):\n    def test_PyBytes_FromStringAndSize(self):\n        PyBytes_FromStringAndSize = pythonapi.PyBytes_FromStringAndSize\n        PyBytes_FromStringAndSize.restype = py_object\n        PyBytes_FromStringAndSize.argtypes = c_char_p, c_size_t\n        self.assertEqual(PyBytes_FromStringAndSize(b\"abcdefghi\", 3), b\"abc\")\n    @support.refcount_test\n    def test_PyString_FromString(self):\n        pythonapi.PyBytes_FromString.restype = py_object\n        pythonapi.PyBytes_FromString.argtypes = (c_char_p,)",
        "detail": "protobuf.Lib.ctypes.test.test_python_api",
        "documentation": {}
    },
    {
        "label": "call_function_TestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_random_things",
        "description": "protobuf.Lib.ctypes.test.test_random_things",
        "peekOfCode": "class call_function_TestCase(unittest.TestCase):\n    # _ctypes.call_function is deprecated and private, but used by\n    # Gary Bishp's readline module.  If we have it, we must test it as well.\n    def test(self):\n        from _ctypes import call_function\n        windll.kernel32.LoadLibraryA.restype = c_void_p\n        windll.kernel32.GetProcAddress.argtypes = c_void_p, c_char_p\n        windll.kernel32.GetProcAddress.restype = c_void_p\n        hdll = windll.kernel32.LoadLibraryA(b\"kernel32\")\n        funcaddr = windll.kernel32.GetProcAddress(hdll, b\"GetModuleHandleA\")",
        "detail": "protobuf.Lib.ctypes.test.test_random_things",
        "documentation": {}
    },
    {
        "label": "CallbackTracbackTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_random_things",
        "description": "protobuf.Lib.ctypes.test.test_random_things",
        "peekOfCode": "class CallbackTracbackTestCase(unittest.TestCase):\n    # When an exception is raised in a ctypes callback function, the C\n    # code prints a traceback.\n    #\n    # This test makes sure the exception types *and* the exception\n    # value is printed correctly.\n    #\n    # Changed in 0.9.3: No longer is '(in callback)' prepended to the\n    # error message - instead an additional frame for the C code is\n    # created, then a full traceback printed.  When SystemExit is",
        "detail": "protobuf.Lib.ctypes.test.test_random_things",
        "documentation": {}
    },
    {
        "label": "callback_func",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.test.test_random_things",
        "description": "protobuf.Lib.ctypes.test.test_random_things",
        "peekOfCode": "def callback_func(arg):\n    42 / arg\n    raise ValueError(arg)\n@unittest.skipUnless(sys.platform == \"win32\", 'Windows-specific test')\nclass call_function_TestCase(unittest.TestCase):\n    # _ctypes.call_function is deprecated and private, but used by\n    # Gary Bishp's readline module.  If we have it, we must test it as well.\n    def test(self):\n        from _ctypes import call_function\n        windll.kernel32.LoadLibraryA.restype = c_void_p",
        "detail": "protobuf.Lib.ctypes.test.test_random_things",
        "documentation": {}
    },
    {
        "label": "RefcountTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_refcounts",
        "description": "protobuf.Lib.ctypes.test.test_refcounts",
        "peekOfCode": "class RefcountTestCase(unittest.TestCase):\n    @support.refcount_test\n    def test_1(self):\n        from sys import getrefcount as grc\n        f = dll._testfunc_callback_i_if\n        f.restype = ctypes.c_int\n        f.argtypes = [ctypes.c_int, MyCallback]\n        def callback(value):\n            #print \"called back with\", value\n            return value",
        "detail": "protobuf.Lib.ctypes.test.test_refcounts",
        "documentation": {}
    },
    {
        "label": "AnotherLeak",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_refcounts",
        "description": "protobuf.Lib.ctypes.test.test_refcounts",
        "peekOfCode": "class AnotherLeak(unittest.TestCase):\n    def test_callback(self):\n        import sys\n        proto = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_int, ctypes.c_int)\n        def func(a, b):\n            return a * b * 2\n        f = proto(func)\n        a = sys.getrefcount(ctypes.c_int)\n        f(1, 2)\n        self.assertEqual(sys.getrefcount(ctypes.c_int), a)",
        "detail": "protobuf.Lib.ctypes.test.test_refcounts",
        "documentation": {}
    },
    {
        "label": "MyCallback",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_refcounts",
        "description": "protobuf.Lib.ctypes.test.test_refcounts",
        "peekOfCode": "MyCallback = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_int)\nOtherCallback = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_int, ctypes.c_ulonglong)\nimport _ctypes_test\ndll = ctypes.CDLL(_ctypes_test.__file__)\nclass RefcountTestCase(unittest.TestCase):\n    @support.refcount_test\n    def test_1(self):\n        from sys import getrefcount as grc\n        f = dll._testfunc_callback_i_if\n        f.restype = ctypes.c_int",
        "detail": "protobuf.Lib.ctypes.test.test_refcounts",
        "documentation": {}
    },
    {
        "label": "OtherCallback",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_refcounts",
        "description": "protobuf.Lib.ctypes.test.test_refcounts",
        "peekOfCode": "OtherCallback = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_int, ctypes.c_ulonglong)\nimport _ctypes_test\ndll = ctypes.CDLL(_ctypes_test.__file__)\nclass RefcountTestCase(unittest.TestCase):\n    @support.refcount_test\n    def test_1(self):\n        from sys import getrefcount as grc\n        f = dll._testfunc_callback_i_if\n        f.restype = ctypes.c_int\n        f.argtypes = [ctypes.c_int, MyCallback]",
        "detail": "protobuf.Lib.ctypes.test.test_refcounts",
        "documentation": {}
    },
    {
        "label": "dll",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_refcounts",
        "description": "protobuf.Lib.ctypes.test.test_refcounts",
        "peekOfCode": "dll = ctypes.CDLL(_ctypes_test.__file__)\nclass RefcountTestCase(unittest.TestCase):\n    @support.refcount_test\n    def test_1(self):\n        from sys import getrefcount as grc\n        f = dll._testfunc_callback_i_if\n        f.restype = ctypes.c_int\n        f.argtypes = [ctypes.c_int, MyCallback]\n        def callback(value):\n            #print \"called back with\", value",
        "detail": "protobuf.Lib.ctypes.test.test_refcounts",
        "documentation": {}
    },
    {
        "label": "X",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_repr",
        "description": "protobuf.Lib.ctypes.test.test_repr",
        "peekOfCode": "class X(c_char):\n    pass\n# This test checks if the __repr__ is correct for subclasses of simple types\nclass ReprTest(unittest.TestCase):\n    def test_numbers(self):\n        for typ in subclasses:\n            base = typ.__bases__[0]\n            self.assertTrue(repr(base(42)).startswith(base.__name__))\n            self.assertEqual(\"<X object at\", repr(typ(42))[:12])\n    def test_char(self):",
        "detail": "protobuf.Lib.ctypes.test.test_repr",
        "documentation": {}
    },
    {
        "label": "ReprTest",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_repr",
        "description": "protobuf.Lib.ctypes.test.test_repr",
        "peekOfCode": "class ReprTest(unittest.TestCase):\n    def test_numbers(self):\n        for typ in subclasses:\n            base = typ.__bases__[0]\n            self.assertTrue(repr(base(42)).startswith(base.__name__))\n            self.assertEqual(\"<X object at\", repr(typ(42))[:12])\n    def test_char(self):\n        self.assertEqual(\"c_char(b'x')\", repr(c_char(b'x')))\n        self.assertEqual(\"<X object at\", repr(X(b'x'))[:12])\nif __name__ == \"__main__\":",
        "detail": "protobuf.Lib.ctypes.test.test_repr",
        "documentation": {}
    },
    {
        "label": "subclasses",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_repr",
        "description": "protobuf.Lib.ctypes.test.test_repr",
        "peekOfCode": "subclasses = []\nfor base in [c_byte, c_short, c_int, c_long, c_longlong,\n        c_ubyte, c_ushort, c_uint, c_ulong, c_ulonglong,\n        c_float, c_double, c_longdouble, c_bool]:\n    class X(base):\n        pass\n    subclasses.append(X)\nclass X(c_char):\n    pass\n# This test checks if the __repr__ is correct for subclasses of simple types",
        "detail": "protobuf.Lib.ctypes.test.test_repr",
        "documentation": {}
    },
    {
        "label": "ReturnFuncPtrTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_returnfuncptrs",
        "description": "protobuf.Lib.ctypes.test.test_returnfuncptrs",
        "peekOfCode": "class ReturnFuncPtrTestCase(unittest.TestCase):\n    def test_with_prototype(self):\n        # The _ctypes_test shared lib/dll exports quite some functions for testing.\n        # The get_strchr function returns a *pointer* to the C strchr function.\n        dll = CDLL(_ctypes_test.__file__)\n        get_strchr = dll.get_strchr\n        get_strchr.restype = CFUNCTYPE(c_char_p, c_char_p, c_char)\n        strchr = get_strchr()\n        self.assertEqual(strchr(b\"abcdef\", b\"b\"), b\"bcdef\")\n        self.assertEqual(strchr(b\"abcdef\", b\"x\"), None)",
        "detail": "protobuf.Lib.ctypes.test.test_returnfuncptrs",
        "documentation": {}
    },
    {
        "label": "MyInt",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_simplesubclasses",
        "description": "protobuf.Lib.ctypes.test.test_simplesubclasses",
        "peekOfCode": "class MyInt(c_int):\n    def __eq__(self, other):\n        if type(other) != MyInt:\n            return NotImplementedError\n        return self.value == other.value\nclass Test(unittest.TestCase):\n    def test_compare(self):\n        self.assertEqual(MyInt(3), MyInt(3))\n        self.assertNotEqual(MyInt(42), MyInt(43))\n    def test_ignore_retval(self):",
        "detail": "protobuf.Lib.ctypes.test.test_simplesubclasses",
        "documentation": {}
    },
    {
        "label": "Test",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_simplesubclasses",
        "description": "protobuf.Lib.ctypes.test.test_simplesubclasses",
        "peekOfCode": "class Test(unittest.TestCase):\n    def test_compare(self):\n        self.assertEqual(MyInt(3), MyInt(3))\n        self.assertNotEqual(MyInt(42), MyInt(43))\n    def test_ignore_retval(self):\n        # Test if the return value of a callback is ignored\n        # if restype is None\n        proto = CFUNCTYPE(None)\n        def func():\n            return (1, \"abc\", None)",
        "detail": "protobuf.Lib.ctypes.test.test_simplesubclasses",
        "documentation": {}
    },
    {
        "label": "SizesTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_sizes",
        "description": "protobuf.Lib.ctypes.test.test_sizes",
        "peekOfCode": "class SizesTestCase(unittest.TestCase):\n    def test_8(self):\n        self.assertEqual(1, sizeof(c_int8))\n        self.assertEqual(1, sizeof(c_uint8))\n    def test_16(self):\n        self.assertEqual(2, sizeof(c_int16))\n        self.assertEqual(2, sizeof(c_uint16))\n    def test_32(self):\n        self.assertEqual(4, sizeof(c_int32))\n        self.assertEqual(4, sizeof(c_uint32))",
        "detail": "protobuf.Lib.ctypes.test.test_sizes",
        "documentation": {}
    },
    {
        "label": "SlicesTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_slicing",
        "description": "protobuf.Lib.ctypes.test.test_slicing",
        "peekOfCode": "class SlicesTestCase(unittest.TestCase):\n    def test_getslice_cint(self):\n        a = (c_int * 100)(*range(1100, 1200))\n        b = list(range(1100, 1200))\n        self.assertEqual(a[0:2], b[0:2])\n        self.assertEqual(a[0:2:], b[0:2:])\n        self.assertEqual(len(a), len(b))\n        self.assertEqual(a[5:7], b[5:7])\n        self.assertEqual(a[5:7:], b[5:7:])\n        self.assertEqual(a[-1], b[-1])",
        "detail": "protobuf.Lib.ctypes.test.test_slicing",
        "documentation": {}
    },
    {
        "label": "StringPtrTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_stringptr",
        "description": "protobuf.Lib.ctypes.test.test_stringptr",
        "peekOfCode": "class StringPtrTestCase(unittest.TestCase):\n    @support.refcount_test\n    def test__POINTER_c_char(self):\n        class X(Structure):\n            _fields_ = [(\"str\", POINTER(c_char))]\n        x = X()\n        # NULL pointer access\n        self.assertRaises(ValueError, getattr, x.str, \"contents\")\n        b = c_buffer(b\"Hello, World\")\n        from sys import getrefcount as grc",
        "detail": "protobuf.Lib.ctypes.test.test_stringptr",
        "documentation": {}
    },
    {
        "label": "lib",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_stringptr",
        "description": "protobuf.Lib.ctypes.test.test_stringptr",
        "peekOfCode": "lib = CDLL(_ctypes_test.__file__)\nclass StringPtrTestCase(unittest.TestCase):\n    @support.refcount_test\n    def test__POINTER_c_char(self):\n        class X(Structure):\n            _fields_ = [(\"str\", POINTER(c_char))]\n        x = X()\n        # NULL pointer access\n        self.assertRaises(ValueError, getattr, x.str, \"contents\")\n        b = c_buffer(b\"Hello, World\")",
        "detail": "protobuf.Lib.ctypes.test.test_stringptr",
        "documentation": {}
    },
    {
        "label": "StringArrayTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_strings",
        "description": "protobuf.Lib.ctypes.test.test_strings",
        "peekOfCode": "class StringArrayTestCase(unittest.TestCase):\n    def test(self):\n        BUF = c_char * 4\n        buf = BUF(b\"a\", b\"b\", b\"c\")\n        self.assertEqual(buf.value, b\"abc\")\n        self.assertEqual(buf.raw, b\"abc\\000\")\n        buf.value = b\"ABCD\"\n        self.assertEqual(buf.value, b\"ABCD\")\n        self.assertEqual(buf.raw, b\"ABCD\")\n        buf.value = b\"x\"",
        "detail": "protobuf.Lib.ctypes.test.test_strings",
        "documentation": {}
    },
    {
        "label": "WStringArrayTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_strings",
        "description": "protobuf.Lib.ctypes.test.test_strings",
        "peekOfCode": "class WStringArrayTestCase(unittest.TestCase):\n    def test(self):\n        BUF = c_wchar * 4\n        buf = BUF(\"a\", \"b\", \"c\")\n        self.assertEqual(buf.value, \"abc\")\n        buf.value = \"ABCD\"\n        self.assertEqual(buf.value, \"ABCD\")\n        buf.value = \"x\"\n        self.assertEqual(buf.value, \"x\")\n        buf[1] = \"Z\"",
        "detail": "protobuf.Lib.ctypes.test.test_strings",
        "documentation": {}
    },
    {
        "label": "StringTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_strings",
        "description": "protobuf.Lib.ctypes.test.test_strings",
        "peekOfCode": "class StringTestCase(unittest.TestCase):\n    @unittest.skip('test disabled')\n    def test_basic_strings(self):\n        cs = c_string(\"abcdef\")\n        # Cannot call len on a c_string any longer\n        self.assertRaises(TypeError, len, cs)\n        self.assertEqual(sizeof(cs), 7)\n        # The value property is the string up to the first terminating NUL.\n        self.assertEqual(cs.value, \"abcdef\")\n        self.assertEqual(c_string(\"abc\\000def\").value, \"abc\")",
        "detail": "protobuf.Lib.ctypes.test.test_strings",
        "documentation": {}
    },
    {
        "label": "WStringTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_strings",
        "description": "protobuf.Lib.ctypes.test.test_strings",
        "peekOfCode": "class WStringTestCase(unittest.TestCase):\n    def test_wchar(self):\n        c_wchar(\"x\")\n        repr(byref(c_wchar(\"x\")))\n        c_wchar(\"x\")\n    @unittest.skip('test disabled')\n    def test_basic_wstrings(self):\n        cs = c_wstring(\"abcdef\")\n        # XXX This behaviour is about to change:\n        # len returns the size of the internal buffer in bytes.",
        "detail": "protobuf.Lib.ctypes.test.test_strings",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.test.test_strings",
        "description": "protobuf.Lib.ctypes.test.test_strings",
        "peekOfCode": "def run_test(rep, msg, func, arg):\n    items = range(rep)\n    from time import perf_counter as clock\n    start = clock()\n    for i in items:\n        func(arg); func(arg); func(arg); func(arg); func(arg)\n    stop = clock()\n    print(\"%20s: %.2f us\" % (msg, ((stop-start)*1e6/5/rep)))\ndef check_perf():\n    # Construct 5 objects",
        "detail": "protobuf.Lib.ctypes.test.test_strings",
        "documentation": {}
    },
    {
        "label": "check_perf",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.test.test_strings",
        "description": "protobuf.Lib.ctypes.test.test_strings",
        "peekOfCode": "def check_perf():\n    # Construct 5 objects\n    REP = 200000\n    run_test(REP, \"c_string(None)\", c_string, None)\n    run_test(REP, \"c_string('abc')\", c_string, 'abc')\n# Python 2.3 -OO, win2k, P4 700 MHz:\n#\n#      c_string(None): 1.75 us\n#     c_string('abc'): 2.74 us\n# Python 2.2 -OO, win2k, P4 700 MHz:",
        "detail": "protobuf.Lib.ctypes.test.test_strings",
        "documentation": {}
    },
    {
        "label": "SubclassesTest",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_structures",
        "description": "protobuf.Lib.ctypes.test.test_structures",
        "peekOfCode": "class SubclassesTest(unittest.TestCase):\n    def test_subclass(self):\n        class X(Structure):\n            _fields_ = [(\"a\", c_int)]\n        class Y(X):\n            _fields_ = [(\"b\", c_int)]\n        class Z(X):\n            pass\n        self.assertEqual(sizeof(X), sizeof(c_int))\n        self.assertEqual(sizeof(Y), sizeof(c_int)*2)",
        "detail": "protobuf.Lib.ctypes.test.test_structures",
        "documentation": {}
    },
    {
        "label": "StructureTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_structures",
        "description": "protobuf.Lib.ctypes.test.test_structures",
        "peekOfCode": "class StructureTestCase(unittest.TestCase):\n    formats = {\"c\": c_char,\n               \"b\": c_byte,\n               \"B\": c_ubyte,\n               \"h\": c_short,\n               \"H\": c_ushort,\n               \"i\": c_int,\n               \"I\": c_uint,\n               \"l\": c_long,\n               \"L\": c_ulong,",
        "detail": "protobuf.Lib.ctypes.test.test_structures",
        "documentation": {}
    },
    {
        "label": "PointerMemberTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_structures",
        "description": "protobuf.Lib.ctypes.test.test_structures",
        "peekOfCode": "class PointerMemberTestCase(unittest.TestCase):\n    def test(self):\n        # a Structure with a POINTER field\n        class S(Structure):\n            _fields_ = [(\"array\", POINTER(c_int))]\n        s = S()\n        # We can assign arrays of the correct type\n        s.array = (c_int * 3)(1, 2, 3)\n        items = [s.array[i] for i in range(3)]\n        self.assertEqual(items, [1, 2, 3])",
        "detail": "protobuf.Lib.ctypes.test.test_structures",
        "documentation": {}
    },
    {
        "label": "TestRecursiveStructure",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_structures",
        "description": "protobuf.Lib.ctypes.test.test_structures",
        "peekOfCode": "class TestRecursiveStructure(unittest.TestCase):\n    def test_contains_itself(self):\n        class Recursive(Structure):\n            pass\n        try:\n            Recursive._fields_ = [(\"next\", Recursive)]\n        except AttributeError as details:\n            self.assertIn(\"Structure or union cannot contain itself\",\n                          str(details))\n        else:",
        "detail": "protobuf.Lib.ctypes.test.test_structures",
        "documentation": {}
    },
    {
        "label": "MACHINE",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_structures",
        "description": "protobuf.Lib.ctypes.test.test_structures",
        "peekOfCode": "MACHINE = platform.machine()\nclass SubclassesTest(unittest.TestCase):\n    def test_subclass(self):\n        class X(Structure):\n            _fields_ = [(\"a\", c_int)]\n        class Y(X):\n            _fields_ = [(\"b\", c_int)]\n        class Z(X):\n            pass\n        self.assertEqual(sizeof(X), sizeof(c_int))",
        "detail": "protobuf.Lib.ctypes.test.test_structures",
        "documentation": {}
    },
    {
        "label": "StructFieldsTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_struct_fields",
        "description": "protobuf.Lib.ctypes.test.test_struct_fields",
        "peekOfCode": "class StructFieldsTestCase(unittest.TestCase):\n    # Structure/Union classes must get 'finalized' sooner or\n    # later, when one of these things happen:\n    #\n    # 1. _fields_ is set.\n    # 2. An instance is created.\n    # 3. The type is used as field of another Structure/Union.\n    # 4. The type is subclassed\n    #\n    # When they are finalized, assigning _fields_ is no longer allowed.",
        "detail": "protobuf.Lib.ctypes.test.test_struct_fields",
        "documentation": {}
    },
    {
        "label": "TestStructures",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_unaligned_structures",
        "description": "protobuf.Lib.ctypes.test.test_unaligned_structures",
        "peekOfCode": "class TestStructures(unittest.TestCase):\n    def test_native(self):\n        for typ in structures:\n            self.assertEqual(typ.value.offset, 1)\n            o = typ()\n            o.value = 4\n            self.assertEqual(o.value, 4)\n    def test_swapped(self):\n        for typ in byteswapped_structures:\n            self.assertEqual(typ.value.offset, 1)",
        "detail": "protobuf.Lib.ctypes.test.test_unaligned_structures",
        "documentation": {}
    },
    {
        "label": "structures",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_unaligned_structures",
        "description": "protobuf.Lib.ctypes.test.test_unaligned_structures",
        "peekOfCode": "structures = []\nbyteswapped_structures = []\nif sys.byteorder == \"little\":\n    SwappedStructure = BigEndianStructure\nelse:\n    SwappedStructure = LittleEndianStructure\nfor typ in [c_short, c_int, c_long, c_longlong,\n            c_float, c_double,\n            c_ushort, c_uint, c_ulong, c_ulonglong]:\n    class X(Structure):",
        "detail": "protobuf.Lib.ctypes.test.test_unaligned_structures",
        "documentation": {}
    },
    {
        "label": "byteswapped_structures",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_unaligned_structures",
        "description": "protobuf.Lib.ctypes.test.test_unaligned_structures",
        "peekOfCode": "byteswapped_structures = []\nif sys.byteorder == \"little\":\n    SwappedStructure = BigEndianStructure\nelse:\n    SwappedStructure = LittleEndianStructure\nfor typ in [c_short, c_int, c_long, c_longlong,\n            c_float, c_double,\n            c_ushort, c_uint, c_ulong, c_ulonglong]:\n    class X(Structure):\n        _pack_ = 1",
        "detail": "protobuf.Lib.ctypes.test.test_unaligned_structures",
        "documentation": {}
    },
    {
        "label": "UnicodeTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_unicode",
        "description": "protobuf.Lib.ctypes.test.test_unicode",
        "peekOfCode": "class UnicodeTestCase(unittest.TestCase):\n    def test_wcslen(self):\n        dll = ctypes.CDLL(_ctypes_test.__file__)\n        wcslen = dll.my_wcslen\n        wcslen.argtypes = [ctypes.c_wchar_p]\n        self.assertEqual(wcslen(\"abc\"), 3)\n        self.assertEqual(wcslen(\"ab\\u2070\"), 3)\n        self.assertRaises(ctypes.ArgumentError, wcslen, b\"ab\\xe4\")\n    def test_buffers(self):\n        buf = ctypes.create_unicode_buffer(\"abc\")",
        "detail": "protobuf.Lib.ctypes.test.test_unicode",
        "documentation": {}
    },
    {
        "label": "StringTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_unicode",
        "description": "protobuf.Lib.ctypes.test.test_unicode",
        "peekOfCode": "class StringTestCase(UnicodeTestCase):\n    def setUp(self):\n        func.argtypes = [ctypes.c_char_p]\n        func.restype = ctypes.c_char_p\n    def tearDown(self):\n        func.argtypes = None\n        func.restype = ctypes.c_int\n    def test_func(self):\n        self.assertEqual(func(b\"abc\\xe4\"), b\"abc\\xe4\")\n    def test_buffers(self):",
        "detail": "protobuf.Lib.ctypes.test.test_unicode",
        "documentation": {}
    },
    {
        "label": "func",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.test.test_unicode",
        "description": "protobuf.Lib.ctypes.test.test_unicode",
        "peekOfCode": "func = ctypes.CDLL(_ctypes_test.__file__)._testfunc_p_p\nclass StringTestCase(UnicodeTestCase):\n    def setUp(self):\n        func.argtypes = [ctypes.c_char_p]\n        func.restype = ctypes.c_char_p\n    def tearDown(self):\n        func.argtypes = None\n        func.restype = ctypes.c_int\n    def test_func(self):\n        self.assertEqual(func(b\"abc\\xe4\"), b\"abc\\xe4\")",
        "detail": "protobuf.Lib.ctypes.test.test_unicode",
        "documentation": {}
    },
    {
        "label": "ValuesTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_values",
        "description": "protobuf.Lib.ctypes.test.test_values",
        "peekOfCode": "class ValuesTestCase(unittest.TestCase):\n    def test_an_integer(self):\n        # This test checks and changes an integer stored inside the\n        # _ctypes_test dll/shared lib.\n        ctdll = CDLL(_ctypes_test.__file__)\n        an_integer = c_int.in_dll(ctdll, \"an_integer\")\n        x = an_integer.value\n        self.assertEqual(x, ctdll.get_an_integer())\n        an_integer.value *= 2\n        self.assertEqual(x*2, ctdll.get_an_integer())",
        "detail": "protobuf.Lib.ctypes.test.test_values",
        "documentation": {}
    },
    {
        "label": "PythonValuesTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_values",
        "description": "protobuf.Lib.ctypes.test.test_values",
        "peekOfCode": "class PythonValuesTestCase(unittest.TestCase):\n    \"\"\"This test only works when python itself is a dll/shared library\"\"\"\n    def test_optimizeflag(self):\n        # This test accesses the Py_OptimizeFlag integer, which is\n        # exported by the Python dll and should match the sys.flags value\n        opt = c_int.in_dll(pythonapi, \"Py_OptimizeFlag\").value\n        self.assertEqual(opt, sys.flags.optimize)\n    def test_frozentable(self):\n        # Python exports a PyImport_FrozenModules symbol. This is a\n        # pointer to an array of struct _frozen entries.  The end of the",
        "detail": "protobuf.Lib.ctypes.test.test_values",
        "documentation": {}
    },
    {
        "label": "VarSizeTest",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_varsize_struct",
        "description": "protobuf.Lib.ctypes.test.test_varsize_struct",
        "peekOfCode": "class VarSizeTest(unittest.TestCase):\n    def test_resize(self):\n        class X(Structure):\n            _fields_ = [(\"item\", c_int),\n                        (\"array\", c_int * 1)]\n        self.assertEqual(sizeof(X), sizeof(c_int) * 2)\n        x = X()\n        x.item = 42\n        x.array[0] = 100\n        self.assertEqual(sizeof(x), sizeof(c_int) * 2)",
        "detail": "protobuf.Lib.ctypes.test.test_varsize_struct",
        "documentation": {}
    },
    {
        "label": "FunctionCallTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_win32",
        "description": "protobuf.Lib.ctypes.test.test_win32",
        "peekOfCode": "class FunctionCallTestCase(unittest.TestCase):\n    @unittest.skipUnless('MSC' in sys.version, \"SEH only supported by MSC\")\n    @unittest.skipIf(sys.executable.lower().endswith('_d.exe'),\n                     \"SEH not enabled in debug builds\")\n    def test_SEH(self):\n        # Disable faulthandler to prevent logging the warning:\n        # \"Windows fatal exception: access violation\"\n        with support.disable_faulthandler():\n            # Call functions with invalid arguments, and make sure\n            # that access violations are trapped and raise an",
        "detail": "protobuf.Lib.ctypes.test.test_win32",
        "documentation": {}
    },
    {
        "label": "ReturnStructSizesTestCase",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_win32",
        "description": "protobuf.Lib.ctypes.test.test_win32",
        "peekOfCode": "class ReturnStructSizesTestCase(unittest.TestCase):\n    def test_sizes(self):\n        dll = CDLL(_ctypes_test.__file__)\n        for i in range(1, 11):\n            fields = [ (f\"f{f}\", c_char) for f in range(1, i + 1)]\n            class S(Structure):\n                _fields_ = fields\n            f = getattr(dll, f\"TestSize{i}\")\n            f.restype = S\n            res = f()",
        "detail": "protobuf.Lib.ctypes.test.test_win32",
        "documentation": {}
    },
    {
        "label": "TestWintypes",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_win32",
        "description": "protobuf.Lib.ctypes.test.test_win32",
        "peekOfCode": "class TestWintypes(unittest.TestCase):\n    def test_HWND(self):\n        from ctypes import wintypes\n        self.assertEqual(sizeof(wintypes.HWND), sizeof(c_void_p))\n    def test_PARAM(self):\n        from ctypes import wintypes\n        self.assertEqual(sizeof(wintypes.WPARAM),\n                             sizeof(c_void_p))\n        self.assertEqual(sizeof(wintypes.LPARAM),\n                             sizeof(c_void_p))",
        "detail": "protobuf.Lib.ctypes.test.test_win32",
        "documentation": {}
    },
    {
        "label": "TestWinError",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_win32",
        "description": "protobuf.Lib.ctypes.test.test_win32",
        "peekOfCode": "class TestWinError(unittest.TestCase):\n    def test_winerror(self):\n        # see Issue 16169\n        import errno\n        ERROR_INVALID_PARAMETER = 87\n        msg = FormatError(ERROR_INVALID_PARAMETER).strip()\n        args = (errno.EINVAL, msg, None, ERROR_INVALID_PARAMETER)\n        e = WinError(ERROR_INVALID_PARAMETER)\n        self.assertEqual(e.args, args)\n        self.assertEqual(e.errno, errno.EINVAL)",
        "detail": "protobuf.Lib.ctypes.test.test_win32",
        "documentation": {}
    },
    {
        "label": "Structures",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_win32",
        "description": "protobuf.Lib.ctypes.test.test_win32",
        "peekOfCode": "class Structures(unittest.TestCase):\n    def test_struct_by_value(self):\n        class POINT(Structure):\n            _fields_ = [(\"x\", c_long),\n                        (\"y\", c_long)]\n        class RECT(Structure):\n            _fields_ = [(\"left\", c_long),\n                        (\"top\", c_long),\n                        (\"right\", c_long),\n                        (\"bottom\", c_long)]",
        "detail": "protobuf.Lib.ctypes.test.test_win32",
        "documentation": {}
    },
    {
        "label": "WinTypesTest",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.test.test_wintypes",
        "description": "protobuf.Lib.ctypes.test.test_wintypes",
        "peekOfCode": "class WinTypesTest(unittest.TestCase):\n    def test_variant_bool(self):\n        # reads 16-bits from memory, anything non-zero is True\n        for true_value in (1, 32767, 32768, 65535, 65537):\n            true = POINTER(c_int16)(c_int16(true_value))\n            value = cast(true, POINTER(wintypes.VARIANT_BOOL))\n            self.assertEqual(repr(value.contents), 'VARIANT_BOOL(True)')\n            vb = wintypes.VARIANT_BOOL()\n            self.assertIs(vb.value, False)\n            vb.value = True",
        "detail": "protobuf.Lib.ctypes.test.test_wintypes",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.util",
        "description": "protobuf.Lib.ctypes.util",
        "peekOfCode": "def test():\n    from ctypes import cdll\n    if os.name == \"nt\":\n        print(cdll.msvcrt)\n        print(cdll.load(\"msvcrt\"))\n        print(find_library(\"msvcrt\"))\n    if os.name == \"posix\":\n        # find and load_version\n        print(find_library(\"m\"))\n        print(find_library(\"c\"))",
        "detail": "protobuf.Lib.ctypes.util",
        "documentation": {}
    },
    {
        "label": "VARIANT_BOOL",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "class VARIANT_BOOL(ctypes._SimpleCData):\n    _type_ = \"v\"\n    def __repr__(self):\n        return \"%s(%r)\" % (self.__class__.__name__, self.value)\nULONG = ctypes.c_ulong\nLONG = ctypes.c_long\nUSHORT = ctypes.c_ushort\nSHORT = ctypes.c_short\n# in the windows header files, these are structures.\n_LARGE_INTEGER = LARGE_INTEGER = ctypes.c_longlong",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "RECT",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "class RECT(ctypes.Structure):\n    _fields_ = [(\"left\", LONG),\n                (\"top\", LONG),\n                (\"right\", LONG),\n                (\"bottom\", LONG)]\ntagRECT = _RECTL = RECTL = RECT\nclass _SMALL_RECT(ctypes.Structure):\n    _fields_ = [('Left', SHORT),\n                ('Top', SHORT),\n                ('Right', SHORT),",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "_SMALL_RECT",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "class _SMALL_RECT(ctypes.Structure):\n    _fields_ = [('Left', SHORT),\n                ('Top', SHORT),\n                ('Right', SHORT),\n                ('Bottom', SHORT)]\nSMALL_RECT = _SMALL_RECT\nclass _COORD(ctypes.Structure):\n    _fields_ = [('X', SHORT),\n                ('Y', SHORT)]\nclass POINT(ctypes.Structure):",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "_COORD",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "class _COORD(ctypes.Structure):\n    _fields_ = [('X', SHORT),\n                ('Y', SHORT)]\nclass POINT(ctypes.Structure):\n    _fields_ = [(\"x\", LONG),\n                (\"y\", LONG)]\ntagPOINT = _POINTL = POINTL = POINT\nclass SIZE(ctypes.Structure):\n    _fields_ = [(\"cx\", LONG),\n                (\"cy\", LONG)]",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "POINT",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "class POINT(ctypes.Structure):\n    _fields_ = [(\"x\", LONG),\n                (\"y\", LONG)]\ntagPOINT = _POINTL = POINTL = POINT\nclass SIZE(ctypes.Structure):\n    _fields_ = [(\"cx\", LONG),\n                (\"cy\", LONG)]\ntagSIZE = SIZEL = SIZE\ndef RGB(red, green, blue):\n    return red + (green << 8) + (blue << 16)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "SIZE",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "class SIZE(ctypes.Structure):\n    _fields_ = [(\"cx\", LONG),\n                (\"cy\", LONG)]\ntagSIZE = SIZEL = SIZE\ndef RGB(red, green, blue):\n    return red + (green << 8) + (blue << 16)\nclass FILETIME(ctypes.Structure):\n    _fields_ = [(\"dwLowDateTime\", DWORD),\n                (\"dwHighDateTime\", DWORD)]\n_FILETIME = FILETIME",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "FILETIME",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "class FILETIME(ctypes.Structure):\n    _fields_ = [(\"dwLowDateTime\", DWORD),\n                (\"dwHighDateTime\", DWORD)]\n_FILETIME = FILETIME\nclass MSG(ctypes.Structure):\n    _fields_ = [(\"hWnd\", HWND),\n                (\"message\", UINT),\n                (\"wParam\", WPARAM),\n                (\"lParam\", LPARAM),\n                (\"time\", DWORD),",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "MSG",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "class MSG(ctypes.Structure):\n    _fields_ = [(\"hWnd\", HWND),\n                (\"message\", UINT),\n                (\"wParam\", WPARAM),\n                (\"lParam\", LPARAM),\n                (\"time\", DWORD),\n                (\"pt\", POINT)]\ntagMSG = MSG\nMAX_PATH = 260\nclass WIN32_FIND_DATAA(ctypes.Structure):",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "WIN32_FIND_DATAA",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "class WIN32_FIND_DATAA(ctypes.Structure):\n    _fields_ = [(\"dwFileAttributes\", DWORD),\n                (\"ftCreationTime\", FILETIME),\n                (\"ftLastAccessTime\", FILETIME),\n                (\"ftLastWriteTime\", FILETIME),\n                (\"nFileSizeHigh\", DWORD),\n                (\"nFileSizeLow\", DWORD),\n                (\"dwReserved0\", DWORD),\n                (\"dwReserved1\", DWORD),\n                (\"cFileName\", CHAR * MAX_PATH),",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "WIN32_FIND_DATAW",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "class WIN32_FIND_DATAW(ctypes.Structure):\n    _fields_ = [(\"dwFileAttributes\", DWORD),\n                (\"ftCreationTime\", FILETIME),\n                (\"ftLastAccessTime\", FILETIME),\n                (\"ftLastWriteTime\", FILETIME),\n                (\"nFileSizeHigh\", DWORD),\n                (\"nFileSizeLow\", DWORD),\n                (\"dwReserved0\", DWORD),\n                (\"dwReserved1\", DWORD),\n                (\"cFileName\", WCHAR * MAX_PATH),",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "RGB",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "def RGB(red, green, blue):\n    return red + (green << 8) + (blue << 16)\nclass FILETIME(ctypes.Structure):\n    _fields_ = [(\"dwLowDateTime\", DWORD),\n                (\"dwHighDateTime\", DWORD)]\n_FILETIME = FILETIME\nclass MSG(ctypes.Structure):\n    _fields_ = [(\"hWnd\", HWND),\n                (\"message\", UINT),\n                (\"wParam\", WPARAM),",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "BYTE",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "BYTE = ctypes.c_byte\nWORD = ctypes.c_ushort\nDWORD = ctypes.c_ulong\n#UCHAR = ctypes.c_uchar\nCHAR = ctypes.c_char\nWCHAR = ctypes.c_wchar\nUINT = ctypes.c_uint\nINT = ctypes.c_int\nDOUBLE = ctypes.c_double\nFLOAT = ctypes.c_float",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "WORD",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "WORD = ctypes.c_ushort\nDWORD = ctypes.c_ulong\n#UCHAR = ctypes.c_uchar\nCHAR = ctypes.c_char\nWCHAR = ctypes.c_wchar\nUINT = ctypes.c_uint\nINT = ctypes.c_int\nDOUBLE = ctypes.c_double\nFLOAT = ctypes.c_float\nBOOLEAN = BYTE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "DWORD",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "DWORD = ctypes.c_ulong\n#UCHAR = ctypes.c_uchar\nCHAR = ctypes.c_char\nWCHAR = ctypes.c_wchar\nUINT = ctypes.c_uint\nINT = ctypes.c_int\nDOUBLE = ctypes.c_double\nFLOAT = ctypes.c_float\nBOOLEAN = BYTE\nBOOL = ctypes.c_long",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "#UCHAR",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "#UCHAR = ctypes.c_uchar\nCHAR = ctypes.c_char\nWCHAR = ctypes.c_wchar\nUINT = ctypes.c_uint\nINT = ctypes.c_int\nDOUBLE = ctypes.c_double\nFLOAT = ctypes.c_float\nBOOLEAN = BYTE\nBOOL = ctypes.c_long\nclass VARIANT_BOOL(ctypes._SimpleCData):",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "CHAR",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "CHAR = ctypes.c_char\nWCHAR = ctypes.c_wchar\nUINT = ctypes.c_uint\nINT = ctypes.c_int\nDOUBLE = ctypes.c_double\nFLOAT = ctypes.c_float\nBOOLEAN = BYTE\nBOOL = ctypes.c_long\nclass VARIANT_BOOL(ctypes._SimpleCData):\n    _type_ = \"v\"",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "WCHAR",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "WCHAR = ctypes.c_wchar\nUINT = ctypes.c_uint\nINT = ctypes.c_int\nDOUBLE = ctypes.c_double\nFLOAT = ctypes.c_float\nBOOLEAN = BYTE\nBOOL = ctypes.c_long\nclass VARIANT_BOOL(ctypes._SimpleCData):\n    _type_ = \"v\"\n    def __repr__(self):",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "UINT",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "UINT = ctypes.c_uint\nINT = ctypes.c_int\nDOUBLE = ctypes.c_double\nFLOAT = ctypes.c_float\nBOOLEAN = BYTE\nBOOL = ctypes.c_long\nclass VARIANT_BOOL(ctypes._SimpleCData):\n    _type_ = \"v\"\n    def __repr__(self):\n        return \"%s(%r)\" % (self.__class__.__name__, self.value)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "INT",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "INT = ctypes.c_int\nDOUBLE = ctypes.c_double\nFLOAT = ctypes.c_float\nBOOLEAN = BYTE\nBOOL = ctypes.c_long\nclass VARIANT_BOOL(ctypes._SimpleCData):\n    _type_ = \"v\"\n    def __repr__(self):\n        return \"%s(%r)\" % (self.__class__.__name__, self.value)\nULONG = ctypes.c_ulong",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "DOUBLE",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "DOUBLE = ctypes.c_double\nFLOAT = ctypes.c_float\nBOOLEAN = BYTE\nBOOL = ctypes.c_long\nclass VARIANT_BOOL(ctypes._SimpleCData):\n    _type_ = \"v\"\n    def __repr__(self):\n        return \"%s(%r)\" % (self.__class__.__name__, self.value)\nULONG = ctypes.c_ulong\nLONG = ctypes.c_long",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "FLOAT",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "FLOAT = ctypes.c_float\nBOOLEAN = BYTE\nBOOL = ctypes.c_long\nclass VARIANT_BOOL(ctypes._SimpleCData):\n    _type_ = \"v\"\n    def __repr__(self):\n        return \"%s(%r)\" % (self.__class__.__name__, self.value)\nULONG = ctypes.c_ulong\nLONG = ctypes.c_long\nUSHORT = ctypes.c_ushort",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "BOOLEAN",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "BOOLEAN = BYTE\nBOOL = ctypes.c_long\nclass VARIANT_BOOL(ctypes._SimpleCData):\n    _type_ = \"v\"\n    def __repr__(self):\n        return \"%s(%r)\" % (self.__class__.__name__, self.value)\nULONG = ctypes.c_ulong\nLONG = ctypes.c_long\nUSHORT = ctypes.c_ushort\nSHORT = ctypes.c_short",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "BOOL",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "BOOL = ctypes.c_long\nclass VARIANT_BOOL(ctypes._SimpleCData):\n    _type_ = \"v\"\n    def __repr__(self):\n        return \"%s(%r)\" % (self.__class__.__name__, self.value)\nULONG = ctypes.c_ulong\nLONG = ctypes.c_long\nUSHORT = ctypes.c_ushort\nSHORT = ctypes.c_short\n# in the windows header files, these are structures.",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "ULONG",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "ULONG = ctypes.c_ulong\nLONG = ctypes.c_long\nUSHORT = ctypes.c_ushort\nSHORT = ctypes.c_short\n# in the windows header files, these are structures.\n_LARGE_INTEGER = LARGE_INTEGER = ctypes.c_longlong\n_ULARGE_INTEGER = ULARGE_INTEGER = ctypes.c_ulonglong\nLPCOLESTR = LPOLESTR = OLESTR = ctypes.c_wchar_p\nLPCWSTR = LPWSTR = ctypes.c_wchar_p\nLPCSTR = LPSTR = ctypes.c_char_p",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LONG",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LONG = ctypes.c_long\nUSHORT = ctypes.c_ushort\nSHORT = ctypes.c_short\n# in the windows header files, these are structures.\n_LARGE_INTEGER = LARGE_INTEGER = ctypes.c_longlong\n_ULARGE_INTEGER = ULARGE_INTEGER = ctypes.c_ulonglong\nLPCOLESTR = LPOLESTR = OLESTR = ctypes.c_wchar_p\nLPCWSTR = LPWSTR = ctypes.c_wchar_p\nLPCSTR = LPSTR = ctypes.c_char_p\nLPCVOID = LPVOID = ctypes.c_void_p",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "USHORT",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "USHORT = ctypes.c_ushort\nSHORT = ctypes.c_short\n# in the windows header files, these are structures.\n_LARGE_INTEGER = LARGE_INTEGER = ctypes.c_longlong\n_ULARGE_INTEGER = ULARGE_INTEGER = ctypes.c_ulonglong\nLPCOLESTR = LPOLESTR = OLESTR = ctypes.c_wchar_p\nLPCWSTR = LPWSTR = ctypes.c_wchar_p\nLPCSTR = LPSTR = ctypes.c_char_p\nLPCVOID = LPVOID = ctypes.c_void_p\n# WPARAM is defined as UINT_PTR (unsigned type)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "SHORT",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "SHORT = ctypes.c_short\n# in the windows header files, these are structures.\n_LARGE_INTEGER = LARGE_INTEGER = ctypes.c_longlong\n_ULARGE_INTEGER = ULARGE_INTEGER = ctypes.c_ulonglong\nLPCOLESTR = LPOLESTR = OLESTR = ctypes.c_wchar_p\nLPCWSTR = LPWSTR = ctypes.c_wchar_p\nLPCSTR = LPSTR = ctypes.c_char_p\nLPCVOID = LPVOID = ctypes.c_void_p\n# WPARAM is defined as UINT_PTR (unsigned type)\n# LPARAM is defined as LONG_PTR (signed type)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "_LARGE_INTEGER",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "_LARGE_INTEGER = LARGE_INTEGER = ctypes.c_longlong\n_ULARGE_INTEGER = ULARGE_INTEGER = ctypes.c_ulonglong\nLPCOLESTR = LPOLESTR = OLESTR = ctypes.c_wchar_p\nLPCWSTR = LPWSTR = ctypes.c_wchar_p\nLPCSTR = LPSTR = ctypes.c_char_p\nLPCVOID = LPVOID = ctypes.c_void_p\n# WPARAM is defined as UINT_PTR (unsigned type)\n# LPARAM is defined as LONG_PTR (signed type)\nif ctypes.sizeof(ctypes.c_long) == ctypes.sizeof(ctypes.c_void_p):\n    WPARAM = ctypes.c_ulong",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "_ULARGE_INTEGER",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "_ULARGE_INTEGER = ULARGE_INTEGER = ctypes.c_ulonglong\nLPCOLESTR = LPOLESTR = OLESTR = ctypes.c_wchar_p\nLPCWSTR = LPWSTR = ctypes.c_wchar_p\nLPCSTR = LPSTR = ctypes.c_char_p\nLPCVOID = LPVOID = ctypes.c_void_p\n# WPARAM is defined as UINT_PTR (unsigned type)\n# LPARAM is defined as LONG_PTR (signed type)\nif ctypes.sizeof(ctypes.c_long) == ctypes.sizeof(ctypes.c_void_p):\n    WPARAM = ctypes.c_ulong\n    LPARAM = ctypes.c_long",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LPCOLESTR",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LPCOLESTR = LPOLESTR = OLESTR = ctypes.c_wchar_p\nLPCWSTR = LPWSTR = ctypes.c_wchar_p\nLPCSTR = LPSTR = ctypes.c_char_p\nLPCVOID = LPVOID = ctypes.c_void_p\n# WPARAM is defined as UINT_PTR (unsigned type)\n# LPARAM is defined as LONG_PTR (signed type)\nif ctypes.sizeof(ctypes.c_long) == ctypes.sizeof(ctypes.c_void_p):\n    WPARAM = ctypes.c_ulong\n    LPARAM = ctypes.c_long\nelif ctypes.sizeof(ctypes.c_longlong) == ctypes.sizeof(ctypes.c_void_p):",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LPCWSTR",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LPCWSTR = LPWSTR = ctypes.c_wchar_p\nLPCSTR = LPSTR = ctypes.c_char_p\nLPCVOID = LPVOID = ctypes.c_void_p\n# WPARAM is defined as UINT_PTR (unsigned type)\n# LPARAM is defined as LONG_PTR (signed type)\nif ctypes.sizeof(ctypes.c_long) == ctypes.sizeof(ctypes.c_void_p):\n    WPARAM = ctypes.c_ulong\n    LPARAM = ctypes.c_long\nelif ctypes.sizeof(ctypes.c_longlong) == ctypes.sizeof(ctypes.c_void_p):\n    WPARAM = ctypes.c_ulonglong",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LPCSTR",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LPCSTR = LPSTR = ctypes.c_char_p\nLPCVOID = LPVOID = ctypes.c_void_p\n# WPARAM is defined as UINT_PTR (unsigned type)\n# LPARAM is defined as LONG_PTR (signed type)\nif ctypes.sizeof(ctypes.c_long) == ctypes.sizeof(ctypes.c_void_p):\n    WPARAM = ctypes.c_ulong\n    LPARAM = ctypes.c_long\nelif ctypes.sizeof(ctypes.c_longlong) == ctypes.sizeof(ctypes.c_void_p):\n    WPARAM = ctypes.c_ulonglong\n    LPARAM = ctypes.c_longlong",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LPCVOID",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LPCVOID = LPVOID = ctypes.c_void_p\n# WPARAM is defined as UINT_PTR (unsigned type)\n# LPARAM is defined as LONG_PTR (signed type)\nif ctypes.sizeof(ctypes.c_long) == ctypes.sizeof(ctypes.c_void_p):\n    WPARAM = ctypes.c_ulong\n    LPARAM = ctypes.c_long\nelif ctypes.sizeof(ctypes.c_longlong) == ctypes.sizeof(ctypes.c_void_p):\n    WPARAM = ctypes.c_ulonglong\n    LPARAM = ctypes.c_longlong\nATOM = WORD",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "ATOM",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "ATOM = WORD\nLANGID = WORD\nCOLORREF = DWORD\nLGRPID = DWORD\nLCTYPE = DWORD\nLCID = DWORD\n################################################################\n# HANDLE types\nHANDLE = ctypes.c_void_p # in the header files: void *\nHACCEL = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LANGID",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LANGID = WORD\nCOLORREF = DWORD\nLGRPID = DWORD\nLCTYPE = DWORD\nLCID = DWORD\n################################################################\n# HANDLE types\nHANDLE = ctypes.c_void_p # in the header files: void *\nHACCEL = HANDLE\nHBITMAP = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "COLORREF",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "COLORREF = DWORD\nLGRPID = DWORD\nLCTYPE = DWORD\nLCID = DWORD\n################################################################\n# HANDLE types\nHANDLE = ctypes.c_void_p # in the header files: void *\nHACCEL = HANDLE\nHBITMAP = HANDLE\nHBRUSH = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LGRPID",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LGRPID = DWORD\nLCTYPE = DWORD\nLCID = DWORD\n################################################################\n# HANDLE types\nHANDLE = ctypes.c_void_p # in the header files: void *\nHACCEL = HANDLE\nHBITMAP = HANDLE\nHBRUSH = HANDLE\nHCOLORSPACE = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LCTYPE",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LCTYPE = DWORD\nLCID = DWORD\n################################################################\n# HANDLE types\nHANDLE = ctypes.c_void_p # in the header files: void *\nHACCEL = HANDLE\nHBITMAP = HANDLE\nHBRUSH = HANDLE\nHCOLORSPACE = HANDLE\nHDC = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LCID",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LCID = DWORD\n################################################################\n# HANDLE types\nHANDLE = ctypes.c_void_p # in the header files: void *\nHACCEL = HANDLE\nHBITMAP = HANDLE\nHBRUSH = HANDLE\nHCOLORSPACE = HANDLE\nHDC = HANDLE\nHDESK = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HANDLE",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HANDLE = ctypes.c_void_p # in the header files: void *\nHACCEL = HANDLE\nHBITMAP = HANDLE\nHBRUSH = HANDLE\nHCOLORSPACE = HANDLE\nHDC = HANDLE\nHDESK = HANDLE\nHDWP = HANDLE\nHENHMETAFILE = HANDLE\nHFONT = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HACCEL",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HACCEL = HANDLE\nHBITMAP = HANDLE\nHBRUSH = HANDLE\nHCOLORSPACE = HANDLE\nHDC = HANDLE\nHDESK = HANDLE\nHDWP = HANDLE\nHENHMETAFILE = HANDLE\nHFONT = HANDLE\nHGDIOBJ = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HBITMAP",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HBITMAP = HANDLE\nHBRUSH = HANDLE\nHCOLORSPACE = HANDLE\nHDC = HANDLE\nHDESK = HANDLE\nHDWP = HANDLE\nHENHMETAFILE = HANDLE\nHFONT = HANDLE\nHGDIOBJ = HANDLE\nHGLOBAL = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HBRUSH",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HBRUSH = HANDLE\nHCOLORSPACE = HANDLE\nHDC = HANDLE\nHDESK = HANDLE\nHDWP = HANDLE\nHENHMETAFILE = HANDLE\nHFONT = HANDLE\nHGDIOBJ = HANDLE\nHGLOBAL = HANDLE\nHHOOK = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HCOLORSPACE",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HCOLORSPACE = HANDLE\nHDC = HANDLE\nHDESK = HANDLE\nHDWP = HANDLE\nHENHMETAFILE = HANDLE\nHFONT = HANDLE\nHGDIOBJ = HANDLE\nHGLOBAL = HANDLE\nHHOOK = HANDLE\nHICON = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HDC",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HDC = HANDLE\nHDESK = HANDLE\nHDWP = HANDLE\nHENHMETAFILE = HANDLE\nHFONT = HANDLE\nHGDIOBJ = HANDLE\nHGLOBAL = HANDLE\nHHOOK = HANDLE\nHICON = HANDLE\nHINSTANCE = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HDESK",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HDESK = HANDLE\nHDWP = HANDLE\nHENHMETAFILE = HANDLE\nHFONT = HANDLE\nHGDIOBJ = HANDLE\nHGLOBAL = HANDLE\nHHOOK = HANDLE\nHICON = HANDLE\nHINSTANCE = HANDLE\nHKEY = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HDWP",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HDWP = HANDLE\nHENHMETAFILE = HANDLE\nHFONT = HANDLE\nHGDIOBJ = HANDLE\nHGLOBAL = HANDLE\nHHOOK = HANDLE\nHICON = HANDLE\nHINSTANCE = HANDLE\nHKEY = HANDLE\nHKL = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HENHMETAFILE",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HENHMETAFILE = HANDLE\nHFONT = HANDLE\nHGDIOBJ = HANDLE\nHGLOBAL = HANDLE\nHHOOK = HANDLE\nHICON = HANDLE\nHINSTANCE = HANDLE\nHKEY = HANDLE\nHKL = HANDLE\nHLOCAL = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HFONT",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HFONT = HANDLE\nHGDIOBJ = HANDLE\nHGLOBAL = HANDLE\nHHOOK = HANDLE\nHICON = HANDLE\nHINSTANCE = HANDLE\nHKEY = HANDLE\nHKL = HANDLE\nHLOCAL = HANDLE\nHMENU = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HGDIOBJ",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HGDIOBJ = HANDLE\nHGLOBAL = HANDLE\nHHOOK = HANDLE\nHICON = HANDLE\nHINSTANCE = HANDLE\nHKEY = HANDLE\nHKL = HANDLE\nHLOCAL = HANDLE\nHMENU = HANDLE\nHMETAFILE = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HGLOBAL",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HGLOBAL = HANDLE\nHHOOK = HANDLE\nHICON = HANDLE\nHINSTANCE = HANDLE\nHKEY = HANDLE\nHKL = HANDLE\nHLOCAL = HANDLE\nHMENU = HANDLE\nHMETAFILE = HANDLE\nHMODULE = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HHOOK",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HHOOK = HANDLE\nHICON = HANDLE\nHINSTANCE = HANDLE\nHKEY = HANDLE\nHKL = HANDLE\nHLOCAL = HANDLE\nHMENU = HANDLE\nHMETAFILE = HANDLE\nHMODULE = HANDLE\nHMONITOR = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HICON",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HICON = HANDLE\nHINSTANCE = HANDLE\nHKEY = HANDLE\nHKL = HANDLE\nHLOCAL = HANDLE\nHMENU = HANDLE\nHMETAFILE = HANDLE\nHMODULE = HANDLE\nHMONITOR = HANDLE\nHPALETTE = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HINSTANCE",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HINSTANCE = HANDLE\nHKEY = HANDLE\nHKL = HANDLE\nHLOCAL = HANDLE\nHMENU = HANDLE\nHMETAFILE = HANDLE\nHMODULE = HANDLE\nHMONITOR = HANDLE\nHPALETTE = HANDLE\nHPEN = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HKEY",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HKEY = HANDLE\nHKL = HANDLE\nHLOCAL = HANDLE\nHMENU = HANDLE\nHMETAFILE = HANDLE\nHMODULE = HANDLE\nHMONITOR = HANDLE\nHPALETTE = HANDLE\nHPEN = HANDLE\nHRGN = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HKL",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HKL = HANDLE\nHLOCAL = HANDLE\nHMENU = HANDLE\nHMETAFILE = HANDLE\nHMODULE = HANDLE\nHMONITOR = HANDLE\nHPALETTE = HANDLE\nHPEN = HANDLE\nHRGN = HANDLE\nHRSRC = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HLOCAL",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HLOCAL = HANDLE\nHMENU = HANDLE\nHMETAFILE = HANDLE\nHMODULE = HANDLE\nHMONITOR = HANDLE\nHPALETTE = HANDLE\nHPEN = HANDLE\nHRGN = HANDLE\nHRSRC = HANDLE\nHSTR = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HMENU",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HMENU = HANDLE\nHMETAFILE = HANDLE\nHMODULE = HANDLE\nHMONITOR = HANDLE\nHPALETTE = HANDLE\nHPEN = HANDLE\nHRGN = HANDLE\nHRSRC = HANDLE\nHSTR = HANDLE\nHTASK = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HMETAFILE",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HMETAFILE = HANDLE\nHMODULE = HANDLE\nHMONITOR = HANDLE\nHPALETTE = HANDLE\nHPEN = HANDLE\nHRGN = HANDLE\nHRSRC = HANDLE\nHSTR = HANDLE\nHTASK = HANDLE\nHWINSTA = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HMODULE",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HMODULE = HANDLE\nHMONITOR = HANDLE\nHPALETTE = HANDLE\nHPEN = HANDLE\nHRGN = HANDLE\nHRSRC = HANDLE\nHSTR = HANDLE\nHTASK = HANDLE\nHWINSTA = HANDLE\nHWND = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HMONITOR",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HMONITOR = HANDLE\nHPALETTE = HANDLE\nHPEN = HANDLE\nHRGN = HANDLE\nHRSRC = HANDLE\nHSTR = HANDLE\nHTASK = HANDLE\nHWINSTA = HANDLE\nHWND = HANDLE\nSC_HANDLE = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HPALETTE",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HPALETTE = HANDLE\nHPEN = HANDLE\nHRGN = HANDLE\nHRSRC = HANDLE\nHSTR = HANDLE\nHTASK = HANDLE\nHWINSTA = HANDLE\nHWND = HANDLE\nSC_HANDLE = HANDLE\nSERVICE_STATUS_HANDLE = HANDLE",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HPEN",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HPEN = HANDLE\nHRGN = HANDLE\nHRSRC = HANDLE\nHSTR = HANDLE\nHTASK = HANDLE\nHWINSTA = HANDLE\nHWND = HANDLE\nSC_HANDLE = HANDLE\nSERVICE_STATUS_HANDLE = HANDLE\n################################################################",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HRGN",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HRGN = HANDLE\nHRSRC = HANDLE\nHSTR = HANDLE\nHTASK = HANDLE\nHWINSTA = HANDLE\nHWND = HANDLE\nSC_HANDLE = HANDLE\nSERVICE_STATUS_HANDLE = HANDLE\n################################################################\n# Some important structure definitions",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HRSRC",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HRSRC = HANDLE\nHSTR = HANDLE\nHTASK = HANDLE\nHWINSTA = HANDLE\nHWND = HANDLE\nSC_HANDLE = HANDLE\nSERVICE_STATUS_HANDLE = HANDLE\n################################################################\n# Some important structure definitions\nclass RECT(ctypes.Structure):",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HSTR",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HSTR = HANDLE\nHTASK = HANDLE\nHWINSTA = HANDLE\nHWND = HANDLE\nSC_HANDLE = HANDLE\nSERVICE_STATUS_HANDLE = HANDLE\n################################################################\n# Some important structure definitions\nclass RECT(ctypes.Structure):\n    _fields_ = [(\"left\", LONG),",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HTASK",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HTASK = HANDLE\nHWINSTA = HANDLE\nHWND = HANDLE\nSC_HANDLE = HANDLE\nSERVICE_STATUS_HANDLE = HANDLE\n################################################################\n# Some important structure definitions\nclass RECT(ctypes.Structure):\n    _fields_ = [(\"left\", LONG),\n                (\"top\", LONG),",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HWINSTA",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HWINSTA = HANDLE\nHWND = HANDLE\nSC_HANDLE = HANDLE\nSERVICE_STATUS_HANDLE = HANDLE\n################################################################\n# Some important structure definitions\nclass RECT(ctypes.Structure):\n    _fields_ = [(\"left\", LONG),\n                (\"top\", LONG),\n                (\"right\", LONG),",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "HWND",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "HWND = HANDLE\nSC_HANDLE = HANDLE\nSERVICE_STATUS_HANDLE = HANDLE\n################################################################\n# Some important structure definitions\nclass RECT(ctypes.Structure):\n    _fields_ = [(\"left\", LONG),\n                (\"top\", LONG),\n                (\"right\", LONG),\n                (\"bottom\", LONG)]",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "SC_HANDLE",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "SC_HANDLE = HANDLE\nSERVICE_STATUS_HANDLE = HANDLE\n################################################################\n# Some important structure definitions\nclass RECT(ctypes.Structure):\n    _fields_ = [(\"left\", LONG),\n                (\"top\", LONG),\n                (\"right\", LONG),\n                (\"bottom\", LONG)]\ntagRECT = _RECTL = RECTL = RECT",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "SERVICE_STATUS_HANDLE",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "SERVICE_STATUS_HANDLE = HANDLE\n################################################################\n# Some important structure definitions\nclass RECT(ctypes.Structure):\n    _fields_ = [(\"left\", LONG),\n                (\"top\", LONG),\n                (\"right\", LONG),\n                (\"bottom\", LONG)]\ntagRECT = _RECTL = RECTL = RECT\nclass _SMALL_RECT(ctypes.Structure):",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "tagRECT",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "tagRECT = _RECTL = RECTL = RECT\nclass _SMALL_RECT(ctypes.Structure):\n    _fields_ = [('Left', SHORT),\n                ('Top', SHORT),\n                ('Right', SHORT),\n                ('Bottom', SHORT)]\nSMALL_RECT = _SMALL_RECT\nclass _COORD(ctypes.Structure):\n    _fields_ = [('X', SHORT),\n                ('Y', SHORT)]",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "SMALL_RECT",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "SMALL_RECT = _SMALL_RECT\nclass _COORD(ctypes.Structure):\n    _fields_ = [('X', SHORT),\n                ('Y', SHORT)]\nclass POINT(ctypes.Structure):\n    _fields_ = [(\"x\", LONG),\n                (\"y\", LONG)]\ntagPOINT = _POINTL = POINTL = POINT\nclass SIZE(ctypes.Structure):\n    _fields_ = [(\"cx\", LONG),",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "tagPOINT",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "tagPOINT = _POINTL = POINTL = POINT\nclass SIZE(ctypes.Structure):\n    _fields_ = [(\"cx\", LONG),\n                (\"cy\", LONG)]\ntagSIZE = SIZEL = SIZE\ndef RGB(red, green, blue):\n    return red + (green << 8) + (blue << 16)\nclass FILETIME(ctypes.Structure):\n    _fields_ = [(\"dwLowDateTime\", DWORD),\n                (\"dwHighDateTime\", DWORD)]",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "tagSIZE",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "tagSIZE = SIZEL = SIZE\ndef RGB(red, green, blue):\n    return red + (green << 8) + (blue << 16)\nclass FILETIME(ctypes.Structure):\n    _fields_ = [(\"dwLowDateTime\", DWORD),\n                (\"dwHighDateTime\", DWORD)]\n_FILETIME = FILETIME\nclass MSG(ctypes.Structure):\n    _fields_ = [(\"hWnd\", HWND),\n                (\"message\", UINT),",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "_FILETIME",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "_FILETIME = FILETIME\nclass MSG(ctypes.Structure):\n    _fields_ = [(\"hWnd\", HWND),\n                (\"message\", UINT),\n                (\"wParam\", WPARAM),\n                (\"lParam\", LPARAM),\n                (\"time\", DWORD),\n                (\"pt\", POINT)]\ntagMSG = MSG\nMAX_PATH = 260",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "tagMSG",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "tagMSG = MSG\nMAX_PATH = 260\nclass WIN32_FIND_DATAA(ctypes.Structure):\n    _fields_ = [(\"dwFileAttributes\", DWORD),\n                (\"ftCreationTime\", FILETIME),\n                (\"ftLastAccessTime\", FILETIME),\n                (\"ftLastWriteTime\", FILETIME),\n                (\"nFileSizeHigh\", DWORD),\n                (\"nFileSizeLow\", DWORD),\n                (\"dwReserved0\", DWORD),",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "MAX_PATH",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "MAX_PATH = 260\nclass WIN32_FIND_DATAA(ctypes.Structure):\n    _fields_ = [(\"dwFileAttributes\", DWORD),\n                (\"ftCreationTime\", FILETIME),\n                (\"ftLastAccessTime\", FILETIME),\n                (\"ftLastWriteTime\", FILETIME),\n                (\"nFileSizeHigh\", DWORD),\n                (\"nFileSizeLow\", DWORD),\n                (\"dwReserved0\", DWORD),\n                (\"dwReserved1\", DWORD),",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LPBOOL",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LPBOOL = PBOOL = ctypes.POINTER(BOOL)\nPBOOLEAN = ctypes.POINTER(BOOLEAN)\nLPBYTE = PBYTE = ctypes.POINTER(BYTE)\nPCHAR = ctypes.POINTER(CHAR)\nLPCOLORREF = ctypes.POINTER(COLORREF)\nLPDWORD = PDWORD = ctypes.POINTER(DWORD)\nLPFILETIME = PFILETIME = ctypes.POINTER(FILETIME)\nPFLOAT = ctypes.POINTER(FLOAT)\nLPHANDLE = PHANDLE = ctypes.POINTER(HANDLE)\nPHKEY = ctypes.POINTER(HKEY)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "PBOOLEAN",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "PBOOLEAN = ctypes.POINTER(BOOLEAN)\nLPBYTE = PBYTE = ctypes.POINTER(BYTE)\nPCHAR = ctypes.POINTER(CHAR)\nLPCOLORREF = ctypes.POINTER(COLORREF)\nLPDWORD = PDWORD = ctypes.POINTER(DWORD)\nLPFILETIME = PFILETIME = ctypes.POINTER(FILETIME)\nPFLOAT = ctypes.POINTER(FLOAT)\nLPHANDLE = PHANDLE = ctypes.POINTER(HANDLE)\nPHKEY = ctypes.POINTER(HKEY)\nLPHKL = ctypes.POINTER(HKL)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LPBYTE",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LPBYTE = PBYTE = ctypes.POINTER(BYTE)\nPCHAR = ctypes.POINTER(CHAR)\nLPCOLORREF = ctypes.POINTER(COLORREF)\nLPDWORD = PDWORD = ctypes.POINTER(DWORD)\nLPFILETIME = PFILETIME = ctypes.POINTER(FILETIME)\nPFLOAT = ctypes.POINTER(FLOAT)\nLPHANDLE = PHANDLE = ctypes.POINTER(HANDLE)\nPHKEY = ctypes.POINTER(HKEY)\nLPHKL = ctypes.POINTER(HKL)\nLPINT = PINT = ctypes.POINTER(INT)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "PCHAR",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "PCHAR = ctypes.POINTER(CHAR)\nLPCOLORREF = ctypes.POINTER(COLORREF)\nLPDWORD = PDWORD = ctypes.POINTER(DWORD)\nLPFILETIME = PFILETIME = ctypes.POINTER(FILETIME)\nPFLOAT = ctypes.POINTER(FLOAT)\nLPHANDLE = PHANDLE = ctypes.POINTER(HANDLE)\nPHKEY = ctypes.POINTER(HKEY)\nLPHKL = ctypes.POINTER(HKL)\nLPINT = PINT = ctypes.POINTER(INT)\nPLARGE_INTEGER = ctypes.POINTER(LARGE_INTEGER)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LPCOLORREF",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LPCOLORREF = ctypes.POINTER(COLORREF)\nLPDWORD = PDWORD = ctypes.POINTER(DWORD)\nLPFILETIME = PFILETIME = ctypes.POINTER(FILETIME)\nPFLOAT = ctypes.POINTER(FLOAT)\nLPHANDLE = PHANDLE = ctypes.POINTER(HANDLE)\nPHKEY = ctypes.POINTER(HKEY)\nLPHKL = ctypes.POINTER(HKL)\nLPINT = PINT = ctypes.POINTER(INT)\nPLARGE_INTEGER = ctypes.POINTER(LARGE_INTEGER)\nPLCID = ctypes.POINTER(LCID)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LPDWORD",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LPDWORD = PDWORD = ctypes.POINTER(DWORD)\nLPFILETIME = PFILETIME = ctypes.POINTER(FILETIME)\nPFLOAT = ctypes.POINTER(FLOAT)\nLPHANDLE = PHANDLE = ctypes.POINTER(HANDLE)\nPHKEY = ctypes.POINTER(HKEY)\nLPHKL = ctypes.POINTER(HKL)\nLPINT = PINT = ctypes.POINTER(INT)\nPLARGE_INTEGER = ctypes.POINTER(LARGE_INTEGER)\nPLCID = ctypes.POINTER(LCID)\nLPLONG = PLONG = ctypes.POINTER(LONG)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LPFILETIME",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LPFILETIME = PFILETIME = ctypes.POINTER(FILETIME)\nPFLOAT = ctypes.POINTER(FLOAT)\nLPHANDLE = PHANDLE = ctypes.POINTER(HANDLE)\nPHKEY = ctypes.POINTER(HKEY)\nLPHKL = ctypes.POINTER(HKL)\nLPINT = PINT = ctypes.POINTER(INT)\nPLARGE_INTEGER = ctypes.POINTER(LARGE_INTEGER)\nPLCID = ctypes.POINTER(LCID)\nLPLONG = PLONG = ctypes.POINTER(LONG)\nLPMSG = PMSG = ctypes.POINTER(MSG)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "PFLOAT",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "PFLOAT = ctypes.POINTER(FLOAT)\nLPHANDLE = PHANDLE = ctypes.POINTER(HANDLE)\nPHKEY = ctypes.POINTER(HKEY)\nLPHKL = ctypes.POINTER(HKL)\nLPINT = PINT = ctypes.POINTER(INT)\nPLARGE_INTEGER = ctypes.POINTER(LARGE_INTEGER)\nPLCID = ctypes.POINTER(LCID)\nLPLONG = PLONG = ctypes.POINTER(LONG)\nLPMSG = PMSG = ctypes.POINTER(MSG)\nLPPOINT = PPOINT = ctypes.POINTER(POINT)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LPHANDLE",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LPHANDLE = PHANDLE = ctypes.POINTER(HANDLE)\nPHKEY = ctypes.POINTER(HKEY)\nLPHKL = ctypes.POINTER(HKL)\nLPINT = PINT = ctypes.POINTER(INT)\nPLARGE_INTEGER = ctypes.POINTER(LARGE_INTEGER)\nPLCID = ctypes.POINTER(LCID)\nLPLONG = PLONG = ctypes.POINTER(LONG)\nLPMSG = PMSG = ctypes.POINTER(MSG)\nLPPOINT = PPOINT = ctypes.POINTER(POINT)\nPPOINTL = ctypes.POINTER(POINTL)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "PHKEY",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "PHKEY = ctypes.POINTER(HKEY)\nLPHKL = ctypes.POINTER(HKL)\nLPINT = PINT = ctypes.POINTER(INT)\nPLARGE_INTEGER = ctypes.POINTER(LARGE_INTEGER)\nPLCID = ctypes.POINTER(LCID)\nLPLONG = PLONG = ctypes.POINTER(LONG)\nLPMSG = PMSG = ctypes.POINTER(MSG)\nLPPOINT = PPOINT = ctypes.POINTER(POINT)\nPPOINTL = ctypes.POINTER(POINTL)\nLPRECT = PRECT = ctypes.POINTER(RECT)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LPHKL",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LPHKL = ctypes.POINTER(HKL)\nLPINT = PINT = ctypes.POINTER(INT)\nPLARGE_INTEGER = ctypes.POINTER(LARGE_INTEGER)\nPLCID = ctypes.POINTER(LCID)\nLPLONG = PLONG = ctypes.POINTER(LONG)\nLPMSG = PMSG = ctypes.POINTER(MSG)\nLPPOINT = PPOINT = ctypes.POINTER(POINT)\nPPOINTL = ctypes.POINTER(POINTL)\nLPRECT = PRECT = ctypes.POINTER(RECT)\nLPRECTL = PRECTL = ctypes.POINTER(RECTL)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LPINT",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LPINT = PINT = ctypes.POINTER(INT)\nPLARGE_INTEGER = ctypes.POINTER(LARGE_INTEGER)\nPLCID = ctypes.POINTER(LCID)\nLPLONG = PLONG = ctypes.POINTER(LONG)\nLPMSG = PMSG = ctypes.POINTER(MSG)\nLPPOINT = PPOINT = ctypes.POINTER(POINT)\nPPOINTL = ctypes.POINTER(POINTL)\nLPRECT = PRECT = ctypes.POINTER(RECT)\nLPRECTL = PRECTL = ctypes.POINTER(RECTL)\nLPSC_HANDLE = ctypes.POINTER(SC_HANDLE)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "PLARGE_INTEGER",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "PLARGE_INTEGER = ctypes.POINTER(LARGE_INTEGER)\nPLCID = ctypes.POINTER(LCID)\nLPLONG = PLONG = ctypes.POINTER(LONG)\nLPMSG = PMSG = ctypes.POINTER(MSG)\nLPPOINT = PPOINT = ctypes.POINTER(POINT)\nPPOINTL = ctypes.POINTER(POINTL)\nLPRECT = PRECT = ctypes.POINTER(RECT)\nLPRECTL = PRECTL = ctypes.POINTER(RECTL)\nLPSC_HANDLE = ctypes.POINTER(SC_HANDLE)\nPSHORT = ctypes.POINTER(SHORT)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "PLCID",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "PLCID = ctypes.POINTER(LCID)\nLPLONG = PLONG = ctypes.POINTER(LONG)\nLPMSG = PMSG = ctypes.POINTER(MSG)\nLPPOINT = PPOINT = ctypes.POINTER(POINT)\nPPOINTL = ctypes.POINTER(POINTL)\nLPRECT = PRECT = ctypes.POINTER(RECT)\nLPRECTL = PRECTL = ctypes.POINTER(RECTL)\nLPSC_HANDLE = ctypes.POINTER(SC_HANDLE)\nPSHORT = ctypes.POINTER(SHORT)\nLPSIZE = PSIZE = ctypes.POINTER(SIZE)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LPLONG",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LPLONG = PLONG = ctypes.POINTER(LONG)\nLPMSG = PMSG = ctypes.POINTER(MSG)\nLPPOINT = PPOINT = ctypes.POINTER(POINT)\nPPOINTL = ctypes.POINTER(POINTL)\nLPRECT = PRECT = ctypes.POINTER(RECT)\nLPRECTL = PRECTL = ctypes.POINTER(RECTL)\nLPSC_HANDLE = ctypes.POINTER(SC_HANDLE)\nPSHORT = ctypes.POINTER(SHORT)\nLPSIZE = PSIZE = ctypes.POINTER(SIZE)\nLPSIZEL = PSIZEL = ctypes.POINTER(SIZEL)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LPMSG",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LPMSG = PMSG = ctypes.POINTER(MSG)\nLPPOINT = PPOINT = ctypes.POINTER(POINT)\nPPOINTL = ctypes.POINTER(POINTL)\nLPRECT = PRECT = ctypes.POINTER(RECT)\nLPRECTL = PRECTL = ctypes.POINTER(RECTL)\nLPSC_HANDLE = ctypes.POINTER(SC_HANDLE)\nPSHORT = ctypes.POINTER(SHORT)\nLPSIZE = PSIZE = ctypes.POINTER(SIZE)\nLPSIZEL = PSIZEL = ctypes.POINTER(SIZEL)\nPSMALL_RECT = ctypes.POINTER(SMALL_RECT)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LPPOINT",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LPPOINT = PPOINT = ctypes.POINTER(POINT)\nPPOINTL = ctypes.POINTER(POINTL)\nLPRECT = PRECT = ctypes.POINTER(RECT)\nLPRECTL = PRECTL = ctypes.POINTER(RECTL)\nLPSC_HANDLE = ctypes.POINTER(SC_HANDLE)\nPSHORT = ctypes.POINTER(SHORT)\nLPSIZE = PSIZE = ctypes.POINTER(SIZE)\nLPSIZEL = PSIZEL = ctypes.POINTER(SIZEL)\nPSMALL_RECT = ctypes.POINTER(SMALL_RECT)\nLPUINT = PUINT = ctypes.POINTER(UINT)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "PPOINTL",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "PPOINTL = ctypes.POINTER(POINTL)\nLPRECT = PRECT = ctypes.POINTER(RECT)\nLPRECTL = PRECTL = ctypes.POINTER(RECTL)\nLPSC_HANDLE = ctypes.POINTER(SC_HANDLE)\nPSHORT = ctypes.POINTER(SHORT)\nLPSIZE = PSIZE = ctypes.POINTER(SIZE)\nLPSIZEL = PSIZEL = ctypes.POINTER(SIZEL)\nPSMALL_RECT = ctypes.POINTER(SMALL_RECT)\nLPUINT = PUINT = ctypes.POINTER(UINT)\nPULARGE_INTEGER = ctypes.POINTER(ULARGE_INTEGER)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LPRECT",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LPRECT = PRECT = ctypes.POINTER(RECT)\nLPRECTL = PRECTL = ctypes.POINTER(RECTL)\nLPSC_HANDLE = ctypes.POINTER(SC_HANDLE)\nPSHORT = ctypes.POINTER(SHORT)\nLPSIZE = PSIZE = ctypes.POINTER(SIZE)\nLPSIZEL = PSIZEL = ctypes.POINTER(SIZEL)\nPSMALL_RECT = ctypes.POINTER(SMALL_RECT)\nLPUINT = PUINT = ctypes.POINTER(UINT)\nPULARGE_INTEGER = ctypes.POINTER(ULARGE_INTEGER)\nPULONG = ctypes.POINTER(ULONG)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LPRECTL",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LPRECTL = PRECTL = ctypes.POINTER(RECTL)\nLPSC_HANDLE = ctypes.POINTER(SC_HANDLE)\nPSHORT = ctypes.POINTER(SHORT)\nLPSIZE = PSIZE = ctypes.POINTER(SIZE)\nLPSIZEL = PSIZEL = ctypes.POINTER(SIZEL)\nPSMALL_RECT = ctypes.POINTER(SMALL_RECT)\nLPUINT = PUINT = ctypes.POINTER(UINT)\nPULARGE_INTEGER = ctypes.POINTER(ULARGE_INTEGER)\nPULONG = ctypes.POINTER(ULONG)\nPUSHORT = ctypes.POINTER(USHORT)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LPSC_HANDLE",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LPSC_HANDLE = ctypes.POINTER(SC_HANDLE)\nPSHORT = ctypes.POINTER(SHORT)\nLPSIZE = PSIZE = ctypes.POINTER(SIZE)\nLPSIZEL = PSIZEL = ctypes.POINTER(SIZEL)\nPSMALL_RECT = ctypes.POINTER(SMALL_RECT)\nLPUINT = PUINT = ctypes.POINTER(UINT)\nPULARGE_INTEGER = ctypes.POINTER(ULARGE_INTEGER)\nPULONG = ctypes.POINTER(ULONG)\nPUSHORT = ctypes.POINTER(USHORT)\nPWCHAR = ctypes.POINTER(WCHAR)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "PSHORT",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "PSHORT = ctypes.POINTER(SHORT)\nLPSIZE = PSIZE = ctypes.POINTER(SIZE)\nLPSIZEL = PSIZEL = ctypes.POINTER(SIZEL)\nPSMALL_RECT = ctypes.POINTER(SMALL_RECT)\nLPUINT = PUINT = ctypes.POINTER(UINT)\nPULARGE_INTEGER = ctypes.POINTER(ULARGE_INTEGER)\nPULONG = ctypes.POINTER(ULONG)\nPUSHORT = ctypes.POINTER(USHORT)\nPWCHAR = ctypes.POINTER(WCHAR)\nLPWIN32_FIND_DATAA = PWIN32_FIND_DATAA = ctypes.POINTER(WIN32_FIND_DATAA)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LPSIZE",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LPSIZE = PSIZE = ctypes.POINTER(SIZE)\nLPSIZEL = PSIZEL = ctypes.POINTER(SIZEL)\nPSMALL_RECT = ctypes.POINTER(SMALL_RECT)\nLPUINT = PUINT = ctypes.POINTER(UINT)\nPULARGE_INTEGER = ctypes.POINTER(ULARGE_INTEGER)\nPULONG = ctypes.POINTER(ULONG)\nPUSHORT = ctypes.POINTER(USHORT)\nPWCHAR = ctypes.POINTER(WCHAR)\nLPWIN32_FIND_DATAA = PWIN32_FIND_DATAA = ctypes.POINTER(WIN32_FIND_DATAA)\nLPWIN32_FIND_DATAW = PWIN32_FIND_DATAW = ctypes.POINTER(WIN32_FIND_DATAW)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LPSIZEL",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LPSIZEL = PSIZEL = ctypes.POINTER(SIZEL)\nPSMALL_RECT = ctypes.POINTER(SMALL_RECT)\nLPUINT = PUINT = ctypes.POINTER(UINT)\nPULARGE_INTEGER = ctypes.POINTER(ULARGE_INTEGER)\nPULONG = ctypes.POINTER(ULONG)\nPUSHORT = ctypes.POINTER(USHORT)\nPWCHAR = ctypes.POINTER(WCHAR)\nLPWIN32_FIND_DATAA = PWIN32_FIND_DATAA = ctypes.POINTER(WIN32_FIND_DATAA)\nLPWIN32_FIND_DATAW = PWIN32_FIND_DATAW = ctypes.POINTER(WIN32_FIND_DATAW)\nLPWORD = PWORD = ctypes.POINTER(WORD)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "PSMALL_RECT",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "PSMALL_RECT = ctypes.POINTER(SMALL_RECT)\nLPUINT = PUINT = ctypes.POINTER(UINT)\nPULARGE_INTEGER = ctypes.POINTER(ULARGE_INTEGER)\nPULONG = ctypes.POINTER(ULONG)\nPUSHORT = ctypes.POINTER(USHORT)\nPWCHAR = ctypes.POINTER(WCHAR)\nLPWIN32_FIND_DATAA = PWIN32_FIND_DATAA = ctypes.POINTER(WIN32_FIND_DATAA)\nLPWIN32_FIND_DATAW = PWIN32_FIND_DATAW = ctypes.POINTER(WIN32_FIND_DATAW)\nLPWORD = PWORD = ctypes.POINTER(WORD)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LPUINT",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LPUINT = PUINT = ctypes.POINTER(UINT)\nPULARGE_INTEGER = ctypes.POINTER(ULARGE_INTEGER)\nPULONG = ctypes.POINTER(ULONG)\nPUSHORT = ctypes.POINTER(USHORT)\nPWCHAR = ctypes.POINTER(WCHAR)\nLPWIN32_FIND_DATAA = PWIN32_FIND_DATAA = ctypes.POINTER(WIN32_FIND_DATAA)\nLPWIN32_FIND_DATAW = PWIN32_FIND_DATAW = ctypes.POINTER(WIN32_FIND_DATAW)\nLPWORD = PWORD = ctypes.POINTER(WORD)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "PULARGE_INTEGER",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "PULARGE_INTEGER = ctypes.POINTER(ULARGE_INTEGER)\nPULONG = ctypes.POINTER(ULONG)\nPUSHORT = ctypes.POINTER(USHORT)\nPWCHAR = ctypes.POINTER(WCHAR)\nLPWIN32_FIND_DATAA = PWIN32_FIND_DATAA = ctypes.POINTER(WIN32_FIND_DATAA)\nLPWIN32_FIND_DATAW = PWIN32_FIND_DATAW = ctypes.POINTER(WIN32_FIND_DATAW)\nLPWORD = PWORD = ctypes.POINTER(WORD)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "PULONG",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "PULONG = ctypes.POINTER(ULONG)\nPUSHORT = ctypes.POINTER(USHORT)\nPWCHAR = ctypes.POINTER(WCHAR)\nLPWIN32_FIND_DATAA = PWIN32_FIND_DATAA = ctypes.POINTER(WIN32_FIND_DATAA)\nLPWIN32_FIND_DATAW = PWIN32_FIND_DATAW = ctypes.POINTER(WIN32_FIND_DATAW)\nLPWORD = PWORD = ctypes.POINTER(WORD)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "PUSHORT",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "PUSHORT = ctypes.POINTER(USHORT)\nPWCHAR = ctypes.POINTER(WCHAR)\nLPWIN32_FIND_DATAA = PWIN32_FIND_DATAA = ctypes.POINTER(WIN32_FIND_DATAA)\nLPWIN32_FIND_DATAW = PWIN32_FIND_DATAW = ctypes.POINTER(WIN32_FIND_DATAW)\nLPWORD = PWORD = ctypes.POINTER(WORD)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "PWCHAR",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "PWCHAR = ctypes.POINTER(WCHAR)\nLPWIN32_FIND_DATAA = PWIN32_FIND_DATAA = ctypes.POINTER(WIN32_FIND_DATAA)\nLPWIN32_FIND_DATAW = PWIN32_FIND_DATAW = ctypes.POINTER(WIN32_FIND_DATAW)\nLPWORD = PWORD = ctypes.POINTER(WORD)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LPWIN32_FIND_DATAA",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LPWIN32_FIND_DATAA = PWIN32_FIND_DATAA = ctypes.POINTER(WIN32_FIND_DATAA)\nLPWIN32_FIND_DATAW = PWIN32_FIND_DATAW = ctypes.POINTER(WIN32_FIND_DATAW)\nLPWORD = PWORD = ctypes.POINTER(WORD)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LPWIN32_FIND_DATAW",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LPWIN32_FIND_DATAW = PWIN32_FIND_DATAW = ctypes.POINTER(WIN32_FIND_DATAW)\nLPWORD = PWORD = ctypes.POINTER(WORD)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LPWORD",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes.wintypes",
        "description": "protobuf.Lib.ctypes.wintypes",
        "peekOfCode": "LPWORD = PWORD = ctypes.POINTER(WORD)",
        "detail": "protobuf.Lib.ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "get_ld_header",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes._aix",
        "description": "protobuf.Lib.ctypes._aix",
        "peekOfCode": "def get_ld_header(p):\n    # \"nested-function, but placed at module level\n    ld_header = None\n    for line in p.stdout:\n        if line.startswith(('/', './', '../')):\n            ld_header = line\n        elif \"INDEX\" in line:\n            return ld_header.rstrip('\\n')\n    return None\ndef get_ld_header_info(p):",
        "detail": "protobuf.Lib.ctypes._aix",
        "documentation": {}
    },
    {
        "label": "get_ld_header_info",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes._aix",
        "description": "protobuf.Lib.ctypes._aix",
        "peekOfCode": "def get_ld_header_info(p):\n    # \"nested-function, but placed at module level\n    # as an ld_header was found, return known paths, archives and members\n    # these lines start with a digit\n    info = []\n    for line in p.stdout:\n        if re.match(\"[0-9]\", line):\n            info.append(line)\n        else:\n            # blank line (separator), consume line and end for loop",
        "detail": "protobuf.Lib.ctypes._aix",
        "documentation": {}
    },
    {
        "label": "get_ld_headers",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes._aix",
        "description": "protobuf.Lib.ctypes._aix",
        "peekOfCode": "def get_ld_headers(file):\n    \"\"\"\n    Parse the header of the loader section of executable and archives\n    This function calls /usr/bin/dump -H as a subprocess\n    and returns a list of (ld_header, ld_header_info) tuples.\n    \"\"\"\n    # get_ld_headers parsing:\n    # 1. Find a line that starts with /, ./, or ../ - set as ld_header\n    # 2. If \"INDEX\" in occurs in a following line - return ld_header\n    # 3. get info (lines starting with [0-9])",
        "detail": "protobuf.Lib.ctypes._aix",
        "documentation": {}
    },
    {
        "label": "get_shared",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes._aix",
        "description": "protobuf.Lib.ctypes._aix",
        "peekOfCode": "def get_shared(ld_headers):\n    \"\"\"\n    extract the shareable objects from ld_headers\n    character \"[\" is used to strip off the path information.\n    Note: the \"[\" and \"]\" characters that are part of dump -H output\n    are not removed here.\n    \"\"\"\n    shared = []\n    for (line, _) in ld_headers:\n        # potential member lines contain \"[\"",
        "detail": "protobuf.Lib.ctypes._aix",
        "documentation": {}
    },
    {
        "label": "get_one_match",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes._aix",
        "description": "protobuf.Lib.ctypes._aix",
        "peekOfCode": "def get_one_match(expr, lines):\n    \"\"\"\n    Must be only one match, otherwise result is None.\n    When there is a match, strip leading \"[\" and trailing \"]\"\n    \"\"\"\n    # member names in the ld_headers output are between square brackets\n    expr = rf'\\[({expr})\\]'\n    matches = list(filter(None, (re.search(expr, line) for line in lines)))\n    if len(matches) == 1:\n        return matches[0].group(1)",
        "detail": "protobuf.Lib.ctypes._aix",
        "documentation": {}
    },
    {
        "label": "get_legacy",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes._aix",
        "description": "protobuf.Lib.ctypes._aix",
        "peekOfCode": "def get_legacy(members):\n    \"\"\"\n    This routine provides historical aka legacy naming schemes started\n    in AIX4 shared library support for library members names.\n    e.g., in /usr/lib/libc.a the member name shr.o for 32-bit binary and\n    shr_64.o for 64-bit binary.\n    \"\"\"\n    if AIX_ABI == 64:\n        # AIX 64-bit member is one of shr64.o, shr_64.o, or shr4_64.o\n        expr = r'shr4?_?64\\.o'",
        "detail": "protobuf.Lib.ctypes._aix",
        "documentation": {}
    },
    {
        "label": "get_version",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes._aix",
        "description": "protobuf.Lib.ctypes._aix",
        "peekOfCode": "def get_version(name, members):\n    \"\"\"\n    Sort list of members and return highest numbered version - if it exists.\n    This function is called when an unversioned libFOO.a(libFOO.so) has\n    not been found.\n    Versioning for the member name is expected to follow\n    GNU LIBTOOL conventions: the highest version (x, then X.y, then X.Y.z)\n     * find [libFoo.so.X]\n     * find [libFoo.so.X.Y]\n     * find [libFoo.so.X.Y.Z]",
        "detail": "protobuf.Lib.ctypes._aix",
        "documentation": {}
    },
    {
        "label": "get_member",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes._aix",
        "description": "protobuf.Lib.ctypes._aix",
        "peekOfCode": "def get_member(name, members):\n    \"\"\"\n    Return an archive member matching the request in name.\n    Name is the library name without any prefix like lib, suffix like .so,\n    or version number.\n    Given a list of members find and return the most appropriate result\n    Priority is given to generic libXXX.so, then a versioned libXXX.so.a.b.c\n    and finally, legacy AIX naming scheme.\n    \"\"\"\n    # look first for a generic match - prepend lib and append .so",
        "detail": "protobuf.Lib.ctypes._aix",
        "documentation": {}
    },
    {
        "label": "get_libpaths",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes._aix",
        "description": "protobuf.Lib.ctypes._aix",
        "peekOfCode": "def get_libpaths():\n    \"\"\"\n    On AIX, the buildtime searchpath is stored in the executable.\n    as \"loader header information\".\n    The command /usr/bin/dump -H extracts this info.\n    Prefix searched libraries with LD_LIBRARY_PATH (preferred),\n    or LIBPATH if defined. These paths are appended to the paths\n    to libraries the python executable is linked with.\n    This mimics AIX dlopen() behavior.\n    \"\"\"",
        "detail": "protobuf.Lib.ctypes._aix",
        "documentation": {}
    },
    {
        "label": "find_shared",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes._aix",
        "description": "protobuf.Lib.ctypes._aix",
        "peekOfCode": "def find_shared(paths, name):\n    \"\"\"\n    paths is a list of directories to search for an archive.\n    name is the abbreviated name given to find_library().\n    Process: search \"paths\" for archive, and if an archive is found\n    return the result of get_member().\n    If an archive is not found then return None\n    \"\"\"\n    for dir in paths:\n        # /lib is a symbolic link to /usr/lib, skip it",
        "detail": "protobuf.Lib.ctypes._aix",
        "documentation": {}
    },
    {
        "label": "find_library",
        "kind": 2,
        "importPath": "protobuf.Lib.ctypes._aix",
        "description": "protobuf.Lib.ctypes._aix",
        "peekOfCode": "def find_library(name):\n    \"\"\"AIX implementation of ctypes.util.find_library()\n    Find an archive member that will dlopen(). If not available,\n    also search for a file (or link) with a .so suffix.\n    AIX supports two types of schemes that can be used with dlopen().\n    The so-called SystemV Release4 (svr4) format is commonly suffixed\n    with .so while the (default) AIX scheme has the library (archive)\n    ending with the suffix .a\n    As an archive has multiple members (e.g., 32-bit and 64-bit) in one file\n    the argument passed to dlopen must include both the library and",
        "detail": "protobuf.Lib.ctypes._aix",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes._aix",
        "description": "protobuf.Lib.ctypes._aix",
        "peekOfCode": "__author__ = \"Michael Felt <aixtools@felt.demon.nl>\"\nimport re\nfrom os import environ, path\nfrom sys import executable\nfrom ctypes import c_void_p, sizeof\nfrom subprocess import Popen, PIPE, DEVNULL\n# Executable bit size - 32 or 64\n# Used to filter the search in an archive by size, e.g., -X64\nAIX_ABI = sizeof(c_void_p) * 8\nfrom sys import maxsize",
        "detail": "protobuf.Lib.ctypes._aix",
        "documentation": {}
    },
    {
        "label": "AIX_ABI",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes._aix",
        "description": "protobuf.Lib.ctypes._aix",
        "peekOfCode": "AIX_ABI = sizeof(c_void_p) * 8\nfrom sys import maxsize\ndef _last_version(libnames, sep):\n    def _num_version(libname):\n        # \"libxyz.so.MAJOR.MINOR\" => [MAJOR, MINOR]\n        parts = libname.split(sep)\n        nums = []\n        try:\n            while parts:\n                nums.insert(0, int(parts.pop()))",
        "detail": "protobuf.Lib.ctypes._aix",
        "documentation": {}
    },
    {
        "label": "_swapped_meta",
        "kind": 6,
        "importPath": "protobuf.Lib.ctypes._endian",
        "description": "protobuf.Lib.ctypes._endian",
        "peekOfCode": "class _swapped_meta(type(Structure)):\n    def __setattr__(self, attrname, value):\n        if attrname == \"_fields_\":\n            fields = []\n            for desc in value:\n                name = desc[0]\n                typ = desc[1]\n                rest = desc[2:]\n                fields.append((name, _other_endian(typ)) + rest)\n            value = fields",
        "detail": "protobuf.Lib.ctypes._endian",
        "documentation": {}
    },
    {
        "label": "_array_type",
        "kind": 5,
        "importPath": "protobuf.Lib.ctypes._endian",
        "description": "protobuf.Lib.ctypes._endian",
        "peekOfCode": "_array_type = type(Array)\ndef _other_endian(typ):\n    \"\"\"Return the type with the 'other' byte order.  Simple types like\n    c_int and so on already have __ctype_be__ and __ctype_le__\n    attributes which contain the types, for more complicated types\n    arrays and structures are supported.\n    \"\"\"\n    # check _OTHER_ENDIAN attribute (present if typ is primitive type)\n    if hasattr(typ, _OTHER_ENDIAN):\n        return getattr(typ, _OTHER_ENDIAN)",
        "detail": "protobuf.Lib.ctypes._endian",
        "documentation": {}
    },
    {
        "label": "isalnum",
        "kind": 2,
        "importPath": "protobuf.Lib.curses.ascii",
        "description": "protobuf.Lib.curses.ascii",
        "peekOfCode": "def isalnum(c): return isalpha(c) or isdigit(c)\ndef isalpha(c): return isupper(c) or islower(c)\ndef isascii(c): return 0 <= _ctoi(c) <= 127          # ?\ndef isblank(c): return _ctoi(c) in (9, 32)\ndef iscntrl(c): return 0 <= _ctoi(c) <= 31 or _ctoi(c) == 127\ndef isdigit(c): return 48 <= _ctoi(c) <= 57\ndef isgraph(c): return 33 <= _ctoi(c) <= 126\ndef islower(c): return 97 <= _ctoi(c) <= 122\ndef isprint(c): return 32 <= _ctoi(c) <= 126\ndef ispunct(c): return isgraph(c) and not isalnum(c)",
        "detail": "protobuf.Lib.curses.ascii",
        "documentation": {}
    },
    {
        "label": "isalpha",
        "kind": 2,
        "importPath": "protobuf.Lib.curses.ascii",
        "description": "protobuf.Lib.curses.ascii",
        "peekOfCode": "def isalpha(c): return isupper(c) or islower(c)\ndef isascii(c): return 0 <= _ctoi(c) <= 127          # ?\ndef isblank(c): return _ctoi(c) in (9, 32)\ndef iscntrl(c): return 0 <= _ctoi(c) <= 31 or _ctoi(c) == 127\ndef isdigit(c): return 48 <= _ctoi(c) <= 57\ndef isgraph(c): return 33 <= _ctoi(c) <= 126\ndef islower(c): return 97 <= _ctoi(c) <= 122\ndef isprint(c): return 32 <= _ctoi(c) <= 126\ndef ispunct(c): return isgraph(c) and not isalnum(c)\ndef isspace(c): return _ctoi(c) in (9, 10, 11, 12, 13, 32)",
        "detail": "protobuf.Lib.curses.ascii",
        "documentation": {}
    },
    {
        "label": "isascii",
        "kind": 2,
        "importPath": "protobuf.Lib.curses.ascii",
        "description": "protobuf.Lib.curses.ascii",
        "peekOfCode": "def isascii(c): return 0 <= _ctoi(c) <= 127          # ?\ndef isblank(c): return _ctoi(c) in (9, 32)\ndef iscntrl(c): return 0 <= _ctoi(c) <= 31 or _ctoi(c) == 127\ndef isdigit(c): return 48 <= _ctoi(c) <= 57\ndef isgraph(c): return 33 <= _ctoi(c) <= 126\ndef islower(c): return 97 <= _ctoi(c) <= 122\ndef isprint(c): return 32 <= _ctoi(c) <= 126\ndef ispunct(c): return isgraph(c) and not isalnum(c)\ndef isspace(c): return _ctoi(c) in (9, 10, 11, 12, 13, 32)\ndef isupper(c): return 65 <= _ctoi(c) <= 90",
        "detail": "protobuf.Lib.curses.ascii",
        "documentation": {}
    },
    {
        "label": "isblank",
        "kind": 2,
        "importPath": "protobuf.Lib.curses.ascii",
        "description": "protobuf.Lib.curses.ascii",
        "peekOfCode": "def isblank(c): return _ctoi(c) in (9, 32)\ndef iscntrl(c): return 0 <= _ctoi(c) <= 31 or _ctoi(c) == 127\ndef isdigit(c): return 48 <= _ctoi(c) <= 57\ndef isgraph(c): return 33 <= _ctoi(c) <= 126\ndef islower(c): return 97 <= _ctoi(c) <= 122\ndef isprint(c): return 32 <= _ctoi(c) <= 126\ndef ispunct(c): return isgraph(c) and not isalnum(c)\ndef isspace(c): return _ctoi(c) in (9, 10, 11, 12, 13, 32)\ndef isupper(c): return 65 <= _ctoi(c) <= 90\ndef isxdigit(c): return isdigit(c) or \\",
        "detail": "protobuf.Lib.curses.ascii",
        "documentation": {}
    },
    {
        "label": "iscntrl",
        "kind": 2,
        "importPath": "protobuf.Lib.curses.ascii",
        "description": "protobuf.Lib.curses.ascii",
        "peekOfCode": "def iscntrl(c): return 0 <= _ctoi(c) <= 31 or _ctoi(c) == 127\ndef isdigit(c): return 48 <= _ctoi(c) <= 57\ndef isgraph(c): return 33 <= _ctoi(c) <= 126\ndef islower(c): return 97 <= _ctoi(c) <= 122\ndef isprint(c): return 32 <= _ctoi(c) <= 126\ndef ispunct(c): return isgraph(c) and not isalnum(c)\ndef isspace(c): return _ctoi(c) in (9, 10, 11, 12, 13, 32)\ndef isupper(c): return 65 <= _ctoi(c) <= 90\ndef isxdigit(c): return isdigit(c) or \\\n    (65 <= _ctoi(c) <= 70) or (97 <= _ctoi(c) <= 102)",
        "detail": "protobuf.Lib.curses.ascii",
        "documentation": {}
    },
    {
        "label": "isdigit",
        "kind": 2,
        "importPath": "protobuf.Lib.curses.ascii",
        "description": "protobuf.Lib.curses.ascii",
        "peekOfCode": "def isdigit(c): return 48 <= _ctoi(c) <= 57\ndef isgraph(c): return 33 <= _ctoi(c) <= 126\ndef islower(c): return 97 <= _ctoi(c) <= 122\ndef isprint(c): return 32 <= _ctoi(c) <= 126\ndef ispunct(c): return isgraph(c) and not isalnum(c)\ndef isspace(c): return _ctoi(c) in (9, 10, 11, 12, 13, 32)\ndef isupper(c): return 65 <= _ctoi(c) <= 90\ndef isxdigit(c): return isdigit(c) or \\\n    (65 <= _ctoi(c) <= 70) or (97 <= _ctoi(c) <= 102)\ndef isctrl(c): return 0 <= _ctoi(c) < 32",
        "detail": "protobuf.Lib.curses.ascii",
        "documentation": {}
    },
    {
        "label": "isgraph",
        "kind": 2,
        "importPath": "protobuf.Lib.curses.ascii",
        "description": "protobuf.Lib.curses.ascii",
        "peekOfCode": "def isgraph(c): return 33 <= _ctoi(c) <= 126\ndef islower(c): return 97 <= _ctoi(c) <= 122\ndef isprint(c): return 32 <= _ctoi(c) <= 126\ndef ispunct(c): return isgraph(c) and not isalnum(c)\ndef isspace(c): return _ctoi(c) in (9, 10, 11, 12, 13, 32)\ndef isupper(c): return 65 <= _ctoi(c) <= 90\ndef isxdigit(c): return isdigit(c) or \\\n    (65 <= _ctoi(c) <= 70) or (97 <= _ctoi(c) <= 102)\ndef isctrl(c): return 0 <= _ctoi(c) < 32\ndef ismeta(c): return _ctoi(c) > 127",
        "detail": "protobuf.Lib.curses.ascii",
        "documentation": {}
    },
    {
        "label": "islower",
        "kind": 2,
        "importPath": "protobuf.Lib.curses.ascii",
        "description": "protobuf.Lib.curses.ascii",
        "peekOfCode": "def islower(c): return 97 <= _ctoi(c) <= 122\ndef isprint(c): return 32 <= _ctoi(c) <= 126\ndef ispunct(c): return isgraph(c) and not isalnum(c)\ndef isspace(c): return _ctoi(c) in (9, 10, 11, 12, 13, 32)\ndef isupper(c): return 65 <= _ctoi(c) <= 90\ndef isxdigit(c): return isdigit(c) or \\\n    (65 <= _ctoi(c) <= 70) or (97 <= _ctoi(c) <= 102)\ndef isctrl(c): return 0 <= _ctoi(c) < 32\ndef ismeta(c): return _ctoi(c) > 127\ndef ascii(c):",
        "detail": "protobuf.Lib.curses.ascii",
        "documentation": {}
    },
    {
        "label": "isprint",
        "kind": 2,
        "importPath": "protobuf.Lib.curses.ascii",
        "description": "protobuf.Lib.curses.ascii",
        "peekOfCode": "def isprint(c): return 32 <= _ctoi(c) <= 126\ndef ispunct(c): return isgraph(c) and not isalnum(c)\ndef isspace(c): return _ctoi(c) in (9, 10, 11, 12, 13, 32)\ndef isupper(c): return 65 <= _ctoi(c) <= 90\ndef isxdigit(c): return isdigit(c) or \\\n    (65 <= _ctoi(c) <= 70) or (97 <= _ctoi(c) <= 102)\ndef isctrl(c): return 0 <= _ctoi(c) < 32\ndef ismeta(c): return _ctoi(c) > 127\ndef ascii(c):\n    if type(c) == type(\"\"):",
        "detail": "protobuf.Lib.curses.ascii",
        "documentation": {}
    },
    {
        "label": "ispunct",
        "kind": 2,
        "importPath": "protobuf.Lib.curses.ascii",
        "description": "protobuf.Lib.curses.ascii",
        "peekOfCode": "def ispunct(c): return isgraph(c) and not isalnum(c)\ndef isspace(c): return _ctoi(c) in (9, 10, 11, 12, 13, 32)\ndef isupper(c): return 65 <= _ctoi(c) <= 90\ndef isxdigit(c): return isdigit(c) or \\\n    (65 <= _ctoi(c) <= 70) or (97 <= _ctoi(c) <= 102)\ndef isctrl(c): return 0 <= _ctoi(c) < 32\ndef ismeta(c): return _ctoi(c) > 127\ndef ascii(c):\n    if type(c) == type(\"\"):\n        return chr(_ctoi(c) & 0x7f)",
        "detail": "protobuf.Lib.curses.ascii",
        "documentation": {}
    },
    {
        "label": "isspace",
        "kind": 2,
        "importPath": "protobuf.Lib.curses.ascii",
        "description": "protobuf.Lib.curses.ascii",
        "peekOfCode": "def isspace(c): return _ctoi(c) in (9, 10, 11, 12, 13, 32)\ndef isupper(c): return 65 <= _ctoi(c) <= 90\ndef isxdigit(c): return isdigit(c) or \\\n    (65 <= _ctoi(c) <= 70) or (97 <= _ctoi(c) <= 102)\ndef isctrl(c): return 0 <= _ctoi(c) < 32\ndef ismeta(c): return _ctoi(c) > 127\ndef ascii(c):\n    if type(c) == type(\"\"):\n        return chr(_ctoi(c) & 0x7f)\n    else:",
        "detail": "protobuf.Lib.curses.ascii",
        "documentation": {}
    },
    {
        "label": "isupper",
        "kind": 2,
        "importPath": "protobuf.Lib.curses.ascii",
        "description": "protobuf.Lib.curses.ascii",
        "peekOfCode": "def isupper(c): return 65 <= _ctoi(c) <= 90\ndef isxdigit(c): return isdigit(c) or \\\n    (65 <= _ctoi(c) <= 70) or (97 <= _ctoi(c) <= 102)\ndef isctrl(c): return 0 <= _ctoi(c) < 32\ndef ismeta(c): return _ctoi(c) > 127\ndef ascii(c):\n    if type(c) == type(\"\"):\n        return chr(_ctoi(c) & 0x7f)\n    else:\n        return _ctoi(c) & 0x7f",
        "detail": "protobuf.Lib.curses.ascii",
        "documentation": {}
    },
    {
        "label": "isxdigit",
        "kind": 2,
        "importPath": "protobuf.Lib.curses.ascii",
        "description": "protobuf.Lib.curses.ascii",
        "peekOfCode": "def isxdigit(c): return isdigit(c) or \\\n    (65 <= _ctoi(c) <= 70) or (97 <= _ctoi(c) <= 102)\ndef isctrl(c): return 0 <= _ctoi(c) < 32\ndef ismeta(c): return _ctoi(c) > 127\ndef ascii(c):\n    if type(c) == type(\"\"):\n        return chr(_ctoi(c) & 0x7f)\n    else:\n        return _ctoi(c) & 0x7f\ndef ctrl(c):",
        "detail": "protobuf.Lib.curses.ascii",
        "documentation": {}
    },
    {
        "label": "isctrl",
        "kind": 2,
        "importPath": "protobuf.Lib.curses.ascii",
        "description": "protobuf.Lib.curses.ascii",
        "peekOfCode": "def isctrl(c): return 0 <= _ctoi(c) < 32\ndef ismeta(c): return _ctoi(c) > 127\ndef ascii(c):\n    if type(c) == type(\"\"):\n        return chr(_ctoi(c) & 0x7f)\n    else:\n        return _ctoi(c) & 0x7f\ndef ctrl(c):\n    if type(c) == type(\"\"):\n        return chr(_ctoi(c) & 0x1f)",
        "detail": "protobuf.Lib.curses.ascii",
        "documentation": {}
    },
    {
        "label": "ismeta",
        "kind": 2,
        "importPath": "protobuf.Lib.curses.ascii",
        "description": "protobuf.Lib.curses.ascii",
        "peekOfCode": "def ismeta(c): return _ctoi(c) > 127\ndef ascii(c):\n    if type(c) == type(\"\"):\n        return chr(_ctoi(c) & 0x7f)\n    else:\n        return _ctoi(c) & 0x7f\ndef ctrl(c):\n    if type(c) == type(\"\"):\n        return chr(_ctoi(c) & 0x1f)\n    else:",
        "detail": "protobuf.Lib.curses.ascii",
        "documentation": {}
    },
    {
        "label": "ascii",
        "kind": 2,
        "importPath": "protobuf.Lib.curses.ascii",
        "description": "protobuf.Lib.curses.ascii",
        "peekOfCode": "def ascii(c):\n    if type(c) == type(\"\"):\n        return chr(_ctoi(c) & 0x7f)\n    else:\n        return _ctoi(c) & 0x7f\ndef ctrl(c):\n    if type(c) == type(\"\"):\n        return chr(_ctoi(c) & 0x1f)\n    else:\n        return _ctoi(c) & 0x1f",
        "detail": "protobuf.Lib.curses.ascii",
        "documentation": {}
    },
    {
        "label": "ctrl",
        "kind": 2,
        "importPath": "protobuf.Lib.curses.ascii",
        "description": "protobuf.Lib.curses.ascii",
        "peekOfCode": "def ctrl(c):\n    if type(c) == type(\"\"):\n        return chr(_ctoi(c) & 0x1f)\n    else:\n        return _ctoi(c) & 0x1f\ndef alt(c):\n    if type(c) == type(\"\"):\n        return chr(_ctoi(c) | 0x80)\n    else:\n        return _ctoi(c) | 0x80",
        "detail": "protobuf.Lib.curses.ascii",
        "documentation": {}
    },
    {
        "label": "alt",
        "kind": 2,
        "importPath": "protobuf.Lib.curses.ascii",
        "description": "protobuf.Lib.curses.ascii",
        "peekOfCode": "def alt(c):\n    if type(c) == type(\"\"):\n        return chr(_ctoi(c) | 0x80)\n    else:\n        return _ctoi(c) | 0x80\ndef unctrl(c):\n    bits = _ctoi(c)\n    if bits == 0x7f:\n        rep = \"^?\"\n    elif isprint(bits & 0x7f):",
        "detail": "protobuf.Lib.curses.ascii",
        "documentation": {}
    },
    {
        "label": "unctrl",
        "kind": 2,
        "importPath": "protobuf.Lib.curses.ascii",
        "description": "protobuf.Lib.curses.ascii",
        "peekOfCode": "def unctrl(c):\n    bits = _ctoi(c)\n    if bits == 0x7f:\n        rep = \"^?\"\n    elif isprint(bits & 0x7f):\n        rep = chr(bits & 0x7f)\n    else:\n        rep = \"^\" + chr(((bits & 0x7f) | 0x20) + 0x20)\n    if bits & 0x80:\n        return \"!\" + rep",
        "detail": "protobuf.Lib.curses.ascii",
        "documentation": {}
    },
    {
        "label": "controlnames",
        "kind": 5,
        "importPath": "protobuf.Lib.curses.ascii",
        "description": "protobuf.Lib.curses.ascii",
        "peekOfCode": "controlnames = [\n\"NUL\", \"SOH\", \"STX\", \"ETX\", \"EOT\", \"ENQ\", \"ACK\", \"BEL\",\n\"BS\",  \"HT\",  \"LF\",  \"VT\",  \"FF\",  \"CR\",  \"SO\",  \"SI\",\n\"DLE\", \"DC1\", \"DC2\", \"DC3\", \"DC4\", \"NAK\", \"SYN\", \"ETB\",\n\"CAN\", \"EM\",  \"SUB\", \"ESC\", \"FS\",  \"GS\",  \"RS\",  \"US\",\n\"SP\"\n]\ndef _ctoi(c):\n    if type(c) == type(\"\"):\n        return ord(c)",
        "detail": "protobuf.Lib.curses.ascii",
        "documentation": {}
    },
    {
        "label": "has_key",
        "kind": 2,
        "importPath": "protobuf.Lib.curses.has_key",
        "description": "protobuf.Lib.curses.has_key",
        "peekOfCode": "def has_key(ch):\n    if isinstance(ch, str):\n        ch = ord(ch)\n    # Figure out the correct capability name for the keycode.\n    capability_name = _capability_names.get(ch)\n    if capability_name is None:\n        return False\n    #Check the current terminal description for that capability;\n    #if present, return true, else return false.\n    if _curses.tigetstr( capability_name ):",
        "detail": "protobuf.Lib.curses.has_key",
        "documentation": {}
    },
    {
        "label": "_capability_names",
        "kind": 5,
        "importPath": "protobuf.Lib.curses.has_key",
        "description": "protobuf.Lib.curses.has_key",
        "peekOfCode": "_capability_names = {\n    _curses.KEY_A1: 'ka1',\n    _curses.KEY_A3: 'ka3',\n    _curses.KEY_B2: 'kb2',\n    _curses.KEY_BACKSPACE: 'kbs',\n    _curses.KEY_BEG: 'kbeg',\n    _curses.KEY_BTAB: 'kcbt',\n    _curses.KEY_C1: 'kc1',\n    _curses.KEY_C3: 'kc3',\n    _curses.KEY_CANCEL: 'kcan',",
        "detail": "protobuf.Lib.curses.has_key",
        "documentation": {}
    },
    {
        "label": "Textbox",
        "kind": 6,
        "importPath": "protobuf.Lib.curses.textpad",
        "description": "protobuf.Lib.curses.textpad",
        "peekOfCode": "class Textbox:\n    \"\"\"Editing widget using the interior of a window object.\n     Supports the following Emacs-like key bindings:\n    Ctrl-A      Go to left edge of window.\n    Ctrl-B      Cursor left, wrapping to previous line if appropriate.\n    Ctrl-D      Delete character under cursor.\n    Ctrl-E      Go to right edge (stripspaces off) or end of line (stripspaces on).\n    Ctrl-F      Cursor right, wrapping to next line when appropriate.\n    Ctrl-G      Terminate, returning the window contents.\n    Ctrl-H      Delete character backward.",
        "detail": "protobuf.Lib.curses.textpad",
        "documentation": {}
    },
    {
        "label": "rectangle",
        "kind": 2,
        "importPath": "protobuf.Lib.curses.textpad",
        "description": "protobuf.Lib.curses.textpad",
        "peekOfCode": "def rectangle(win, uly, ulx, lry, lrx):\n    \"\"\"Draw a rectangle with corners at the provided upper-left\n    and lower-right coordinates.\n    \"\"\"\n    win.vline(uly+1, ulx, curses.ACS_VLINE, lry - uly - 1)\n    win.hline(uly, ulx+1, curses.ACS_HLINE, lrx - ulx - 1)\n    win.hline(lry, ulx+1, curses.ACS_HLINE, lrx - ulx - 1)\n    win.vline(uly+1, lrx, curses.ACS_VLINE, lry - uly - 1)\n    win.addch(uly, ulx, curses.ACS_ULCORNER)\n    win.addch(uly, lrx, curses.ACS_URCORNER)",
        "detail": "protobuf.Lib.curses.textpad",
        "documentation": {}
    },
    {
        "label": "_Database",
        "kind": 6,
        "importPath": "protobuf.Lib.dbm.dumb",
        "description": "protobuf.Lib.dbm.dumb",
        "peekOfCode": "class _Database(collections.abc.MutableMapping):\n    # The on-disk directory and data files can remain in mutually\n    # inconsistent states for an arbitrarily long time (see comments\n    # at the end of __setitem__).  This is only repaired when _commit()\n    # gets called.  One place _commit() gets called is from __del__(),\n    # and if that occurs at program shutdown time, module globals may\n    # already have gotten rebound to None.  Since it's crucial that\n    # _commit() finish successfully, we can't ignore shutdown races\n    # here, and _commit() must not reference any globals.\n    _os = _os       # for _commit()",
        "detail": "protobuf.Lib.dbm.dumb",
        "documentation": {}
    },
    {
        "label": "open",
        "kind": 2,
        "importPath": "protobuf.Lib.dbm.dumb",
        "description": "protobuf.Lib.dbm.dumb",
        "peekOfCode": "def open(file, flag='c', mode=0o666):\n    \"\"\"Open the database file, filename, and return corresponding object.\n    The flag argument, used to control how the database is opened in the\n    other DBM implementations, supports only the semantics of 'c' and 'n'\n    values.  Other values will default to the semantics of 'c' value:\n    the database will always opened for update and will be created if it\n    does not exist.\n    The optional mode argument is the UNIX mode of the file, used only when\n    the database has to be created.  It defaults to octal code 0o666 (and\n    will be modified by the prevailing umask).",
        "detail": "protobuf.Lib.dbm.dumb",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.dbm.dumb",
        "description": "protobuf.Lib.dbm.dumb",
        "peekOfCode": "__all__ = [\"error\", \"open\"]\n_BLOCKSIZE = 512\nerror = OSError\nclass _Database(collections.abc.MutableMapping):\n    # The on-disk directory and data files can remain in mutually\n    # inconsistent states for an arbitrarily long time (see comments\n    # at the end of __setitem__).  This is only repaired when _commit()\n    # gets called.  One place _commit() gets called is from __del__(),\n    # and if that occurs at program shutdown time, module globals may\n    # already have gotten rebound to None.  Since it's crucial that",
        "detail": "protobuf.Lib.dbm.dumb",
        "documentation": {}
    },
    {
        "label": "_BLOCKSIZE",
        "kind": 5,
        "importPath": "protobuf.Lib.dbm.dumb",
        "description": "protobuf.Lib.dbm.dumb",
        "peekOfCode": "_BLOCKSIZE = 512\nerror = OSError\nclass _Database(collections.abc.MutableMapping):\n    # The on-disk directory and data files can remain in mutually\n    # inconsistent states for an arbitrarily long time (see comments\n    # at the end of __setitem__).  This is only repaired when _commit()\n    # gets called.  One place _commit() gets called is from __del__(),\n    # and if that occurs at program shutdown time, module globals may\n    # already have gotten rebound to None.  Since it's crucial that\n    # _commit() finish successfully, we can't ignore shutdown races",
        "detail": "protobuf.Lib.dbm.dumb",
        "documentation": {}
    },
    {
        "label": "error",
        "kind": 5,
        "importPath": "protobuf.Lib.dbm.dumb",
        "description": "protobuf.Lib.dbm.dumb",
        "peekOfCode": "error = OSError\nclass _Database(collections.abc.MutableMapping):\n    # The on-disk directory and data files can remain in mutually\n    # inconsistent states for an arbitrarily long time (see comments\n    # at the end of __setitem__).  This is only repaired when _commit()\n    # gets called.  One place _commit() gets called is from __del__(),\n    # and if that occurs at program shutdown time, module globals may\n    # already have gotten rebound to None.  Since it's crucial that\n    # _commit() finish successfully, we can't ignore shutdown races\n    # here, and _commit() must not reference any globals.",
        "detail": "protobuf.Lib.dbm.dumb",
        "documentation": {}
    },
    {
        "label": "bdist",
        "kind": 6,
        "importPath": "protobuf.Lib.distutils.command.bdist",
        "description": "protobuf.Lib.distutils.command.bdist",
        "peekOfCode": "class bdist(Command):\n    description = \"create a built (binary) distribution\"\n    user_options = [('bdist-base=', 'b',\n                     \"temporary directory for creating built distributions\"),\n                    ('plat-name=', 'p',\n                     \"platform name to embed in generated filenames \"\n                     \"(default: %s)\" % get_platform()),\n                    ('formats=', None,\n                     \"formats for distribution (comma-separated list)\"),\n                    ('dist-dir=', 'd',",
        "detail": "protobuf.Lib.distutils.command.bdist",
        "documentation": {}
    },
    {
        "label": "show_formats",
        "kind": 2,
        "importPath": "protobuf.Lib.distutils.command.bdist",
        "description": "protobuf.Lib.distutils.command.bdist",
        "peekOfCode": "def show_formats():\n    \"\"\"Print list of available formats (arguments to \"--format\" option).\n    \"\"\"\n    from distutils.fancy_getopt import FancyGetopt\n    formats = []\n    for format in bdist.format_commands:\n        formats.append((\"formats=\" + format, None,\n                        bdist.format_command[format][1]))\n    pretty_printer = FancyGetopt(formats)\n    pretty_printer.print_help(\"List of available distribution formats:\")",
        "detail": "protobuf.Lib.distutils.command.bdist",
        "documentation": {}
    },
    {
        "label": "bdist_dumb",
        "kind": 6,
        "importPath": "protobuf.Lib.distutils.command.bdist_dumb",
        "description": "protobuf.Lib.distutils.command.bdist_dumb",
        "peekOfCode": "class bdist_dumb(Command):\n    description = \"create a \\\"dumb\\\" built distribution\"\n    user_options = [('bdist-dir=', 'd',\n                     \"temporary directory for creating the distribution\"),\n                    ('plat-name=', 'p',\n                     \"platform name to embed in generated filenames \"\n                     \"(default: %s)\" % get_platform()),\n                    ('format=', 'f',\n                     \"archive format to create (tar, gztar, bztar, xztar, \"\n                     \"ztar, zip)\"),",
        "detail": "protobuf.Lib.distutils.command.bdist_dumb",
        "documentation": {}
    },
    {
        "label": "PyDialog",
        "kind": 6,
        "importPath": "protobuf.Lib.distutils.command.bdist_msi",
        "description": "protobuf.Lib.distutils.command.bdist_msi",
        "peekOfCode": "class PyDialog(Dialog):\n    \"\"\"Dialog class with a fixed layout: controls at the top, then a ruler,\n    then a list of buttons: back, next, cancel. Optionally a bitmap at the\n    left.\"\"\"\n    def __init__(self, *args, **kw):\n        \"\"\"Dialog(database, name, x, y, w, h, attributes, title, first,\n        default, cancel, bitmap=true)\"\"\"\n        Dialog.__init__(self, *args)\n        ruler = self.h - 36\n        bmwidth = 152*ruler/328",
        "detail": "protobuf.Lib.distutils.command.bdist_msi",
        "documentation": {}
    },
    {
        "label": "bdist_msi",
        "kind": 6,
        "importPath": "protobuf.Lib.distutils.command.bdist_msi",
        "description": "protobuf.Lib.distutils.command.bdist_msi",
        "peekOfCode": "class bdist_msi(Command):\n    description = \"create a Microsoft Installer (.msi) binary distribution\"\n    user_options = [('bdist-dir=', None,\n                     \"temporary directory for creating the distribution\"),\n                    ('plat-name=', 'p',\n                     \"platform name to embed in generated filenames \"\n                     \"(default: %s)\" % get_platform()),\n                    ('keep-temp', 'k',\n                     \"keep the pseudo-installation tree around after \" +\n                     \"creating the distribution archive\"),",
        "detail": "protobuf.Lib.distutils.command.bdist_msi",
        "documentation": {}
    },
    {
        "label": "bdist_rpm",
        "kind": 6,
        "importPath": "protobuf.Lib.distutils.command.bdist_rpm",
        "description": "protobuf.Lib.distutils.command.bdist_rpm",
        "peekOfCode": "class bdist_rpm(Command):\n    description = \"create an RPM distribution\"\n    user_options = [\n        ('bdist-base=', None,\n         \"base directory for creating built distributions\"),\n        ('rpm-base=', None,\n         \"base directory for creating RPMs (defaults to \\\"rpm\\\" under \"\n         \"--bdist-base; must be specified for RPM 2)\"),\n        ('dist-dir=', 'd',\n         \"directory to put final RPM files in \"",
        "detail": "protobuf.Lib.distutils.command.bdist_rpm",
        "documentation": {}
    },
    {
        "label": "build",
        "kind": 6,
        "importPath": "protobuf.Lib.distutils.command.build",
        "description": "protobuf.Lib.distutils.command.build",
        "peekOfCode": "class build(Command):\n    description = \"build everything needed to install\"\n    user_options = [\n        ('build-base=', 'b',\n         \"base directory for build library\"),\n        ('build-purelib=', None,\n         \"build directory for platform-neutral distributions\"),\n        ('build-platlib=', None,\n         \"build directory for platform-specific distributions\"),\n        ('build-lib=', None,",
        "detail": "protobuf.Lib.distutils.command.build",
        "documentation": {}
    },
    {
        "label": "show_compilers",
        "kind": 2,
        "importPath": "protobuf.Lib.distutils.command.build",
        "description": "protobuf.Lib.distutils.command.build",
        "peekOfCode": "def show_compilers():\n    from distutils.ccompiler import show_compilers\n    show_compilers()\nclass build(Command):\n    description = \"build everything needed to install\"\n    user_options = [\n        ('build-base=', 'b',\n         \"base directory for build library\"),\n        ('build-purelib=', None,\n         \"build directory for platform-neutral distributions\"),",
        "detail": "protobuf.Lib.distutils.command.build",
        "documentation": {}
    },
    {
        "label": "build_clib",
        "kind": 6,
        "importPath": "protobuf.Lib.distutils.command.build_clib",
        "description": "protobuf.Lib.distutils.command.build_clib",
        "peekOfCode": "class build_clib(Command):\n    description = \"build C/C++ libraries used by Python extensions\"\n    user_options = [\n        ('build-clib=', 'b',\n         \"directory to build C/C++ libraries to\"),\n        ('build-temp=', 't',\n         \"directory to put temporary build by-products\"),\n        ('debug', 'g',\n         \"compile with debugging information\"),\n        ('force', 'f',",
        "detail": "protobuf.Lib.distutils.command.build_clib",
        "documentation": {}
    },
    {
        "label": "show_compilers",
        "kind": 2,
        "importPath": "protobuf.Lib.distutils.command.build_clib",
        "description": "protobuf.Lib.distutils.command.build_clib",
        "peekOfCode": "def show_compilers():\n    from distutils.ccompiler import show_compilers\n    show_compilers()\nclass build_clib(Command):\n    description = \"build C/C++ libraries used by Python extensions\"\n    user_options = [\n        ('build-clib=', 'b',\n         \"directory to build C/C++ libraries to\"),\n        ('build-temp=', 't',\n         \"directory to put temporary build by-products\"),",
        "detail": "protobuf.Lib.distutils.command.build_clib",
        "documentation": {}
    },
    {
        "label": "build_ext",
        "kind": 6,
        "importPath": "protobuf.Lib.distutils.command.build_ext",
        "description": "protobuf.Lib.distutils.command.build_ext",
        "peekOfCode": "class build_ext(Command):\n    description = \"build C/C++ extensions (compile/link to build directory)\"\n    # XXX thoughts on how to deal with complex command-line options like\n    # these, i.e. how to make it so fancy_getopt can suck them off the\n    # command line and make it look like setup.py defined the appropriate\n    # lists of tuples of what-have-you.\n    #   - each command needs a callback to process its command-line options\n    #   - Command.__init__() needs access to its share of the whole\n    #     command line (must ultimately come from\n    #     Distribution.parse_command_line())",
        "detail": "protobuf.Lib.distutils.command.build_ext",
        "documentation": {}
    },
    {
        "label": "show_compiler",
        "kind": 2,
        "importPath": "protobuf.Lib.distutils.command.build_ext",
        "description": "protobuf.Lib.distutils.command.build_ext",
        "peekOfCode": "def show_compilers ():\n    from distutils.ccompiler import show_compilers\n    show_compilers()\nclass build_ext(Command):\n    description = \"build C/C++ extensions (compile/link to build directory)\"\n    # XXX thoughts on how to deal with complex command-line options like\n    # these, i.e. how to make it so fancy_getopt can suck them off the\n    # command line and make it look like setup.py defined the appropriate\n    # lists of tuples of what-have-you.\n    #   - each command needs a callback to process its command-line options",
        "detail": "protobuf.Lib.distutils.command.build_ext",
        "documentation": {}
    },
    {
        "label": "extension_name_re",
        "kind": 5,
        "importPath": "protobuf.Lib.distutils.command.build_ext",
        "description": "protobuf.Lib.distutils.command.build_ext",
        "peekOfCode": "extension_name_re = re.compile \\\n    (r'^[a-zA-Z_][a-zA-Z_0-9]*(\\.[a-zA-Z_][a-zA-Z_0-9]*)*$')\ndef show_compilers ():\n    from distutils.ccompiler import show_compilers\n    show_compilers()\nclass build_ext(Command):\n    description = \"build C/C++ extensions (compile/link to build directory)\"\n    # XXX thoughts on how to deal with complex command-line options like\n    # these, i.e. how to make it so fancy_getopt can suck them off the\n    # command line and make it look like setup.py defined the appropriate",
        "detail": "protobuf.Lib.distutils.command.build_ext",
        "documentation": {}
    },
    {
        "label": "build_p",
        "kind": 6,
        "importPath": "protobuf.Lib.distutils.command.build_py",
        "description": "protobuf.Lib.distutils.command.build_py",
        "peekOfCode": "class build_py (Command):\n    description = \"\\\"build\\\" pure Python modules (copy to build directory)\"\n    user_options = [\n        ('build-lib=', 'd', \"directory to \\\"build\\\" (copy) to\"),\n        ('compile', 'c', \"compile .py to .pyc\"),\n        ('no-compile', None, \"don't compile .py files [default]\"),\n        ('optimize=', 'O',\n         \"also compile with optimization: -O1 for \\\"python -O\\\", \"\n         \"-O2 for \\\"python -OO\\\", and -O0 to disable [default: -O0]\"),\n        ('force', 'f', \"forcibly build everything (ignore file timestamps)\"),",
        "detail": "protobuf.Lib.distutils.command.build_py",
        "documentation": {}
    },
    {
        "label": "build_py_2to3",
        "kind": 6,
        "importPath": "protobuf.Lib.distutils.command.build_py",
        "description": "protobuf.Lib.distutils.command.build_py",
        "peekOfCode": "class build_py_2to3(build_py, Mixin2to3):\n    def run(self):\n        self.updated_files = []\n        # Base class code\n        if self.py_modules:\n            self.build_modules()\n        if self.packages:\n            self.build_packages()\n            self.build_package_data()\n        # 2to3",
        "detail": "protobuf.Lib.distutils.command.build_py",
        "documentation": {}
    },
    {
        "label": "build_scripts",
        "kind": 6,
        "importPath": "protobuf.Lib.distutils.command.build_scripts",
        "description": "protobuf.Lib.distutils.command.build_scripts",
        "peekOfCode": "class build_scripts(Command):\n    description = \"\\\"build\\\" scripts (copy and fixup #! line)\"\n    user_options = [\n        ('build-dir=', 'd', \"directory to \\\"build\\\" (copy) to\"),\n        ('force', 'f', \"forcibly build everything (ignore file timestamps\"),\n        ('executable=', 'e', \"specify final destination interpreter path\"),\n        ]\n    boolean_options = ['force']\n    def initialize_options(self):\n        self.build_dir = None",
        "detail": "protobuf.Lib.distutils.command.build_scripts",
        "documentation": {}
    },
    {
        "label": "build_scripts_2to3",
        "kind": 6,
        "importPath": "protobuf.Lib.distutils.command.build_scripts",
        "description": "protobuf.Lib.distutils.command.build_scripts",
        "peekOfCode": "class build_scripts_2to3(build_scripts, Mixin2to3):\n    def copy_scripts(self):\n        outfiles, updated_files = build_scripts.copy_scripts(self)\n        if not self.dry_run:\n            self.run_2to3(updated_files)\n        return outfiles, updated_files",
        "detail": "protobuf.Lib.distutils.command.build_scripts",
        "documentation": {}
    },
    {
        "label": "first_line_re",
        "kind": 5,
        "importPath": "protobuf.Lib.distutils.command.build_scripts",
        "description": "protobuf.Lib.distutils.command.build_scripts",
        "peekOfCode": "first_line_re = re.compile(b'^#!.*python[0-9.]*([ \\t].*)?$')\nclass build_scripts(Command):\n    description = \"\\\"build\\\" scripts (copy and fixup #! line)\"\n    user_options = [\n        ('build-dir=', 'd', \"directory to \\\"build\\\" (copy) to\"),\n        ('force', 'f', \"forcibly build everything (ignore file timestamps\"),\n        ('executable=', 'e', \"specify final destination interpreter path\"),\n        ]\n    boolean_options = ['force']\n    def initialize_options(self):",
        "detail": "protobuf.Lib.distutils.command.build_scripts",
        "documentation": {}
    },
    {
        "label": "check",
        "kind": 6,
        "importPath": "protobuf.Lib.distutils.command.check",
        "description": "protobuf.Lib.distutils.command.check",
        "peekOfCode": "class check(Command):\n    \"\"\"This command checks the meta-data of the package.\n    \"\"\"\n    description = (\"perform some checks on the package\")\n    user_options = [('metadata', 'm', 'Verify meta-data'),\n                    ('restructuredtext', 'r',\n                     ('Checks if long string meta-data syntax '\n                      'are reStructuredText-compliant')),\n                    ('strict', 's',\n                     'Will exit with an error if a check fails')]",
        "detail": "protobuf.Lib.distutils.command.check",
        "documentation": {}
    },
    {
        "label": "clean",
        "kind": 6,
        "importPath": "protobuf.Lib.distutils.command.clean",
        "description": "protobuf.Lib.distutils.command.clean",
        "peekOfCode": "class clean(Command):\n    description = \"clean up temporary files from 'build' command\"\n    user_options = [\n        ('build-base=', 'b',\n         \"base build directory (default: 'build.build-base')\"),\n        ('build-lib=', None,\n         \"build directory for all modules (default: 'build.build-lib')\"),\n        ('build-temp=', 't',\n         \"temporary build directory (default: 'build.build-temp')\"),\n        ('build-scripts=', None,",
        "detail": "protobuf.Lib.distutils.command.clean",
        "documentation": {}
    },
    {
        "label": "make_tarball",
        "kind": 2,
        "importPath": "protobuf.Lib.distutils.archive_util",
        "description": "protobuf.Lib.distutils.archive_util",
        "peekOfCode": "def make_tarball(base_name, base_dir, compress=\"gzip\", verbose=0, dry_run=0,\n                 owner=None, group=None):\n    \"\"\"Create a (possibly compressed) tar file from all the files under\n    'base_dir'.\n    'compress' must be \"gzip\" (the default), \"bzip2\", \"xz\", \"compress\", or\n    None.  (\"compress\" will be deprecated in Python 3.2)\n    'owner' and 'group' can be used to define an owner and a group for the\n    archive that is being built. If not provided, the current owner and group\n    will be used.\n    The output tar file will be named 'base_dir' +  \".tar\", possibly plus",
        "detail": "protobuf.Lib.distutils.archive_util",
        "documentation": {}
    },
    {
        "label": "make_zipfile",
        "kind": 2,
        "importPath": "protobuf.Lib.distutils.archive_util",
        "description": "protobuf.Lib.distutils.archive_util",
        "peekOfCode": "def make_zipfile(base_name, base_dir, verbose=0, dry_run=0):\n    \"\"\"Create a zip file from all the files under 'base_dir'.\n    The output zip file will be named 'base_name' + \".zip\".  Uses either the\n    \"zipfile\" Python module (if available) or the InfoZIP \"zip\" utility\n    (if installed and found on the default search path).  If neither tool is\n    available, raises DistutilsExecError.  Returns the name of the output zip\n    file.\n    \"\"\"\n    zip_filename = base_name + \".zip\"\n    mkpath(os.path.dirname(zip_filename), dry_run=dry_run)",
        "detail": "protobuf.Lib.distutils.archive_util",
        "documentation": {}
    },
    {
        "label": "check_archive_formats",
        "kind": 2,
        "importPath": "protobuf.Lib.distutils.archive_util",
        "description": "protobuf.Lib.distutils.archive_util",
        "peekOfCode": "def check_archive_formats(formats):\n    \"\"\"Returns the first format from the 'format' list that is unknown.\n    If all formats are known, returns None\n    \"\"\"\n    for format in formats:\n        if format not in ARCHIVE_FORMATS:\n            return format\n    return None\ndef make_archive(base_name, format, root_dir=None, base_dir=None, verbose=0,\n                 dry_run=0, owner=None, group=None):",
        "detail": "protobuf.Lib.distutils.archive_util",
        "documentation": {}
    },
    {
        "label": "make_archive",
        "kind": 2,
        "importPath": "protobuf.Lib.distutils.archive_util",
        "description": "protobuf.Lib.distutils.archive_util",
        "peekOfCode": "def make_archive(base_name, format, root_dir=None, base_dir=None, verbose=0,\n                 dry_run=0, owner=None, group=None):\n    \"\"\"Create an archive file (eg. zip or tar).\n    'base_name' is the name of the file to create, minus any format-specific\n    extension; 'format' is the archive format: one of \"zip\", \"tar\", \"gztar\",\n    \"bztar\", \"xztar\", or \"ztar\".\n    'root_dir' is a directory that will be the root directory of the\n    archive; ie. we typically chdir into 'root_dir' before creating the\n    archive.  'base_dir' is the directory where we start archiving from;\n    ie. 'base_dir' will be the common prefix of all files and",
        "detail": "protobuf.Lib.distutils.archive_util",
        "documentation": {}
    },
    {
        "label": "ARCHIVE_FORMATS",
        "kind": 5,
        "importPath": "protobuf.Lib.distutils.archive_util",
        "description": "protobuf.Lib.distutils.archive_util",
        "peekOfCode": "ARCHIVE_FORMATS = {\n    'gztar': (make_tarball, [('compress', 'gzip')], \"gzip'ed tar-file\"),\n    'bztar': (make_tarball, [('compress', 'bzip2')], \"bzip2'ed tar-file\"),\n    'xztar': (make_tarball, [('compress', 'xz')], \"xz'ed tar-file\"),\n    'ztar':  (make_tarball, [('compress', 'compress')], \"compressed tar file\"),\n    'tar':   (make_tarball, [('compress', None)], \"uncompressed tar file\"),\n    'zip':   (make_zipfile, [],\"ZIP file\")\n    }\ndef check_archive_formats(formats):\n    \"\"\"Returns the first format from the 'format' list that is unknown.",
        "detail": "protobuf.Lib.distutils.archive_util",
        "documentation": {}
    },
    {
        "label": "BCPPCompiler",
        "kind": 6,
        "importPath": "protobuf.Lib.distutils.bcppcompiler",
        "description": "protobuf.Lib.distutils.bcppcompiler",
        "peekOfCode": "class BCPPCompiler(CCompiler) :\n    \"\"\"Concrete class that implements an interface to the Borland C/C++\n    compiler, as defined by the CCompiler abstract class.\n    \"\"\"\n    compiler_type = 'bcpp'\n    # Just set this so CCompiler's constructor doesn't barf.  We currently\n    # don't use the 'set_executables()' bureaucracy provided by CCompiler,\n    # as it really isn't necessary for this sort of single-compiler class.\n    # Would be nice to have a consistent interface with UnixCCompiler,\n    # though, so it's worth thinking about.",
        "detail": "protobuf.Lib.distutils.bcppcompiler",
        "documentation": {}
    },
    {
        "label": "CCompiler",
        "kind": 6,
        "importPath": "protobuf.Lib.distutils.ccompiler",
        "description": "protobuf.Lib.distutils.ccompiler",
        "peekOfCode": "class CCompiler:\n    \"\"\"Abstract base class to define the interface that must be implemented\n    by real compiler classes.  Also has some utility methods used by\n    several compiler classes.\n    The basic idea behind a compiler abstraction class is that each\n    instance can be used for all the compile/link steps in building a\n    single project.  Thus, attributes common to all of those compile and\n    link steps -- include directories, macros to define, libraries to link\n    against, etc. -- are attributes of the compiler instance.  To allow for\n    variability in how individual files are treated, most of those",
        "detail": "protobuf.Lib.distutils.ccompiler",
        "documentation": {}
    },
    {
        "label": "get_default_compiler",
        "kind": 2,
        "importPath": "protobuf.Lib.distutils.ccompiler",
        "description": "protobuf.Lib.distutils.ccompiler",
        "peekOfCode": "def get_default_compiler(osname=None, platform=None):\n    \"\"\"Determine the default compiler to use for the given platform.\n       osname should be one of the standard Python OS names (i.e. the\n       ones returned by os.name) and platform the common value\n       returned by sys.platform for the platform in question.\n       The default values are os.name and sys.platform in case the\n       parameters are not given.\n    \"\"\"\n    if osname is None:\n        osname = os.name",
        "detail": "protobuf.Lib.distutils.ccompiler",
        "documentation": {}
    },
    {
        "label": "show_compilers",
        "kind": 2,
        "importPath": "protobuf.Lib.distutils.ccompiler",
        "description": "protobuf.Lib.distutils.ccompiler",
        "peekOfCode": "def show_compilers():\n    \"\"\"Print list of available compilers (used by the \"--help-compiler\"\n    options to \"build\", \"build_ext\", \"build_clib\").\n    \"\"\"\n    # XXX this \"knows\" that the compiler option it's describing is\n    # \"--compiler\", which just happens to be the case for the three\n    # commands that use it.\n    from distutils.fancy_getopt import FancyGetopt\n    compilers = []\n    for compiler in compiler_class.keys():",
        "detail": "protobuf.Lib.distutils.ccompiler",
        "documentation": {}
    },
    {
        "label": "new_compiler",
        "kind": 2,
        "importPath": "protobuf.Lib.distutils.ccompiler",
        "description": "protobuf.Lib.distutils.ccompiler",
        "peekOfCode": "def new_compiler(plat=None, compiler=None, verbose=0, dry_run=0, force=0):\n    \"\"\"Generate an instance of some CCompiler subclass for the supplied\n    platform/compiler combination.  'plat' defaults to 'os.name'\n    (eg. 'posix', 'nt'), and 'compiler' defaults to the default compiler\n    for that platform.  Currently only 'posix' and 'nt' are supported, and\n    the default compilers are \"traditional Unix interface\" (UnixCCompiler\n    class) and Visual C++ (MSVCCompiler class).  Note that it's perfectly\n    possible to ask for a Unix compiler object under Windows, and a\n    Microsoft compiler object under Unix -- if you supply a value for\n    'compiler', 'plat' is ignored.",
        "detail": "protobuf.Lib.distutils.ccompiler",
        "documentation": {}
    },
    {
        "label": "gen_preprocess_options",
        "kind": 2,
        "importPath": "protobuf.Lib.distutils.ccompiler",
        "description": "protobuf.Lib.distutils.ccompiler",
        "peekOfCode": "def gen_preprocess_options(macros, include_dirs):\n    \"\"\"Generate C pre-processor options (-D, -U, -I) as used by at least\n    two types of compilers: the typical Unix compiler and Visual C++.\n    'macros' is the usual thing, a list of 1- or 2-tuples, where (name,)\n    means undefine (-U) macro 'name', and (name,value) means define (-D)\n    macro 'name' to 'value'.  'include_dirs' is just a list of directory\n    names to be added to the header file search path (-I).  Returns a list\n    of command-line options suitable for either Unix compilers or Visual\n    C++.\n    \"\"\"",
        "detail": "protobuf.Lib.distutils.ccompiler",
        "documentation": {}
    },
    {
        "label": "gen_lib_option",
        "kind": 2,
        "importPath": "protobuf.Lib.distutils.ccompiler",
        "description": "protobuf.Lib.distutils.ccompiler",
        "peekOfCode": "def gen_lib_options (compiler, library_dirs, runtime_library_dirs, libraries):\n    \"\"\"Generate linker options for searching library directories and\n    linking with specific libraries.  'libraries' and 'library_dirs' are,\n    respectively, lists of library names (not filenames!) and search\n    directories.  Returns a list of command-line options suitable for use\n    with some compiler (depending on the two format strings passed in).\n    \"\"\"\n    lib_opts = []\n    for dir in library_dirs:\n        lib_opts.append(compiler.library_dir_option(dir))",
        "detail": "protobuf.Lib.distutils.ccompiler",
        "documentation": {}
    },
    {
        "label": "_default_compilers",
        "kind": 5,
        "importPath": "protobuf.Lib.distutils.ccompiler",
        "description": "protobuf.Lib.distutils.ccompiler",
        "peekOfCode": "_default_compilers = (\n    # Platform string mappings\n    # on a cygwin built python we can use gcc like an ordinary UNIXish\n    # compiler\n    ('cygwin.*', 'unix'),\n    # OS name mappings\n    ('posix', 'unix'),\n    ('nt', 'msvc'),\n    )\ndef get_default_compiler(osname=None, platform=None):",
        "detail": "protobuf.Lib.distutils.ccompiler",
        "documentation": {}
    },
    {
        "label": "compiler_class",
        "kind": 5,
        "importPath": "protobuf.Lib.distutils.ccompiler",
        "description": "protobuf.Lib.distutils.ccompiler",
        "peekOfCode": "compiler_class = { 'unix':    ('unixccompiler', 'UnixCCompiler',\n                               \"standard UNIX-style compiler\"),\n                   'msvc':    ('_msvccompiler', 'MSVCCompiler',\n                               \"Microsoft Visual C++\"),\n                   'cygwin':  ('cygwinccompiler', 'CygwinCCompiler',\n                               \"Cygwin port of GNU C Compiler for Win32\"),\n                   'mingw32': ('cygwinccompiler', 'Mingw32CCompiler',\n                               \"Mingw32 port of GNU C Compiler for Win32\"),\n                   'bcpp':    ('bcppcompiler', 'BCPPCompiler',\n                               \"Borland C++ Compiler\"),",
        "detail": "protobuf.Lib.distutils.ccompiler",
        "documentation": {}
    },
    {
        "label": "Command",
        "kind": 6,
        "importPath": "protobuf.Lib.distutils.cmd",
        "description": "protobuf.Lib.distutils.cmd",
        "peekOfCode": "class Command:\n    \"\"\"Abstract base class for defining command classes, the \"worker bees\"\n    of the Distutils.  A useful analogy for command classes is to think of\n    them as subroutines with local variables called \"options\".  The options\n    are \"declared\" in 'initialize_options()' and \"defined\" (given their\n    final values, aka \"finalized\") in 'finalize_options()', both of which\n    must be defined by every command class.  The distinction between the\n    two is necessary because option values might come from the outside\n    world (command line, config file, ...), and any options dependent on\n    other options must be computed *after* these outside influences have",
        "detail": "protobuf.Lib.distutils.cmd",
        "documentation": {}
    },
    {
        "label": "MSVCCompiler",
        "kind": 6,
        "importPath": "protobuf.Lib.distutils._msvccompiler",
        "description": "protobuf.Lib.distutils._msvccompiler",
        "peekOfCode": "class MSVCCompiler(CCompiler) :\n    \"\"\"Concrete class that implements an interface to Microsoft Visual C++,\n       as defined by the CCompiler abstract class.\"\"\"\n    compiler_type = 'msvc'\n    # Just set this so CCompiler's constructor doesn't barf.  We currently\n    # don't use the 'set_executables()' bureaucracy provided by CCompiler,\n    # as it really isn't necessary for this sort of single-compiler class.\n    # Would be nice to have a consistent interface with UnixCCompiler,\n    # though, so it's worth thinking about.\n    executables = {}",
        "detail": "protobuf.Lib.distutils._msvccompiler",
        "documentation": {}
    },
    {
        "label": "PLAT_SPEC_TO_RUNTIME",
        "kind": 5,
        "importPath": "protobuf.Lib.distutils._msvccompiler",
        "description": "protobuf.Lib.distutils._msvccompiler",
        "peekOfCode": "PLAT_SPEC_TO_RUNTIME = {\n    'x86' : 'x86',\n    'x86_amd64' : 'x64',\n    'x86_arm' : 'arm',\n    'x86_arm64' : 'arm64'\n}\ndef _find_vcvarsall(plat_spec):\n    # bpo-38597: Removed vcruntime return value\n    _, best_dir = _find_vc2017()\n    if not best_dir:",
        "detail": "protobuf.Lib.distutils._msvccompiler",
        "documentation": {}
    },
    {
        "label": "PLAT_TO_VCVARS",
        "kind": 5,
        "importPath": "protobuf.Lib.distutils._msvccompiler",
        "description": "protobuf.Lib.distutils._msvccompiler",
        "peekOfCode": "PLAT_TO_VCVARS = {\n    'win32' : 'x86',\n    'win-amd64' : 'x86_amd64',\n    'win-arm32' : 'x86_arm',\n    'win-arm64' : 'x86_arm64'\n}\nclass MSVCCompiler(CCompiler) :\n    \"\"\"Concrete class that implements an interface to Microsoft Visual C++,\n       as defined by the CCompiler abstract class.\"\"\"\n    compiler_type = 'msvc'",
        "detail": "protobuf.Lib.distutils._msvccompiler",
        "documentation": {}
    },
    {
        "label": "abstractclassmethod",
        "kind": 6,
        "importPath": "protobuf.Lib.abc",
        "description": "protobuf.Lib.abc",
        "peekOfCode": "class abstractclassmethod(classmethod):\n    \"\"\"A decorator indicating abstract classmethods.\n    Deprecated, use 'classmethod' with 'abstractmethod' instead:\n        class C(ABC):\n            @classmethod\n            @abstractmethod\n            def my_abstract_classmethod(cls, ...):\n                ...\n    \"\"\"\n    __isabstractmethod__ = True",
        "detail": "protobuf.Lib.abc",
        "documentation": {}
    },
    {
        "label": "abstractstaticmethod",
        "kind": 6,
        "importPath": "protobuf.Lib.abc",
        "description": "protobuf.Lib.abc",
        "peekOfCode": "class abstractstaticmethod(staticmethod):\n    \"\"\"A decorator indicating abstract staticmethods.\n    Deprecated, use 'staticmethod' with 'abstractmethod' instead:\n        class C(ABC):\n            @staticmethod\n            @abstractmethod\n            def my_abstract_staticmethod(...):\n                ...\n    \"\"\"\n    __isabstractmethod__ = True",
        "detail": "protobuf.Lib.abc",
        "documentation": {}
    },
    {
        "label": "abstractproperty",
        "kind": 6,
        "importPath": "protobuf.Lib.abc",
        "description": "protobuf.Lib.abc",
        "peekOfCode": "class abstractproperty(property):\n    \"\"\"A decorator indicating abstract properties.\n    Deprecated, use 'property' with 'abstractmethod' instead:\n        class C(ABC):\n            @property\n            @abstractmethod\n            def my_abstract_property(self):\n                ...\n    \"\"\"\n    __isabstractmethod__ = True",
        "detail": "protobuf.Lib.abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "kind": 6,
        "importPath": "protobuf.Lib.abc",
        "description": "protobuf.Lib.abc",
        "peekOfCode": "class ABC(metaclass=ABCMeta):\n    \"\"\"Helper class that provides a standard way to create an ABC using\n    inheritance.\n    \"\"\"\n    __slots__ = ()",
        "detail": "protobuf.Lib.abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "kind": 2,
        "importPath": "protobuf.Lib.abc",
        "description": "protobuf.Lib.abc",
        "peekOfCode": "def abstractmethod(funcobj):\n    \"\"\"A decorator indicating abstract methods.\n    Requires that the metaclass is ABCMeta or derived from it.  A\n    class that has a metaclass derived from ABCMeta cannot be\n    instantiated unless all of its abstract methods are overridden.\n    The abstract methods can be called using any of the normal\n    'super' call mechanisms.  abstractmethod() may be used to declare\n    abstract methods for properties and descriptors.\n    Usage:\n        class C(metaclass=ABCMeta):",
        "detail": "protobuf.Lib.abc",
        "documentation": {}
    },
    {
        "label": "update_abstractmethods",
        "kind": 2,
        "importPath": "protobuf.Lib.abc",
        "description": "protobuf.Lib.abc",
        "peekOfCode": "def update_abstractmethods(cls):\n    \"\"\"Recalculate the set of abstract methods of an abstract class.\n    If a class has had one of its abstract methods implemented after the\n    class was created, the method will not be considered implemented until\n    this function is called. Alternatively, if a new abstract method has been\n    added to the class, it will only be considered an abstract method of the\n    class after this function is called.\n    This function should be called before any use is made of the class,\n    usually in class decorators that add methods to the subject class.\n    Returns cls, to allow usage as a class decorator.",
        "detail": "protobuf.Lib.abc",
        "documentation": {}
    },
    {
        "label": "Error",
        "kind": 6,
        "importPath": "protobuf.Lib.aifc",
        "description": "protobuf.Lib.aifc",
        "peekOfCode": "class Error(Exception):\n    pass\n_AIFC_version = 0xA2805140     # Version 1 of AIFF-C\ndef _read_long(file):\n    try:\n        return struct.unpack('>l', file.read(4))[0]\n    except struct.error:\n        raise EOFError from None\ndef _read_ulong(file):\n    try:",
        "detail": "protobuf.Lib.aifc",
        "documentation": {}
    },
    {
        "label": "Aifc_read",
        "kind": 6,
        "importPath": "protobuf.Lib.aifc",
        "description": "protobuf.Lib.aifc",
        "peekOfCode": "class Aifc_read:\n    # Variables used in this class:\n    #\n    # These variables are available to the user though appropriate\n    # methods of this class:\n    # _file -- the open file with methods read(), close(), and seek()\n    #       set through the __init__() method\n    # _nchannels -- the number of audio channels\n    #       available through the getnchannels() method\n    # _nframes -- the number of audio frames",
        "detail": "protobuf.Lib.aifc",
        "documentation": {}
    },
    {
        "label": "Aifc_write",
        "kind": 6,
        "importPath": "protobuf.Lib.aifc",
        "description": "protobuf.Lib.aifc",
        "peekOfCode": "class Aifc_write:\n    # Variables used in this class:\n    #\n    # These variables are user settable through appropriate methods\n    # of this class:\n    # _file -- the open file with methods write(), close(), tell(), seek()\n    #       set through the __init__() method\n    # _comptype -- the AIFF-C compression type ('NONE' in AIFF)\n    #       set through the setcomptype() or setparams() method\n    # _compname -- the human-readable AIFF-C compression type",
        "detail": "protobuf.Lib.aifc",
        "documentation": {}
    },
    {
        "label": "open",
        "kind": 2,
        "importPath": "protobuf.Lib.aifc",
        "description": "protobuf.Lib.aifc",
        "peekOfCode": "def open(f, mode=None):\n    if mode is None:\n        if hasattr(f, 'mode'):\n            mode = f.mode\n        else:\n            mode = 'rb'\n    if mode in ('r', 'rb'):\n        return Aifc_read(f)\n    elif mode in ('w', 'wb'):\n        return Aifc_write(f)",
        "detail": "protobuf.Lib.aifc",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.aifc",
        "description": "protobuf.Lib.aifc",
        "peekOfCode": "__all__ = [\"Error\", \"open\"]\nclass Error(Exception):\n    pass\n_AIFC_version = 0xA2805140     # Version 1 of AIFF-C\ndef _read_long(file):\n    try:\n        return struct.unpack('>l', file.read(4))[0]\n    except struct.error:\n        raise EOFError from None\ndef _read_ulong(file):",
        "detail": "protobuf.Lib.aifc",
        "documentation": {}
    },
    {
        "label": "_AIFC_version",
        "kind": 5,
        "importPath": "protobuf.Lib.aifc",
        "description": "protobuf.Lib.aifc",
        "peekOfCode": "_AIFC_version = 0xA2805140     # Version 1 of AIFF-C\ndef _read_long(file):\n    try:\n        return struct.unpack('>l', file.read(4))[0]\n    except struct.error:\n        raise EOFError from None\ndef _read_ulong(file):\n    try:\n        return struct.unpack('>L', file.read(4))[0]\n    except struct.error:",
        "detail": "protobuf.Lib.aifc",
        "documentation": {}
    },
    {
        "label": "_HUGE_VAL",
        "kind": 5,
        "importPath": "protobuf.Lib.aifc",
        "description": "protobuf.Lib.aifc",
        "peekOfCode": "_HUGE_VAL = 1.79769313486231e+308 # See <limits.h>\ndef _read_float(f): # 10 bytes\n    expon = _read_short(f) # 2 bytes\n    sign = 1\n    if expon < 0:\n        sign = -1\n        expon = expon + 0x8000\n    himant = _read_ulong(f) # 4 bytes\n    lomant = _read_ulong(f) # 4 bytes\n    if expon == himant == lomant == 0:",
        "detail": "protobuf.Lib.aifc",
        "documentation": {}
    },
    {
        "label": "_aifc_params",
        "kind": 5,
        "importPath": "protobuf.Lib.aifc",
        "description": "protobuf.Lib.aifc",
        "peekOfCode": "_aifc_params = namedtuple('_aifc_params',\n                          'nchannels sampwidth framerate nframes comptype compname')\n_aifc_params.nchannels.__doc__ = 'Number of audio channels (1 for mono, 2 for stereo)'\n_aifc_params.sampwidth.__doc__ = 'Sample width in bytes'\n_aifc_params.framerate.__doc__ = 'Sampling frequency'\n_aifc_params.nframes.__doc__ = 'Number of audio frames'\n_aifc_params.comptype.__doc__ = 'Compression type (\"NONE\" for AIFF files)'\n_aifc_params.compname.__doc__ = (\"\"\"\\\nA human-readable version of the compression type\n('not compressed' for AIFF files)\"\"\")",
        "detail": "protobuf.Lib.aifc",
        "documentation": {}
    },
    {
        "label": "_aifc_params.nchannels.__doc__",
        "kind": 5,
        "importPath": "protobuf.Lib.aifc",
        "description": "protobuf.Lib.aifc",
        "peekOfCode": "_aifc_params.nchannels.__doc__ = 'Number of audio channels (1 for mono, 2 for stereo)'\n_aifc_params.sampwidth.__doc__ = 'Sample width in bytes'\n_aifc_params.framerate.__doc__ = 'Sampling frequency'\n_aifc_params.nframes.__doc__ = 'Number of audio frames'\n_aifc_params.comptype.__doc__ = 'Compression type (\"NONE\" for AIFF files)'\n_aifc_params.compname.__doc__ = (\"\"\"\\\nA human-readable version of the compression type\n('not compressed' for AIFF files)\"\"\")\nclass Aifc_read:\n    # Variables used in this class:",
        "detail": "protobuf.Lib.aifc",
        "documentation": {}
    },
    {
        "label": "_aifc_params.sampwidth.__doc__",
        "kind": 5,
        "importPath": "protobuf.Lib.aifc",
        "description": "protobuf.Lib.aifc",
        "peekOfCode": "_aifc_params.sampwidth.__doc__ = 'Sample width in bytes'\n_aifc_params.framerate.__doc__ = 'Sampling frequency'\n_aifc_params.nframes.__doc__ = 'Number of audio frames'\n_aifc_params.comptype.__doc__ = 'Compression type (\"NONE\" for AIFF files)'\n_aifc_params.compname.__doc__ = (\"\"\"\\\nA human-readable version of the compression type\n('not compressed' for AIFF files)\"\"\")\nclass Aifc_read:\n    # Variables used in this class:\n    #",
        "detail": "protobuf.Lib.aifc",
        "documentation": {}
    },
    {
        "label": "_aifc_params.framerate.__doc__",
        "kind": 5,
        "importPath": "protobuf.Lib.aifc",
        "description": "protobuf.Lib.aifc",
        "peekOfCode": "_aifc_params.framerate.__doc__ = 'Sampling frequency'\n_aifc_params.nframes.__doc__ = 'Number of audio frames'\n_aifc_params.comptype.__doc__ = 'Compression type (\"NONE\" for AIFF files)'\n_aifc_params.compname.__doc__ = (\"\"\"\\\nA human-readable version of the compression type\n('not compressed' for AIFF files)\"\"\")\nclass Aifc_read:\n    # Variables used in this class:\n    #\n    # These variables are available to the user though appropriate",
        "detail": "protobuf.Lib.aifc",
        "documentation": {}
    },
    {
        "label": "_aifc_params.nframes.__doc__",
        "kind": 5,
        "importPath": "protobuf.Lib.aifc",
        "description": "protobuf.Lib.aifc",
        "peekOfCode": "_aifc_params.nframes.__doc__ = 'Number of audio frames'\n_aifc_params.comptype.__doc__ = 'Compression type (\"NONE\" for AIFF files)'\n_aifc_params.compname.__doc__ = (\"\"\"\\\nA human-readable version of the compression type\n('not compressed' for AIFF files)\"\"\")\nclass Aifc_read:\n    # Variables used in this class:\n    #\n    # These variables are available to the user though appropriate\n    # methods of this class:",
        "detail": "protobuf.Lib.aifc",
        "documentation": {}
    },
    {
        "label": "_aifc_params.comptype.__doc__",
        "kind": 5,
        "importPath": "protobuf.Lib.aifc",
        "description": "protobuf.Lib.aifc",
        "peekOfCode": "_aifc_params.comptype.__doc__ = 'Compression type (\"NONE\" for AIFF files)'\n_aifc_params.compname.__doc__ = (\"\"\"\\\nA human-readable version of the compression type\n('not compressed' for AIFF files)\"\"\")\nclass Aifc_read:\n    # Variables used in this class:\n    #\n    # These variables are available to the user though appropriate\n    # methods of this class:\n    # _file -- the open file with methods read(), close(), and seek()",
        "detail": "protobuf.Lib.aifc",
        "documentation": {}
    },
    {
        "label": "_aifc_params.compname.__doc__",
        "kind": 5,
        "importPath": "protobuf.Lib.aifc",
        "description": "protobuf.Lib.aifc",
        "peekOfCode": "_aifc_params.compname.__doc__ = (\"\"\"\\\nA human-readable version of the compression type\n('not compressed' for AIFF files)\"\"\")\nclass Aifc_read:\n    # Variables used in this class:\n    #\n    # These variables are available to the user though appropriate\n    # methods of this class:\n    # _file -- the open file with methods read(), close(), and seek()\n    #       set through the __init__() method",
        "detail": "protobuf.Lib.aifc",
        "documentation": {}
    },
    {
        "label": "geohash",
        "kind": 2,
        "importPath": "protobuf.Lib.antigravity",
        "description": "protobuf.Lib.antigravity",
        "peekOfCode": "def geohash(latitude, longitude, datedow):\n    '''Compute geohash() using the Munroe algorithm.\n    >>> geohash(37.421542, -122.085589, b'2005-05-26-10458.68')\n    37.857713 -122.544543\n    '''\n    # https://xkcd.com/426/\n    h = hashlib.md5(datedow, usedforsecurity=False).hexdigest()\n    p, q = [('%f' % float.fromhex('0.' + x)) for x in (h[:16], h[16:32])]\n    print('%d%s %d%s' % (latitude, p[1:], longitude, q[1:]))",
        "detail": "protobuf.Lib.antigravity",
        "documentation": {}
    },
    {
        "label": "_AttributeHolder",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class _AttributeHolder(object):\n    \"\"\"Abstract base class that provides __repr__.\n    The __repr__ method returns a string in the format::\n        ClassName(attr=name, attr=name, ...)\n    The attributes are determined either by a class-level attribute,\n    '_kwarg_names', or by inspecting the instance __dict__.\n    \"\"\"\n    def __repr__(self):\n        type_name = type(self).__name__\n        arg_strings = []",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "HelpFormatter",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class HelpFormatter(object):\n    \"\"\"Formatter for generating usage messages and argument help strings.\n    Only the name of this class is considered a public API. All the methods\n    provided by the class are considered an implementation detail.\n    \"\"\"\n    def __init__(self,\n                 prog,\n                 indent_increment=2,\n                 max_help_position=24,\n                 width=None):",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "RawDescriptionHelpFormatter",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class RawDescriptionHelpFormatter(HelpFormatter):\n    \"\"\"Help message formatter which retains any formatting in descriptions.\n    Only the name of this class is considered a public API. All the methods\n    provided by the class are considered an implementation detail.\n    \"\"\"\n    def _fill_text(self, text, width, indent):\n        return ''.join(indent + line for line in text.splitlines(keepends=True))\nclass RawTextHelpFormatter(RawDescriptionHelpFormatter):\n    \"\"\"Help message formatter which retains formatting of all help text.\n    Only the name of this class is considered a public API. All the methods",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "RawTextHelpFormatter",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class RawTextHelpFormatter(RawDescriptionHelpFormatter):\n    \"\"\"Help message formatter which retains formatting of all help text.\n    Only the name of this class is considered a public API. All the methods\n    provided by the class are considered an implementation detail.\n    \"\"\"\n    def _split_lines(self, text, width):\n        return text.splitlines()\nclass ArgumentDefaultsHelpFormatter(HelpFormatter):\n    \"\"\"Help message formatter which adds default values to argument help.\n    Only the name of this class is considered a public API. All the methods",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentDefaultsHelpFormatter",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class ArgumentDefaultsHelpFormatter(HelpFormatter):\n    \"\"\"Help message formatter which adds default values to argument help.\n    Only the name of this class is considered a public API. All the methods\n    provided by the class are considered an implementation detail.\n    \"\"\"\n    def _get_help_string(self, action):\n        help = action.help\n        if '%(default)' not in action.help:\n            if action.default is not SUPPRESS:\n                defaulting_nargs = [OPTIONAL, ZERO_OR_MORE]",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "MetavarTypeHelpFormatter",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class MetavarTypeHelpFormatter(HelpFormatter):\n    \"\"\"Help message formatter which uses the argument 'type' as the default\n    metavar value (instead of the argument 'dest')\n    Only the name of this class is considered a public API. All the methods\n    provided by the class are considered an implementation detail.\n    \"\"\"\n    def _get_default_metavar_for_optional(self, action):\n        return action.type.__name__\n    def _get_default_metavar_for_positional(self, action):\n        return action.type.__name__",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentError",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class ArgumentError(Exception):\n    \"\"\"An error from creating or using an argument (optional or positional).\n    The string value of this exception is the message, augmented with\n    information about the argument that caused it.\n    \"\"\"\n    def __init__(self, argument, message):\n        self.argument_name = _get_action_name(argument)\n        self.message = message\n    def __str__(self):\n        if self.argument_name is None:",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentTypeError",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class ArgumentTypeError(Exception):\n    \"\"\"An error from trying to convert a command line string to a type.\"\"\"\n    pass\n# ==============\n# Action classes\n# ==============\nclass Action(_AttributeHolder):\n    \"\"\"Information about how to convert command line strings to Python objects.\n    Action objects are used by an ArgumentParser to represent the information\n    needed to parse a single argument from one or more strings from the",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "Action",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class Action(_AttributeHolder):\n    \"\"\"Information about how to convert command line strings to Python objects.\n    Action objects are used by an ArgumentParser to represent the information\n    needed to parse a single argument from one or more strings from the\n    command line. The keyword arguments to the Action constructor are also\n    all attributes of Action instances.\n    Keyword Arguments:\n        - option_strings -- A list of command-line option strings which\n            should be associated with this action.\n        - dest -- The name of the attribute to hold the created object(s)",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "BooleanOptionalAction",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class BooleanOptionalAction(Action):\n    def __init__(self,\n                 option_strings,\n                 dest,\n                 default=None,\n                 type=None,\n                 choices=None,\n                 required=False,\n                 help=None,\n                 metavar=None):",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "_StoreAction",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class _StoreAction(Action):\n    def __init__(self,\n                 option_strings,\n                 dest,\n                 nargs=None,\n                 const=None,\n                 default=None,\n                 type=None,\n                 choices=None,\n                 required=False,",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "_StoreConstAction",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class _StoreConstAction(Action):\n    def __init__(self,\n                 option_strings,\n                 dest,\n                 const,\n                 default=None,\n                 required=False,\n                 help=None,\n                 metavar=None):\n        super(_StoreConstAction, self).__init__(",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "_StoreTrueAction",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class _StoreTrueAction(_StoreConstAction):\n    def __init__(self,\n                 option_strings,\n                 dest,\n                 default=False,\n                 required=False,\n                 help=None):\n        super(_StoreTrueAction, self).__init__(\n            option_strings=option_strings,\n            dest=dest,",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "_StoreFalseAction",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class _StoreFalseAction(_StoreConstAction):\n    def __init__(self,\n                 option_strings,\n                 dest,\n                 default=True,\n                 required=False,\n                 help=None):\n        super(_StoreFalseAction, self).__init__(\n            option_strings=option_strings,\n            dest=dest,",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "_AppendAction",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class _AppendAction(Action):\n    def __init__(self,\n                 option_strings,\n                 dest,\n                 nargs=None,\n                 const=None,\n                 default=None,\n                 type=None,\n                 choices=None,\n                 required=False,",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "_AppendConstAction",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class _AppendConstAction(Action):\n    def __init__(self,\n                 option_strings,\n                 dest,\n                 const,\n                 default=None,\n                 required=False,\n                 help=None,\n                 metavar=None):\n        super(_AppendConstAction, self).__init__(",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "_CountAction",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class _CountAction(Action):\n    def __init__(self,\n                 option_strings,\n                 dest,\n                 default=None,\n                 required=False,\n                 help=None):\n        super(_CountAction, self).__init__(\n            option_strings=option_strings,\n            dest=dest,",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "_HelpAction",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class _HelpAction(Action):\n    def __init__(self,\n                 option_strings,\n                 dest=SUPPRESS,\n                 default=SUPPRESS,\n                 help=None):\n        super(_HelpAction, self).__init__(\n            option_strings=option_strings,\n            dest=dest,\n            default=default,",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "_VersionAction",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class _VersionAction(Action):\n    def __init__(self,\n                 option_strings,\n                 version=None,\n                 dest=SUPPRESS,\n                 default=SUPPRESS,\n                 help=\"show program's version number and exit\"):\n        super(_VersionAction, self).__init__(\n            option_strings=option_strings,\n            dest=dest,",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "_SubParsersAction",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class _SubParsersAction(Action):\n    class _ChoicesPseudoAction(Action):\n        def __init__(self, name, aliases, help):\n            metavar = dest = name\n            if aliases:\n                metavar += ' (%s)' % ', '.join(aliases)\n            sup = super(_SubParsersAction._ChoicesPseudoAction, self)\n            sup.__init__(option_strings=[], dest=dest, help=help,\n                         metavar=metavar)\n    def __init__(self,",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "_ExtendAction",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class _ExtendAction(_AppendAction):\n    def __call__(self, parser, namespace, values, option_string=None):\n        items = getattr(namespace, self.dest, None)\n        items = _copy_items(items)\n        items.extend(values)\n        setattr(namespace, self.dest, items)\n# ==============\n# Type classes\n# ==============\nclass FileType(object):",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "FileType",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class FileType(object):\n    \"\"\"Factory for creating file object types\n    Instances of FileType are typically passed as type= arguments to the\n    ArgumentParser add_argument() method.\n    Keyword Arguments:\n        - mode -- A string indicating how the file is to be opened. Accepts the\n            same values as the builtin open() function.\n        - bufsize -- The file's desired buffer size. Accepts the same values as\n            the builtin open() function.\n        - encoding -- The file's encoding. Accepts the same values as the",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "Namespace",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class Namespace(_AttributeHolder):\n    \"\"\"Simple object for storing attributes.\n    Implements equality by attribute names and values, and provides a simple\n    string representation.\n    \"\"\"\n    def __init__(self, **kwargs):\n        for name in kwargs:\n            setattr(self, name, kwargs[name])\n    def __eq__(self, other):\n        if not isinstance(other, Namespace):",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "_ActionsContainer",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class _ActionsContainer(object):\n    def __init__(self,\n                 description,\n                 prefix_chars,\n                 argument_default,\n                 conflict_handler):\n        super(_ActionsContainer, self).__init__()\n        self.description = description\n        self.argument_default = argument_default\n        self.prefix_chars = prefix_chars",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "_ArgumentGroup",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class _ArgumentGroup(_ActionsContainer):\n    def __init__(self, container, title=None, description=None, **kwargs):\n        # add any missing keyword arguments by checking the container\n        update = kwargs.setdefault\n        update('conflict_handler', container.conflict_handler)\n        update('prefix_chars', container.prefix_chars)\n        update('argument_default', container.argument_default)\n        super_init = super(_ArgumentGroup, self).__init__\n        super_init(description=description, **kwargs)\n        # group attributes",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "_MutuallyExclusiveGroup",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class _MutuallyExclusiveGroup(_ArgumentGroup):\n    def __init__(self, container, required=False):\n        super(_MutuallyExclusiveGroup, self).__init__(container)\n        self.required = required\n        self._container = container\n    def _add_action(self, action):\n        if action.required:\n            msg = _('mutually exclusive arguments must be optional')\n            raise ValueError(msg)\n        action = self._container._add_action(action)",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "kind": 6,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "class ArgumentParser(_AttributeHolder, _ActionsContainer):\n    \"\"\"Object for parsing command line strings into Python objects.\n    Keyword Arguments:\n        - prog -- The name of the program (default:\n            ``os.path.basename(sys.argv[0])``)\n        - usage -- A usage message (default: auto-generated from arguments)\n        - description -- A description of what the program does\n        - epilog -- Text following the argument descriptions\n        - parents -- Parsers whose arguments should be copied into this one\n        - formatter_class -- HelpFormatter class for printing help messages",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "__version__ = '1.1'\n__all__ = [\n    'ArgumentParser',\n    'ArgumentError',\n    'ArgumentTypeError',\n    'BooleanOptionalAction',\n    'FileType',\n    'HelpFormatter',\n    'ArgumentDefaultsHelpFormatter',\n    'RawDescriptionHelpFormatter',",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "__all__ = [\n    'ArgumentParser',\n    'ArgumentError',\n    'ArgumentTypeError',\n    'BooleanOptionalAction',\n    'FileType',\n    'HelpFormatter',\n    'ArgumentDefaultsHelpFormatter',\n    'RawDescriptionHelpFormatter',\n    'RawTextHelpFormatter',",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "SUPPRESS",
        "kind": 5,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "SUPPRESS = '==SUPPRESS=='\nOPTIONAL = '?'\nZERO_OR_MORE = '*'\nONE_OR_MORE = '+'\nPARSER = 'A...'\nREMAINDER = '...'\n_UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args'\n# =============================\n# Utility functions and classes\n# =============================",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "OPTIONAL",
        "kind": 5,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "OPTIONAL = '?'\nZERO_OR_MORE = '*'\nONE_OR_MORE = '+'\nPARSER = 'A...'\nREMAINDER = '...'\n_UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args'\n# =============================\n# Utility functions and classes\n# =============================\nclass _AttributeHolder(object):",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "ZERO_OR_MORE",
        "kind": 5,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "ZERO_OR_MORE = '*'\nONE_OR_MORE = '+'\nPARSER = 'A...'\nREMAINDER = '...'\n_UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args'\n# =============================\n# Utility functions and classes\n# =============================\nclass _AttributeHolder(object):\n    \"\"\"Abstract base class that provides __repr__.",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "ONE_OR_MORE",
        "kind": 5,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "ONE_OR_MORE = '+'\nPARSER = 'A...'\nREMAINDER = '...'\n_UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args'\n# =============================\n# Utility functions and classes\n# =============================\nclass _AttributeHolder(object):\n    \"\"\"Abstract base class that provides __repr__.\n    The __repr__ method returns a string in the format::",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "PARSER",
        "kind": 5,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "PARSER = 'A...'\nREMAINDER = '...'\n_UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args'\n# =============================\n# Utility functions and classes\n# =============================\nclass _AttributeHolder(object):\n    \"\"\"Abstract base class that provides __repr__.\n    The __repr__ method returns a string in the format::\n        ClassName(attr=name, attr=name, ...)",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "REMAINDER",
        "kind": 5,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "REMAINDER = '...'\n_UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args'\n# =============================\n# Utility functions and classes\n# =============================\nclass _AttributeHolder(object):\n    \"\"\"Abstract base class that provides __repr__.\n    The __repr__ method returns a string in the format::\n        ClassName(attr=name, attr=name, ...)\n    The attributes are determined either by a class-level attribute,",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "_UNRECOGNIZED_ARGS_ATTR",
        "kind": 5,
        "importPath": "protobuf.Lib.argparse",
        "description": "protobuf.Lib.argparse",
        "peekOfCode": "_UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args'\n# =============================\n# Utility functions and classes\n# =============================\nclass _AttributeHolder(object):\n    \"\"\"Abstract base class that provides __repr__.\n    The __repr__ method returns a string in the format::\n        ClassName(attr=name, attr=name, ...)\n    The attributes are determined either by a class-level attribute,\n    '_kwarg_names', or by inspecting the instance __dict__.",
        "detail": "protobuf.Lib.argparse",
        "documentation": {}
    },
    {
        "label": "NodeVisitor",
        "kind": 6,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "class NodeVisitor(object):\n    \"\"\"\n    A node visitor base class that walks the abstract syntax tree and calls a\n    visitor function for every node found.  This function may return a value\n    which is forwarded by the `visit` method.\n    This class is meant to be subclassed, with the subclass adding visitor\n    methods.\n    Per default the visitor functions for the nodes are ``'visit_'`` +\n    class name of the node.  So a `TryFinally` node visit function would\n    be `visit_TryFinally`.  This behavior can be changed by overriding",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "NodeTransformer",
        "kind": 6,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "class NodeTransformer(NodeVisitor):\n    \"\"\"\n    A :class:`NodeVisitor` subclass that walks the abstract syntax tree and\n    allows modification of nodes.\n    The `NodeTransformer` will walk the AST and use the return value of the\n    visitor methods to replace or remove the old node.  If the return value of\n    the visitor method is ``None``, the node will be removed from its location,\n    otherwise it is replaced with the return value.  The return value may be the\n    original node in which case no replacement takes place.\n    Here is an example transformer that rewrites all occurrences of name lookups",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "_ABC",
        "kind": 6,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "class _ABC(type):\n    def __init__(cls, *args):\n        cls.__doc__ = \"\"\"Deprecated AST node class. Use ast.Constant instead\"\"\"\n    def __instancecheck__(cls, inst):\n        if not isinstance(inst, Constant):\n            return False\n        if cls in _const_types:\n            try:\n                value = inst.value\n            except AttributeError:",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "Num",
        "kind": 6,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "class Num(Constant, metaclass=_ABC):\n    _fields = ('n',)\n    __new__ = _new\nclass Str(Constant, metaclass=_ABC):\n    _fields = ('s',)\n    __new__ = _new\nclass Bytes(Constant, metaclass=_ABC):\n    _fields = ('s',)\n    __new__ = _new\nclass NameConstant(Constant, metaclass=_ABC):",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "Str",
        "kind": 6,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "class Str(Constant, metaclass=_ABC):\n    _fields = ('s',)\n    __new__ = _new\nclass Bytes(Constant, metaclass=_ABC):\n    _fields = ('s',)\n    __new__ = _new\nclass NameConstant(Constant, metaclass=_ABC):\n    __new__ = _new\nclass Ellipsis(Constant, metaclass=_ABC):\n    _fields = ()",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "Bytes",
        "kind": 6,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "class Bytes(Constant, metaclass=_ABC):\n    _fields = ('s',)\n    __new__ = _new\nclass NameConstant(Constant, metaclass=_ABC):\n    __new__ = _new\nclass Ellipsis(Constant, metaclass=_ABC):\n    _fields = ()\n    def __new__(cls, *args, **kwargs):\n        if cls is Ellipsis:\n            return Constant(..., *args, **kwargs)",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "NameConstant",
        "kind": 6,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "class NameConstant(Constant, metaclass=_ABC):\n    __new__ = _new\nclass Ellipsis(Constant, metaclass=_ABC):\n    _fields = ()\n    def __new__(cls, *args, **kwargs):\n        if cls is Ellipsis:\n            return Constant(..., *args, **kwargs)\n        return Constant.__new__(cls, *args, **kwargs)\n_const_types = {\n    Num: (int, float, complex),",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "Ellipsis",
        "kind": 6,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "class Ellipsis(Constant, metaclass=_ABC):\n    _fields = ()\n    def __new__(cls, *args, **kwargs):\n        if cls is Ellipsis:\n            return Constant(..., *args, **kwargs)\n        return Constant.__new__(cls, *args, **kwargs)\n_const_types = {\n    Num: (int, float, complex),\n    Str: (str,),\n    Bytes: (bytes,),",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "slice",
        "kind": 6,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "class slice(AST):\n    \"\"\"Deprecated AST node class.\"\"\"\nclass Index(slice):\n    \"\"\"Deprecated AST node class. Use the index value directly instead.\"\"\"\n    def __new__(cls, value, **kwargs):\n        return value\nclass ExtSlice(slice):\n    \"\"\"Deprecated AST node class. Use ast.Tuple instead.\"\"\"\n    def __new__(cls, dims=(), **kwargs):\n        return Tuple(list(dims), Load(), **kwargs)",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "Index",
        "kind": 6,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "class Index(slice):\n    \"\"\"Deprecated AST node class. Use the index value directly instead.\"\"\"\n    def __new__(cls, value, **kwargs):\n        return value\nclass ExtSlice(slice):\n    \"\"\"Deprecated AST node class. Use ast.Tuple instead.\"\"\"\n    def __new__(cls, dims=(), **kwargs):\n        return Tuple(list(dims), Load(), **kwargs)\n# If the ast module is loaded more than once, only add deprecated methods once\nif not hasattr(Tuple, 'dims'):",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "ExtSlice",
        "kind": 6,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "class ExtSlice(slice):\n    \"\"\"Deprecated AST node class. Use ast.Tuple instead.\"\"\"\n    def __new__(cls, dims=(), **kwargs):\n        return Tuple(list(dims), Load(), **kwargs)\n# If the ast module is loaded more than once, only add deprecated methods once\nif not hasattr(Tuple, 'dims'):\n    # The following code is for backward compatibility.\n    # It will be removed in future.\n    def _dims_getter(self):\n        \"\"\"Deprecated. Use elts instead.\"\"\"",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "Suite",
        "kind": 6,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "class Suite(mod):\n    \"\"\"Deprecated AST node class.  Unused in Python 3.\"\"\"\nclass AugLoad(expr_context):\n    \"\"\"Deprecated AST node class.  Unused in Python 3.\"\"\"\nclass AugStore(expr_context):\n    \"\"\"Deprecated AST node class.  Unused in Python 3.\"\"\"\nclass Param(expr_context):\n    \"\"\"Deprecated AST node class.  Unused in Python 3.\"\"\"\n# Large float and imaginary literals get turned into infinities in the AST.\n# We unparse those infinities to INFSTR.",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "AugLoad",
        "kind": 6,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "class AugLoad(expr_context):\n    \"\"\"Deprecated AST node class.  Unused in Python 3.\"\"\"\nclass AugStore(expr_context):\n    \"\"\"Deprecated AST node class.  Unused in Python 3.\"\"\"\nclass Param(expr_context):\n    \"\"\"Deprecated AST node class.  Unused in Python 3.\"\"\"\n# Large float and imaginary literals get turned into infinities in the AST.\n# We unparse those infinities to INFSTR.\n_INFSTR = \"1e\" + repr(sys.float_info.max_10_exp + 1)\nclass _Precedence(IntEnum):",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "AugStore",
        "kind": 6,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "class AugStore(expr_context):\n    \"\"\"Deprecated AST node class.  Unused in Python 3.\"\"\"\nclass Param(expr_context):\n    \"\"\"Deprecated AST node class.  Unused in Python 3.\"\"\"\n# Large float and imaginary literals get turned into infinities in the AST.\n# We unparse those infinities to INFSTR.\n_INFSTR = \"1e\" + repr(sys.float_info.max_10_exp + 1)\nclass _Precedence(IntEnum):\n    \"\"\"Precedence table that originated from python grammar.\"\"\"\n    TUPLE = auto()",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "Param",
        "kind": 6,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "class Param(expr_context):\n    \"\"\"Deprecated AST node class.  Unused in Python 3.\"\"\"\n# Large float and imaginary literals get turned into infinities in the AST.\n# We unparse those infinities to INFSTR.\n_INFSTR = \"1e\" + repr(sys.float_info.max_10_exp + 1)\nclass _Precedence(IntEnum):\n    \"\"\"Precedence table that originated from python grammar.\"\"\"\n    TUPLE = auto()\n    YIELD = auto()           # 'yield', 'yield from'\n    TEST = auto()            # 'if'-'else', 'lambda'",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "_Precedence",
        "kind": 6,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "class _Precedence(IntEnum):\n    \"\"\"Precedence table that originated from python grammar.\"\"\"\n    TUPLE = auto()\n    YIELD = auto()           # 'yield', 'yield from'\n    TEST = auto()            # 'if'-'else', 'lambda'\n    OR = auto()              # 'or'\n    AND = auto()             # 'and'\n    NOT = auto()             # 'not'\n    CMP = auto()             # '<', '>', '==', '>=', '<=', '!=',\n                             # 'in', 'not in', 'is', 'is not'",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "_Unparser",
        "kind": 6,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "class _Unparser(NodeVisitor):\n    \"\"\"Methods in this class recursively traverse an AST and\n    output source code for the abstract syntax; original formatting\n    is disregarded.\"\"\"\n    def __init__(self, *, _avoid_backslashes=False):\n        self._source = []\n        self._buffer = []\n        self._precedences = {}\n        self._type_ignores = {}\n        self._indent = 0",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "def parse(source, filename='<unknown>', mode='exec', *,\n          type_comments=False, feature_version=None):\n    \"\"\"\n    Parse the source into an AST node.\n    Equivalent to compile(source, filename, mode, PyCF_ONLY_AST).\n    Pass type_comments=True to get back type comments where the syntax allows.\n    \"\"\"\n    flags = PyCF_ONLY_AST\n    if type_comments:\n        flags |= PyCF_TYPE_COMMENTS",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "literal_eval",
        "kind": 2,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "def literal_eval(node_or_string):\n    \"\"\"\n    Evaluate an expression node or a string containing only a Python\n    expression.  The string or node provided may only consist of the following\n    Python literal structures: strings, bytes, numbers, tuples, lists, dicts,\n    sets, booleans, and None.\n    Caution: A complex expression can overflow the C stack and cause a crash.\n    \"\"\"\n    if isinstance(node_or_string, str):\n        node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "dump",
        "kind": 2,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "def dump(node, annotate_fields=True, include_attributes=False, *, indent=None):\n    \"\"\"\n    Return a formatted dump of the tree in node.  This is mainly useful for\n    debugging purposes.  If annotate_fields is true (by default),\n    the returned string will show the names and the values for fields.\n    If annotate_fields is false, the result string will be more compact by\n    omitting unambiguous field names.  Attributes such as line\n    numbers and column offsets are not dumped by default.  If this is wanted,\n    include_attributes can be set to true.  If indent is a non-negative\n    integer or string, then the tree will be pretty-printed with that indent",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "copy_location",
        "kind": 2,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "def copy_location(new_node, old_node):\n    \"\"\"\n    Copy source location (`lineno`, `col_offset`, `end_lineno`, and `end_col_offset`\n    attributes) from *old_node* to *new_node* if possible, and return *new_node*.\n    \"\"\"\n    for attr in 'lineno', 'col_offset', 'end_lineno', 'end_col_offset':\n        if attr in old_node._attributes and attr in new_node._attributes:\n            value = getattr(old_node, attr, None)\n            # end_lineno and end_col_offset are optional attributes, and they\n            # should be copied whether the value is None or not.",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "fix_missing_locations",
        "kind": 2,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "def fix_missing_locations(node):\n    \"\"\"\n    When you compile a node tree with compile(), the compiler expects lineno and\n    col_offset attributes for every node that supports them.  This is rather\n    tedious to fill in for generated nodes, so this helper adds these attributes\n    recursively where not already set, by setting them to the values of the\n    parent node.  It works recursively starting at *node*.\n    \"\"\"\n    def _fix(node, lineno, col_offset, end_lineno, end_col_offset):\n        if 'lineno' in node._attributes:",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "increment_lineno",
        "kind": 2,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "def increment_lineno(node, n=1):\n    \"\"\"\n    Increment the line number and end line number of each node in the tree\n    starting at *node* by *n*. This is useful to \"move code\" to a different\n    location in a file.\n    \"\"\"\n    for child in walk(node):\n        # TypeIgnore is a special case where lineno is not an attribute\n        # but rather a field of the node itself.\n        if isinstance(child, TypeIgnore):",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "iter_fields",
        "kind": 2,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "def iter_fields(node):\n    \"\"\"\n    Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields``\n    that is present on *node*.\n    \"\"\"\n    for field in node._fields:\n        try:\n            yield field, getattr(node, field)\n        except AttributeError:\n            pass",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "iter_child_nodes",
        "kind": 2,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "def iter_child_nodes(node):\n    \"\"\"\n    Yield all direct child nodes of *node*, that is, all fields that are nodes\n    and all items of fields that are lists of nodes.\n    \"\"\"\n    for name, field in iter_fields(node):\n        if isinstance(field, AST):\n            yield field\n        elif isinstance(field, list):\n            for item in field:",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "get_docstring",
        "kind": 2,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "def get_docstring(node, clean=True):\n    \"\"\"\n    Return the docstring for the given node or None if no docstring can\n    be found.  If the node provided does not have docstrings a TypeError\n    will be raised.\n    If *clean* is `True`, all tabs are expanded to spaces and any whitespace\n    that can be uniformly removed from the second line onwards is removed.\n    \"\"\"\n    if not isinstance(node, (AsyncFunctionDef, FunctionDef, ClassDef, Module)):\n        raise TypeError(\"%r can't have docstrings\" % node.__class__.__name__)",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "get_source_segment",
        "kind": 2,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "def get_source_segment(source, node, *, padded=False):\n    \"\"\"Get source code segment of the *source* that generated *node*.\n    If some location information (`lineno`, `end_lineno`, `col_offset`,\n    or `end_col_offset`) is missing, return None.\n    If *padded* is `True`, the first line of a multi-line statement will\n    be padded with spaces to match its original position.\n    \"\"\"\n    try:\n        if node.end_lineno is None or node.end_col_offset is None:\n            return None",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "walk",
        "kind": 2,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "def walk(node):\n    \"\"\"\n    Recursively yield all descendant nodes in the tree starting at *node*\n    (including *node* itself), in no specified order.  This is useful if you\n    only want to modify nodes in place and don't care about the context.\n    \"\"\"\n    from collections import deque\n    todo = deque([node])\n    while todo:\n        node = todo.popleft()",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "unparse",
        "kind": 2,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "def unparse(ast_obj):\n    unparser = _Unparser()\n    return unparser.visit(ast_obj)\ndef main():\n    import argparse\n    parser = argparse.ArgumentParser(prog='python -m ast')\n    parser.add_argument('infile', type=argparse.FileType(mode='rb'), nargs='?',\n                        default='-',\n                        help='the file to parse; defaults to stdin')\n    parser.add_argument('-m', '--mode', default='exec',",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "def main():\n    import argparse\n    parser = argparse.ArgumentParser(prog='python -m ast')\n    parser.add_argument('infile', type=argparse.FileType(mode='rb'), nargs='?',\n                        default='-',\n                        help='the file to parse; defaults to stdin')\n    parser.add_argument('-m', '--mode', default='exec',\n                        choices=('exec', 'single', 'eval', 'func_type'),\n                        help='specify what kind of code must be parsed')\n    parser.add_argument('--no-type-comments', default=True, action='store_false',",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "_const_types",
        "kind": 5,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "_const_types = {\n    Num: (int, float, complex),\n    Str: (str,),\n    Bytes: (bytes,),\n    NameConstant: (type(None), bool),\n    Ellipsis: (type(...),),\n}\n_const_types_not = {\n    Num: (bool,),\n}",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "_const_types_not",
        "kind": 5,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "_const_types_not = {\n    Num: (bool,),\n}\n_const_node_type_names = {\n    bool: 'NameConstant',  # should be before int\n    type(None): 'NameConstant',\n    int: 'Num',\n    float: 'Num',\n    complex: 'Num',\n    str: 'Str',",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "_const_node_type_names",
        "kind": 5,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "_const_node_type_names = {\n    bool: 'NameConstant',  # should be before int\n    type(None): 'NameConstant',\n    int: 'Num',\n    float: 'Num',\n    complex: 'Num',\n    str: 'Str',\n    bytes: 'Bytes',\n    type(...): 'Ellipsis',\n}",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "_INFSTR",
        "kind": 5,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "_INFSTR = \"1e\" + repr(sys.float_info.max_10_exp + 1)\nclass _Precedence(IntEnum):\n    \"\"\"Precedence table that originated from python grammar.\"\"\"\n    TUPLE = auto()\n    YIELD = auto()           # 'yield', 'yield from'\n    TEST = auto()            # 'if'-'else', 'lambda'\n    OR = auto()              # 'or'\n    AND = auto()             # 'and'\n    NOT = auto()             # 'not'\n    CMP = auto()             # '<', '>', '==', '>=', '<=', '!=',",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "_SINGLE_QUOTES",
        "kind": 5,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "_SINGLE_QUOTES = (\"'\", '\"')\n_MULTI_QUOTES = ('\"\"\"', \"'''\")\n_ALL_QUOTES = (*_SINGLE_QUOTES, *_MULTI_QUOTES)\nclass _Unparser(NodeVisitor):\n    \"\"\"Methods in this class recursively traverse an AST and\n    output source code for the abstract syntax; original formatting\n    is disregarded.\"\"\"\n    def __init__(self, *, _avoid_backslashes=False):\n        self._source = []\n        self._buffer = []",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "_MULTI_QUOTES",
        "kind": 5,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "_MULTI_QUOTES = ('\"\"\"', \"'''\")\n_ALL_QUOTES = (*_SINGLE_QUOTES, *_MULTI_QUOTES)\nclass _Unparser(NodeVisitor):\n    \"\"\"Methods in this class recursively traverse an AST and\n    output source code for the abstract syntax; original formatting\n    is disregarded.\"\"\"\n    def __init__(self, *, _avoid_backslashes=False):\n        self._source = []\n        self._buffer = []\n        self._precedences = {}",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "_ALL_QUOTES",
        "kind": 5,
        "importPath": "protobuf.Lib.ast",
        "description": "protobuf.Lib.ast",
        "peekOfCode": "_ALL_QUOTES = (*_SINGLE_QUOTES, *_MULTI_QUOTES)\nclass _Unparser(NodeVisitor):\n    \"\"\"Methods in this class recursively traverse an AST and\n    output source code for the abstract syntax; original formatting\n    is disregarded.\"\"\"\n    def __init__(self, *, _avoid_backslashes=False):\n        self._source = []\n        self._buffer = []\n        self._precedences = {}\n        self._type_ignores = {}",
        "detail": "protobuf.Lib.ast",
        "documentation": {}
    },
    {
        "label": "async_chat",
        "kind": 6,
        "importPath": "protobuf.Lib.asynchat",
        "description": "protobuf.Lib.asynchat",
        "peekOfCode": "class async_chat(asyncore.dispatcher):\n    \"\"\"This is an abstract class.  You must derive from this class, and add\n    the two methods collect_incoming_data() and found_terminator()\"\"\"\n    # these are overridable defaults\n    ac_in_buffer_size = 65536\n    ac_out_buffer_size = 65536\n    # we don't want to enable the use of encoding by default, because that is a\n    # sign of an application bug that we don't want to pass silently\n    use_encoding = 0\n    encoding = 'latin-1'",
        "detail": "protobuf.Lib.asynchat",
        "documentation": {}
    },
    {
        "label": "simple_producer",
        "kind": 6,
        "importPath": "protobuf.Lib.asynchat",
        "description": "protobuf.Lib.asynchat",
        "peekOfCode": "class simple_producer:\n    def __init__(self, data, buffer_size=512):\n        self.data = data\n        self.buffer_size = buffer_size\n    def more(self):\n        if len(self.data) > self.buffer_size:\n            result = self.data[:self.buffer_size]\n            self.data = self.data[self.buffer_size:]\n            return result\n        else:",
        "detail": "protobuf.Lib.asynchat",
        "documentation": {}
    },
    {
        "label": "find_prefix_at_end",
        "kind": 2,
        "importPath": "protobuf.Lib.asynchat",
        "description": "protobuf.Lib.asynchat",
        "peekOfCode": "def find_prefix_at_end(haystack, needle):\n    l = len(needle) - 1\n    while l and not haystack.endswith(needle[:l]):\n        l -= 1\n    return l",
        "detail": "protobuf.Lib.asynchat",
        "documentation": {}
    },
    {
        "label": "ExitNow",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncore",
        "description": "protobuf.Lib.asyncore",
        "peekOfCode": "class ExitNow(Exception):\n    pass\n_reraised_exceptions = (ExitNow, KeyboardInterrupt, SystemExit)\ndef read(obj):\n    try:\n        obj.handle_read_event()\n    except _reraised_exceptions:\n        raise\n    except:\n        obj.handle_error()",
        "detail": "protobuf.Lib.asyncore",
        "documentation": {}
    },
    {
        "label": "dispatcher",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncore",
        "description": "protobuf.Lib.asyncore",
        "peekOfCode": "class dispatcher:\n    debug = False\n    connected = False\n    accepting = False\n    connecting = False\n    closing = False\n    addr = None\n    ignore_log_types = frozenset({'warning'})\n    def __init__(self, sock=None, map=None):\n        if map is None:",
        "detail": "protobuf.Lib.asyncore",
        "documentation": {}
    },
    {
        "label": "dispatcher_with_send",
        "kind": 6,
        "importPath": "protobuf.Lib.asyncore",
        "description": "protobuf.Lib.asyncore",
        "peekOfCode": "class dispatcher_with_send(dispatcher):\n    def __init__(self, sock=None, map=None):\n        dispatcher.__init__(self, sock, map)\n        self.out_buffer = b''\n    def initiate_send(self):\n        num_sent = 0\n        num_sent = dispatcher.send(self, self.out_buffer[:65536])\n        self.out_buffer = self.out_buffer[num_sent:]\n    def handle_write(self):\n        self.initiate_send()",
        "detail": "protobuf.Lib.asyncore",
        "documentation": {}
    },
    {
        "label": "read",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncore",
        "description": "protobuf.Lib.asyncore",
        "peekOfCode": "def read(obj):\n    try:\n        obj.handle_read_event()\n    except _reraised_exceptions:\n        raise\n    except:\n        obj.handle_error()\ndef write(obj):\n    try:\n        obj.handle_write_event()",
        "detail": "protobuf.Lib.asyncore",
        "documentation": {}
    },
    {
        "label": "write",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncore",
        "description": "protobuf.Lib.asyncore",
        "peekOfCode": "def write(obj):\n    try:\n        obj.handle_write_event()\n    except _reraised_exceptions:\n        raise\n    except:\n        obj.handle_error()\ndef _exception(obj):\n    try:\n        obj.handle_expt_event()",
        "detail": "protobuf.Lib.asyncore",
        "documentation": {}
    },
    {
        "label": "readwrite",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncore",
        "description": "protobuf.Lib.asyncore",
        "peekOfCode": "def readwrite(obj, flags):\n    try:\n        if flags & select.POLLIN:\n            obj.handle_read_event()\n        if flags & select.POLLOUT:\n            obj.handle_write_event()\n        if flags & select.POLLPRI:\n            obj.handle_expt_event()\n        if flags & (select.POLLHUP | select.POLLERR | select.POLLNVAL):\n            obj.handle_close()",
        "detail": "protobuf.Lib.asyncore",
        "documentation": {}
    },
    {
        "label": "poll",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncore",
        "description": "protobuf.Lib.asyncore",
        "peekOfCode": "def poll(timeout=0.0, map=None):\n    if map is None:\n        map = socket_map\n    if map:\n        r = []; w = []; e = []\n        for fd, obj in list(map.items()):\n            is_r = obj.readable()\n            is_w = obj.writable()\n            if is_r:\n                r.append(fd)",
        "detail": "protobuf.Lib.asyncore",
        "documentation": {}
    },
    {
        "label": "poll2",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncore",
        "description": "protobuf.Lib.asyncore",
        "peekOfCode": "def poll2(timeout=0.0, map=None):\n    # Use the poll() support added to the select module in Python 2.0\n    if map is None:\n        map = socket_map\n    if timeout is not None:\n        # timeout is in milliseconds\n        timeout = int(timeout*1000)\n    pollster = select.poll()\n    if map:\n        for fd, obj in list(map.items()):",
        "detail": "protobuf.Lib.asyncore",
        "documentation": {}
    },
    {
        "label": "loop",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncore",
        "description": "protobuf.Lib.asyncore",
        "peekOfCode": "def loop(timeout=30.0, use_poll=False, map=None, count=None):\n    if map is None:\n        map = socket_map\n    if use_poll and hasattr(select, 'poll'):\n        poll_fun = poll2\n    else:\n        poll_fun = poll\n    if count is None:\n        while map:\n            poll_fun(timeout, map)",
        "detail": "protobuf.Lib.asyncore",
        "documentation": {}
    },
    {
        "label": "compact_traceback",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncore",
        "description": "protobuf.Lib.asyncore",
        "peekOfCode": "def compact_traceback():\n    t, v, tb = sys.exc_info()\n    tbinfo = []\n    if not tb: # Must have a traceback\n        raise AssertionError(\"traceback does not exist\")\n    while tb:\n        tbinfo.append((\n            tb.tb_frame.f_code.co_filename,\n            tb.tb_frame.f_code.co_name,\n            str(tb.tb_lineno)",
        "detail": "protobuf.Lib.asyncore",
        "documentation": {}
    },
    {
        "label": "close_all",
        "kind": 2,
        "importPath": "protobuf.Lib.asyncore",
        "description": "protobuf.Lib.asyncore",
        "peekOfCode": "def close_all(map=None, ignore_all=False):\n    if map is None:\n        map = socket_map\n    for x in list(map.values()):\n        try:\n            x.close()\n        except OSError as x:\n            if x.errno == EBADF:\n                pass\n            elif not ignore_all:",
        "detail": "protobuf.Lib.asyncore",
        "documentation": {}
    },
    {
        "label": "_DISCONNECTED",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncore",
        "description": "protobuf.Lib.asyncore",
        "peekOfCode": "_DISCONNECTED = frozenset({ECONNRESET, ENOTCONN, ESHUTDOWN, ECONNABORTED, EPIPE,\n                           EBADF})\ntry:\n    socket_map\nexcept NameError:\n    socket_map = {}\ndef _strerror(err):\n    try:\n        return os.strerror(err)\n    except (ValueError, OverflowError, NameError):",
        "detail": "protobuf.Lib.asyncore",
        "documentation": {}
    },
    {
        "label": "_reraised_exceptions",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncore",
        "description": "protobuf.Lib.asyncore",
        "peekOfCode": "_reraised_exceptions = (ExitNow, KeyboardInterrupt, SystemExit)\ndef read(obj):\n    try:\n        obj.handle_read_event()\n    except _reraised_exceptions:\n        raise\n    except:\n        obj.handle_error()\ndef write(obj):\n    try:",
        "detail": "protobuf.Lib.asyncore",
        "documentation": {}
    },
    {
        "label": "poll3",
        "kind": 5,
        "importPath": "protobuf.Lib.asyncore",
        "description": "protobuf.Lib.asyncore",
        "peekOfCode": "poll3 = poll2                           # Alias for backward compatibility\ndef loop(timeout=30.0, use_poll=False, map=None, count=None):\n    if map is None:\n        map = socket_map\n    if use_poll and hasattr(select, 'poll'):\n        poll_fun = poll2\n    else:\n        poll_fun = poll\n    if count is None:\n        while map:",
        "detail": "protobuf.Lib.asyncore",
        "documentation": {}
    },
    {
        "label": "b64encode",
        "kind": 2,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "def b64encode(s, altchars=None):\n    \"\"\"Encode the bytes-like object s using Base64 and return a bytes object.\n    Optional altchars should be a byte string of length 2 which specifies an\n    alternative alphabet for the '+' and '/' characters.  This allows an\n    application to e.g. generate url or filesystem safe Base64 strings.\n    \"\"\"\n    encoded = binascii.b2a_base64(s, newline=False)\n    if altchars is not None:\n        assert len(altchars) == 2, repr(altchars)\n        return encoded.translate(bytes.maketrans(b'+/', altchars))",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "b64decode",
        "kind": 2,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "def b64decode(s, altchars=None, validate=False):\n    \"\"\"Decode the Base64 encoded bytes-like object or ASCII string s.\n    Optional altchars must be a bytes-like object or ASCII string of length 2\n    which specifies the alternative alphabet used instead of the '+' and '/'\n    characters.\n    The result is returned as a bytes object.  A binascii.Error is raised if\n    s is incorrectly padded.\n    If validate is False (the default), characters that are neither in the\n    normal base-64 alphabet nor the alternative alphabet are discarded prior\n    to the padding check.  If validate is True, these non-alphabet characters",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "standard_b64encode",
        "kind": 2,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "def standard_b64encode(s):\n    \"\"\"Encode bytes-like object s using the standard Base64 alphabet.\n    The result is returned as a bytes object.\n    \"\"\"\n    return b64encode(s)\ndef standard_b64decode(s):\n    \"\"\"Decode bytes encoded with the standard Base64 alphabet.\n    Argument s is a bytes-like object or ASCII string to decode.  The result\n    is returned as a bytes object.  A binascii.Error is raised if the input\n    is incorrectly padded.  Characters that are not in the standard alphabet",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "standard_b64decode",
        "kind": 2,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "def standard_b64decode(s):\n    \"\"\"Decode bytes encoded with the standard Base64 alphabet.\n    Argument s is a bytes-like object or ASCII string to decode.  The result\n    is returned as a bytes object.  A binascii.Error is raised if the input\n    is incorrectly padded.  Characters that are not in the standard alphabet\n    are discarded prior to the padding check.\n    \"\"\"\n    return b64decode(s)\n_urlsafe_encode_translation = bytes.maketrans(b'+/', b'-_')\n_urlsafe_decode_translation = bytes.maketrans(b'-_', b'+/')",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "urlsafe_b64encode",
        "kind": 2,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "def urlsafe_b64encode(s):\n    \"\"\"Encode bytes using the URL- and filesystem-safe Base64 alphabet.\n    Argument s is a bytes-like object to encode.  The result is returned as a\n    bytes object.  The alphabet uses '-' instead of '+' and '_' instead of\n    '/'.\n    \"\"\"\n    return b64encode(s).translate(_urlsafe_encode_translation)\ndef urlsafe_b64decode(s):\n    \"\"\"Decode bytes using the URL- and filesystem-safe Base64 alphabet.\n    Argument s is a bytes-like object or ASCII string to decode.  The result",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "urlsafe_b64decode",
        "kind": 2,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "def urlsafe_b64decode(s):\n    \"\"\"Decode bytes using the URL- and filesystem-safe Base64 alphabet.\n    Argument s is a bytes-like object or ASCII string to decode.  The result\n    is returned as a bytes object.  A binascii.Error is raised if the input\n    is incorrectly padded.  Characters that are not in the URL-safe base-64\n    alphabet, and are not a plus '+' or slash '/', are discarded prior to the\n    padding check.\n    The alphabet uses '-' instead of '+' and '_' instead of '/'.\n    \"\"\"\n    s = _bytes_from_decode_data(s)",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "b32encode",
        "kind": 2,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "def b32encode(s):\n    return _b32encode(_b32alphabet, s)\nb32encode.__doc__ = _B32_ENCODE_DOCSTRING.format(encoding='base32')\ndef b32decode(s, casefold=False, map01=None):\n    return _b32decode(_b32alphabet, s, casefold, map01)\nb32decode.__doc__ = _B32_DECODE_DOCSTRING.format(encoding='base32',\n                                        extra_args=_B32_DECODE_MAP01_DOCSTRING)\ndef b32hexencode(s):\n    return _b32encode(_b32hexalphabet, s)\nb32hexencode.__doc__ = _B32_ENCODE_DOCSTRING.format(encoding='base32hex')",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "b32decode",
        "kind": 2,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "def b32decode(s, casefold=False, map01=None):\n    return _b32decode(_b32alphabet, s, casefold, map01)\nb32decode.__doc__ = _B32_DECODE_DOCSTRING.format(encoding='base32',\n                                        extra_args=_B32_DECODE_MAP01_DOCSTRING)\ndef b32hexencode(s):\n    return _b32encode(_b32hexalphabet, s)\nb32hexencode.__doc__ = _B32_ENCODE_DOCSTRING.format(encoding='base32hex')\ndef b32hexdecode(s, casefold=False):\n    # base32hex does not have the 01 mapping\n    return _b32decode(_b32hexalphabet, s, casefold)",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "b32hexencode",
        "kind": 2,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "def b32hexencode(s):\n    return _b32encode(_b32hexalphabet, s)\nb32hexencode.__doc__ = _B32_ENCODE_DOCSTRING.format(encoding='base32hex')\ndef b32hexdecode(s, casefold=False):\n    # base32hex does not have the 01 mapping\n    return _b32decode(_b32hexalphabet, s, casefold)\nb32hexdecode.__doc__ = _B32_DECODE_DOCSTRING.format(encoding='base32hex',\n                                                    extra_args='')\n# RFC 3548, Base 16 Alphabet specifies uppercase, but hexlify() returns\n# lowercase.  The RFC also recommends against accepting input case",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "b32hexdecode",
        "kind": 2,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "def b32hexdecode(s, casefold=False):\n    # base32hex does not have the 01 mapping\n    return _b32decode(_b32hexalphabet, s, casefold)\nb32hexdecode.__doc__ = _B32_DECODE_DOCSTRING.format(encoding='base32hex',\n                                                    extra_args='')\n# RFC 3548, Base 16 Alphabet specifies uppercase, but hexlify() returns\n# lowercase.  The RFC also recommends against accepting input case\n# insensitively.\ndef b16encode(s):\n    \"\"\"Encode the bytes-like object s using Base16 and return a bytes object.",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "b16encode",
        "kind": 2,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "def b16encode(s):\n    \"\"\"Encode the bytes-like object s using Base16 and return a bytes object.\n    \"\"\"\n    return binascii.hexlify(s).upper()\ndef b16decode(s, casefold=False):\n    \"\"\"Decode the Base16 encoded bytes-like object or ASCII string s.\n    Optional casefold is a flag specifying whether a lowercase alphabet is\n    acceptable as input.  For security purposes, the default is False.\n    The result is returned as a bytes object.  A binascii.Error is raised if\n    s is incorrectly padded or if there are non-alphabet characters present",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "b16decode",
        "kind": 2,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "def b16decode(s, casefold=False):\n    \"\"\"Decode the Base16 encoded bytes-like object or ASCII string s.\n    Optional casefold is a flag specifying whether a lowercase alphabet is\n    acceptable as input.  For security purposes, the default is False.\n    The result is returned as a bytes object.  A binascii.Error is raised if\n    s is incorrectly padded or if there are non-alphabet characters present\n    in the input.\n    \"\"\"\n    s = _bytes_from_decode_data(s)\n    if casefold:",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "a85encode",
        "kind": 2,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "def a85encode(b, *, foldspaces=False, wrapcol=0, pad=False, adobe=False):\n    \"\"\"Encode bytes-like object b using Ascii85 and return a bytes object.\n    foldspaces is an optional flag that uses the special short sequence 'y'\n    instead of 4 consecutive spaces (ASCII 0x20) as supported by 'btoa'. This\n    feature is not supported by the \"standard\" Adobe encoding.\n    wrapcol controls whether the output should have newline (b'\\\\n') characters\n    added to it. If this is non-zero, each output line will be at most this\n    many characters long.\n    pad controls whether the input is padded to a multiple of 4 before\n    encoding. Note that the btoa implementation always pads.",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "a85decode",
        "kind": 2,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "def a85decode(b, *, foldspaces=False, adobe=False, ignorechars=b' \\t\\n\\r\\v'):\n    \"\"\"Decode the Ascii85 encoded bytes-like object or ASCII string b.\n    foldspaces is a flag that specifies whether the 'y' short sequence should be\n    accepted as shorthand for 4 consecutive spaces (ASCII 0x20). This feature is\n    not supported by the \"standard\" Adobe encoding.\n    adobe controls whether the input sequence is in Adobe Ascii85 format (i.e.\n    is framed with <~ and ~>).\n    ignorechars should be a byte string containing characters to ignore from the\n    input. This should only contain whitespace characters, and by default\n    contains all whitespace characters in ASCII.",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "b85encode",
        "kind": 2,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "def b85encode(b, pad=False):\n    \"\"\"Encode bytes-like object b in base85 format and return a bytes object.\n    If pad is true, the input is padded with b'\\\\0' so its length is a multiple of\n    4 bytes before encoding.\n    \"\"\"\n    global _b85chars, _b85chars2\n    # Delay the initialization of tables to not waste memory\n    # if the function is never called\n    if _b85chars2 is None:\n        _b85chars = [bytes((i,)) for i in _b85alphabet]",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "b85decode",
        "kind": 2,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "def b85decode(b):\n    \"\"\"Decode the base85-encoded bytes-like object or ASCII string b\n    The result is returned as a bytes object.\n    \"\"\"\n    global _b85dec\n    # Delay the initialization of tables to not waste memory\n    # if the function is never called\n    if _b85dec is None:\n        _b85dec = [None] * 256\n        for i, c in enumerate(_b85alphabet):",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "encode",
        "kind": 2,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "def encode(input, output):\n    \"\"\"Encode a file; input and output are binary files.\"\"\"\n    while True:\n        s = input.read(MAXBINSIZE)\n        if not s:\n            break\n        while len(s) < MAXBINSIZE:\n            ns = input.read(MAXBINSIZE-len(s))\n            if not ns:\n                break",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "decode",
        "kind": 2,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "def decode(input, output):\n    \"\"\"Decode a file; input and output are binary files.\"\"\"\n    while True:\n        line = input.readline()\n        if not line:\n            break\n        s = binascii.a2b_base64(line)\n        output.write(s)\ndef _input_type_check(s):\n    try:",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "encodebytes",
        "kind": 2,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "def encodebytes(s):\n    \"\"\"Encode a bytestring into a bytes object containing multiple lines\n    of base-64 data.\"\"\"\n    _input_type_check(s)\n    pieces = []\n    for i in range(0, len(s), MAXBINSIZE):\n        chunk = s[i : i + MAXBINSIZE]\n        pieces.append(binascii.b2a_base64(chunk))\n    return b\"\".join(pieces)\ndef decodebytes(s):",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "decodebytes",
        "kind": 2,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "def decodebytes(s):\n    \"\"\"Decode a bytestring of base-64 data into a bytes object.\"\"\"\n    _input_type_check(s)\n    return binascii.a2b_base64(s)\n# Usable as a script...\ndef main():\n    \"\"\"Small main program\"\"\"\n    import sys, getopt\n    try:\n        opts, args = getopt.getopt(sys.argv[1:], 'deut')",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "def main():\n    \"\"\"Small main program\"\"\"\n    import sys, getopt\n    try:\n        opts, args = getopt.getopt(sys.argv[1:], 'deut')\n    except getopt.error as msg:\n        sys.stdout = sys.stderr\n        print(msg)\n        print(\"\"\"usage: %s [-d|-e|-u|-t] [file|-]\n        -d, -u: decode",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "def test():\n    s0 = b\"Aladdin:open sesame\"\n    print(repr(s0))\n    s1 = encodebytes(s0)\n    print(repr(s1))\n    s2 = decodebytes(s1)\n    print(repr(s2))\n    assert s0 == s2\nif __name__ == '__main__':\n    main()",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "__all__ = [\n    # Legacy interface exports traditional RFC 2045 Base64 encodings\n    'encode', 'decode', 'encodebytes', 'decodebytes',\n    # Generalized interface for other encodings\n    'b64encode', 'b64decode', 'b32encode', 'b32decode',\n    'b32hexencode', 'b32hexdecode', 'b16encode', 'b16decode',\n    # Base85 and Ascii85 encodings\n    'b85encode', 'b85decode', 'a85encode', 'a85decode',\n    # Standard Base64 encoding\n    'standard_b64encode', 'standard_b64decode',",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "bytes_types",
        "kind": 5,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "bytes_types = (bytes, bytearray)  # Types acceptable as binary data\ndef _bytes_from_decode_data(s):\n    if isinstance(s, str):\n        try:\n            return s.encode('ascii')\n        except UnicodeEncodeError:\n            raise ValueError('string argument should contain only ASCII characters')\n    if isinstance(s, bytes_types):\n        return s\n    try:",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_urlsafe_encode_translation",
        "kind": 5,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "_urlsafe_encode_translation = bytes.maketrans(b'+/', b'-_')\n_urlsafe_decode_translation = bytes.maketrans(b'-_', b'+/')\ndef urlsafe_b64encode(s):\n    \"\"\"Encode bytes using the URL- and filesystem-safe Base64 alphabet.\n    Argument s is a bytes-like object to encode.  The result is returned as a\n    bytes object.  The alphabet uses '-' instead of '+' and '_' instead of\n    '/'.\n    \"\"\"\n    return b64encode(s).translate(_urlsafe_encode_translation)\ndef urlsafe_b64decode(s):",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_urlsafe_decode_translation",
        "kind": 5,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "_urlsafe_decode_translation = bytes.maketrans(b'-_', b'+/')\ndef urlsafe_b64encode(s):\n    \"\"\"Encode bytes using the URL- and filesystem-safe Base64 alphabet.\n    Argument s is a bytes-like object to encode.  The result is returned as a\n    bytes object.  The alphabet uses '-' instead of '+' and '_' instead of\n    '/'.\n    \"\"\"\n    return b64encode(s).translate(_urlsafe_encode_translation)\ndef urlsafe_b64decode(s):\n    \"\"\"Decode bytes using the URL- and filesystem-safe Base64 alphabet.",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_B32_ENCODE_DOCSTRING",
        "kind": 5,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "_B32_ENCODE_DOCSTRING = '''\nEncode the bytes-like objects using {encoding} and return a bytes object.\n'''\n_B32_DECODE_DOCSTRING = '''\nDecode the {encoding} encoded bytes-like object or ASCII string s.\nOptional casefold is a flag specifying whether a lowercase alphabet is\nacceptable as input.  For security purposes, the default is False.\n{extra_args}\nThe result is returned as a bytes object.  A binascii.Error is raised if\nthe input is incorrectly padded or if there are non-alphabet",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_B32_DECODE_DOCSTRING",
        "kind": 5,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "_B32_DECODE_DOCSTRING = '''\nDecode the {encoding} encoded bytes-like object or ASCII string s.\nOptional casefold is a flag specifying whether a lowercase alphabet is\nacceptable as input.  For security purposes, the default is False.\n{extra_args}\nThe result is returned as a bytes object.  A binascii.Error is raised if\nthe input is incorrectly padded or if there are non-alphabet\ncharacters present in the input.\n'''\n_B32_DECODE_MAP01_DOCSTRING = '''",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_B32_DECODE_MAP01_DOCSTRING",
        "kind": 5,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "_B32_DECODE_MAP01_DOCSTRING = '''\nRFC 3548 allows for optional mapping of the digit 0 (zero) to the\nletter O (oh), and for optional mapping of the digit 1 (one) to\neither the letter I (eye) or letter L (el).  The optional argument\nmap01 when not None, specifies which letter the digit 1 should be\nmapped to (when map01 is not None, the digit 0 is always mapped to\nthe letter O).  For security purposes the default is None, so that\n0 and 1 are not allowed in the input.\n'''\n_b32alphabet = b'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_b32alphabet",
        "kind": 5,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "_b32alphabet = b'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'\n_b32hexalphabet = b'0123456789ABCDEFGHIJKLMNOPQRSTUV'\n_b32tab2 = {}\n_b32rev = {}\ndef _b32encode(alphabet, s):\n    global _b32tab2\n    # Delay the initialization of the table to not waste memory\n    # if the function is never called\n    if alphabet not in _b32tab2:\n        b32tab = [bytes((i,)) for i in alphabet]",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_b32hexalphabet",
        "kind": 5,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "_b32hexalphabet = b'0123456789ABCDEFGHIJKLMNOPQRSTUV'\n_b32tab2 = {}\n_b32rev = {}\ndef _b32encode(alphabet, s):\n    global _b32tab2\n    # Delay the initialization of the table to not waste memory\n    # if the function is never called\n    if alphabet not in _b32tab2:\n        b32tab = [bytes((i,)) for i in alphabet]\n        _b32tab2[alphabet] = [a + b for a in b32tab for b in b32tab]",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_b32tab2",
        "kind": 5,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "_b32tab2 = {}\n_b32rev = {}\ndef _b32encode(alphabet, s):\n    global _b32tab2\n    # Delay the initialization of the table to not waste memory\n    # if the function is never called\n    if alphabet not in _b32tab2:\n        b32tab = [bytes((i,)) for i in alphabet]\n        _b32tab2[alphabet] = [a + b for a in b32tab for b in b32tab]\n        b32tab = None",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_b32rev",
        "kind": 5,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "_b32rev = {}\ndef _b32encode(alphabet, s):\n    global _b32tab2\n    # Delay the initialization of the table to not waste memory\n    # if the function is never called\n    if alphabet not in _b32tab2:\n        b32tab = [bytes((i,)) for i in alphabet]\n        _b32tab2[alphabet] = [a + b for a in b32tab for b in b32tab]\n        b32tab = None\n    if not isinstance(s, bytes_types):",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "b32encode.__doc__",
        "kind": 5,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "b32encode.__doc__ = _B32_ENCODE_DOCSTRING.format(encoding='base32')\ndef b32decode(s, casefold=False, map01=None):\n    return _b32decode(_b32alphabet, s, casefold, map01)\nb32decode.__doc__ = _B32_DECODE_DOCSTRING.format(encoding='base32',\n                                        extra_args=_B32_DECODE_MAP01_DOCSTRING)\ndef b32hexencode(s):\n    return _b32encode(_b32hexalphabet, s)\nb32hexencode.__doc__ = _B32_ENCODE_DOCSTRING.format(encoding='base32hex')\ndef b32hexdecode(s, casefold=False):\n    # base32hex does not have the 01 mapping",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "b32decode.__doc__",
        "kind": 5,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "b32decode.__doc__ = _B32_DECODE_DOCSTRING.format(encoding='base32',\n                                        extra_args=_B32_DECODE_MAP01_DOCSTRING)\ndef b32hexencode(s):\n    return _b32encode(_b32hexalphabet, s)\nb32hexencode.__doc__ = _B32_ENCODE_DOCSTRING.format(encoding='base32hex')\ndef b32hexdecode(s, casefold=False):\n    # base32hex does not have the 01 mapping\n    return _b32decode(_b32hexalphabet, s, casefold)\nb32hexdecode.__doc__ = _B32_DECODE_DOCSTRING.format(encoding='base32hex',\n                                                    extra_args='')",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "b32hexencode.__doc__",
        "kind": 5,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "b32hexencode.__doc__ = _B32_ENCODE_DOCSTRING.format(encoding='base32hex')\ndef b32hexdecode(s, casefold=False):\n    # base32hex does not have the 01 mapping\n    return _b32decode(_b32hexalphabet, s, casefold)\nb32hexdecode.__doc__ = _B32_DECODE_DOCSTRING.format(encoding='base32hex',\n                                                    extra_args='')\n# RFC 3548, Base 16 Alphabet specifies uppercase, but hexlify() returns\n# lowercase.  The RFC also recommends against accepting input case\n# insensitively.\ndef b16encode(s):",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "b32hexdecode.__doc__",
        "kind": 5,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "b32hexdecode.__doc__ = _B32_DECODE_DOCSTRING.format(encoding='base32hex',\n                                                    extra_args='')\n# RFC 3548, Base 16 Alphabet specifies uppercase, but hexlify() returns\n# lowercase.  The RFC also recommends against accepting input case\n# insensitively.\ndef b16encode(s):\n    \"\"\"Encode the bytes-like object s using Base16 and return a bytes object.\n    \"\"\"\n    return binascii.hexlify(s).upper()\ndef b16decode(s, casefold=False):",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_a85chars",
        "kind": 5,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "_a85chars = None\n_a85chars2 = None\n_A85START = b\"<~\"\n_A85END = b\"~>\"\ndef _85encode(b, chars, chars2, pad=False, foldnuls=False, foldspaces=False):\n    # Helper function for a85encode and b85encode\n    if not isinstance(b, bytes_types):\n        b = memoryview(b).tobytes()\n    padding = (-len(b)) % 4\n    if padding:",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_a85chars2",
        "kind": 5,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "_a85chars2 = None\n_A85START = b\"<~\"\n_A85END = b\"~>\"\ndef _85encode(b, chars, chars2, pad=False, foldnuls=False, foldspaces=False):\n    # Helper function for a85encode and b85encode\n    if not isinstance(b, bytes_types):\n        b = memoryview(b).tobytes()\n    padding = (-len(b)) % 4\n    if padding:\n        b = b + b'\\0' * padding",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_A85START",
        "kind": 5,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "_A85START = b\"<~\"\n_A85END = b\"~>\"\ndef _85encode(b, chars, chars2, pad=False, foldnuls=False, foldspaces=False):\n    # Helper function for a85encode and b85encode\n    if not isinstance(b, bytes_types):\n        b = memoryview(b).tobytes()\n    padding = (-len(b)) % 4\n    if padding:\n        b = b + b'\\0' * padding\n    words = struct.Struct('!%dI' % (len(b) // 4)).unpack(b)",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_A85END",
        "kind": 5,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "_A85END = b\"~>\"\ndef _85encode(b, chars, chars2, pad=False, foldnuls=False, foldspaces=False):\n    # Helper function for a85encode and b85encode\n    if not isinstance(b, bytes_types):\n        b = memoryview(b).tobytes()\n    padding = (-len(b)) % 4\n    if padding:\n        b = b + b'\\0' * padding\n    words = struct.Struct('!%dI' % (len(b) // 4)).unpack(b)\n    chunks = [b'z' if foldnuls and not word else",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_b85alphabet",
        "kind": 5,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "_b85alphabet = (b\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                b\"abcdefghijklmnopqrstuvwxyz!#$%&()*+-;<=>?@^_`{|}~\")\n_b85chars = None\n_b85chars2 = None\n_b85dec = None\ndef b85encode(b, pad=False):\n    \"\"\"Encode bytes-like object b in base85 format and return a bytes object.\n    If pad is true, the input is padded with b'\\\\0' so its length is a multiple of\n    4 bytes before encoding.\n    \"\"\"",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_b85chars",
        "kind": 5,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "_b85chars = None\n_b85chars2 = None\n_b85dec = None\ndef b85encode(b, pad=False):\n    \"\"\"Encode bytes-like object b in base85 format and return a bytes object.\n    If pad is true, the input is padded with b'\\\\0' so its length is a multiple of\n    4 bytes before encoding.\n    \"\"\"\n    global _b85chars, _b85chars2\n    # Delay the initialization of tables to not waste memory",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_b85chars2",
        "kind": 5,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "_b85chars2 = None\n_b85dec = None\ndef b85encode(b, pad=False):\n    \"\"\"Encode bytes-like object b in base85 format and return a bytes object.\n    If pad is true, the input is padded with b'\\\\0' so its length is a multiple of\n    4 bytes before encoding.\n    \"\"\"\n    global _b85chars, _b85chars2\n    # Delay the initialization of tables to not waste memory\n    # if the function is never called",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_b85dec",
        "kind": 5,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "_b85dec = None\ndef b85encode(b, pad=False):\n    \"\"\"Encode bytes-like object b in base85 format and return a bytes object.\n    If pad is true, the input is padded with b'\\\\0' so its length is a multiple of\n    4 bytes before encoding.\n    \"\"\"\n    global _b85chars, _b85chars2\n    # Delay the initialization of tables to not waste memory\n    # if the function is never called\n    if _b85chars2 is None:",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "MAXLINESIZE",
        "kind": 5,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "MAXLINESIZE = 76 # Excluding the CRLF\nMAXBINSIZE = (MAXLINESIZE//4)*3\ndef encode(input, output):\n    \"\"\"Encode a file; input and output are binary files.\"\"\"\n    while True:\n        s = input.read(MAXBINSIZE)\n        if not s:\n            break\n        while len(s) < MAXBINSIZE:\n            ns = input.read(MAXBINSIZE-len(s))",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "MAXBINSIZE",
        "kind": 5,
        "importPath": "protobuf.Lib.base64",
        "description": "protobuf.Lib.base64",
        "peekOfCode": "MAXBINSIZE = (MAXLINESIZE//4)*3\ndef encode(input, output):\n    \"\"\"Encode a file; input and output are binary files.\"\"\"\n    while True:\n        s = input.read(MAXBINSIZE)\n        if not s:\n            break\n        while len(s) < MAXBINSIZE:\n            ns = input.read(MAXBINSIZE-len(s))\n            if not ns:",
        "detail": "protobuf.Lib.base64",
        "documentation": {}
    },
    {
        "label": "BdbQuit",
        "kind": 6,
        "importPath": "protobuf.Lib.bdb",
        "description": "protobuf.Lib.bdb",
        "peekOfCode": "class BdbQuit(Exception):\n    \"\"\"Exception to give up completely.\"\"\"\nclass Bdb:\n    \"\"\"Generic Python debugger base class.\n    This class takes care of details of the trace facility;\n    a derived class should implement user interaction.\n    The standard debugger class (pdb.Pdb) is an example.\n    The optional skip argument must be an iterable of glob-style\n    module name patterns.  The debugger will not step into frames\n    that originate in a module that matches one of these patterns.",
        "detail": "protobuf.Lib.bdb",
        "documentation": {}
    },
    {
        "label": "Bdb",
        "kind": 6,
        "importPath": "protobuf.Lib.bdb",
        "description": "protobuf.Lib.bdb",
        "peekOfCode": "class Bdb:\n    \"\"\"Generic Python debugger base class.\n    This class takes care of details of the trace facility;\n    a derived class should implement user interaction.\n    The standard debugger class (pdb.Pdb) is an example.\n    The optional skip argument must be an iterable of glob-style\n    module name patterns.  The debugger will not step into frames\n    that originate in a module that matches one of these patterns.\n    Whether a frame is considered to originate in a certain module\n    is determined by the __name__ in the frame globals.",
        "detail": "protobuf.Lib.bdb",
        "documentation": {}
    },
    {
        "label": "Breakpoint",
        "kind": 6,
        "importPath": "protobuf.Lib.bdb",
        "description": "protobuf.Lib.bdb",
        "peekOfCode": "class Breakpoint:\n    \"\"\"Breakpoint class.\n    Implements temporary breakpoints, ignore counts, disabling and\n    (re)-enabling, and conditionals.\n    Breakpoints are indexed by number through bpbynumber and by\n    the (file, line) tuple using bplist.  The former points to a\n    single instance of class Breakpoint.  The latter points to a\n    list of such instances since there may be more than one\n    breakpoint per line.\n    When creating a breakpoint, its associated filename should be",
        "detail": "protobuf.Lib.bdb",
        "documentation": {}
    },
    {
        "label": "Tdb",
        "kind": 6,
        "importPath": "protobuf.Lib.bdb",
        "description": "protobuf.Lib.bdb",
        "peekOfCode": "class Tdb(Bdb):\n    def user_call(self, frame, args):\n        name = frame.f_code.co_name\n        if not name: name = '???'\n        print('+++ call', name, args)\n    def user_line(self, frame):\n        import linecache\n        name = frame.f_code.co_name\n        if not name: name = '???'\n        fn = self.canonic(frame.f_code.co_filename)",
        "detail": "protobuf.Lib.bdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "kind": 2,
        "importPath": "protobuf.Lib.bdb",
        "description": "protobuf.Lib.bdb",
        "peekOfCode": "def set_trace():\n    \"\"\"Start debugging with a Bdb instance from the caller's frame.\"\"\"\n    Bdb().set_trace()\nclass Breakpoint:\n    \"\"\"Breakpoint class.\n    Implements temporary breakpoints, ignore counts, disabling and\n    (re)-enabling, and conditionals.\n    Breakpoints are indexed by number through bpbynumber and by\n    the (file, line) tuple using bplist.  The former points to a\n    single instance of class Breakpoint.  The latter points to a",
        "detail": "protobuf.Lib.bdb",
        "documentation": {}
    },
    {
        "label": "checkfuncname",
        "kind": 2,
        "importPath": "protobuf.Lib.bdb",
        "description": "protobuf.Lib.bdb",
        "peekOfCode": "def checkfuncname(b, frame):\n    \"\"\"Return True if break should happen here.\n    Whether a break should happen depends on the way that b (the breakpoint)\n    was set.  If it was set via line number, check if b.line is the same as\n    the one in the frame.  If it was set via function name, check if this is\n    the right function and if it is on the first executable line.\n    \"\"\"\n    if not b.funcname:\n        # Breakpoint was set via line number.\n        if b.line != frame.f_lineno:",
        "detail": "protobuf.Lib.bdb",
        "documentation": {}
    },
    {
        "label": "effective",
        "kind": 2,
        "importPath": "protobuf.Lib.bdb",
        "description": "protobuf.Lib.bdb",
        "peekOfCode": "def effective(file, line, frame):\n    \"\"\"Return (active breakpoint, delete temporary flag) or (None, None) as\n       breakpoint to act upon.\n       The \"active breakpoint\" is the first entry in bplist[line, file] (which\n       must exist) that is enabled, for which checkfuncname is True, and that\n       has neither a False condition nor a positive ignore count.  The flag,\n       meaning that a temporary breakpoint should be deleted, is False only\n       when the condiion cannot be evaluated (in which case, ignore count is\n       ignored).\n       If no such entry exists, then (None, None) is returned.",
        "detail": "protobuf.Lib.bdb",
        "documentation": {}
    },
    {
        "label": "foo",
        "kind": 2,
        "importPath": "protobuf.Lib.bdb",
        "description": "protobuf.Lib.bdb",
        "peekOfCode": "def foo(n):\n    print('foo(', n, ')')\n    x = bar(n*10)\n    print('bar returned', x)\ndef bar(a):\n    print('bar(', a, ')')\n    return a/2\ndef test():\n    t = Tdb()\n    t.run('import bdb; bdb.foo(10)')",
        "detail": "protobuf.Lib.bdb",
        "documentation": {}
    },
    {
        "label": "bar",
        "kind": 2,
        "importPath": "protobuf.Lib.bdb",
        "description": "protobuf.Lib.bdb",
        "peekOfCode": "def bar(a):\n    print('bar(', a, ')')\n    return a/2\ndef test():\n    t = Tdb()\n    t.run('import bdb; bdb.foo(10)')",
        "detail": "protobuf.Lib.bdb",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "protobuf.Lib.bdb",
        "description": "protobuf.Lib.bdb",
        "peekOfCode": "def test():\n    t = Tdb()\n    t.run('import bdb; bdb.foo(10)')",
        "detail": "protobuf.Lib.bdb",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.bdb",
        "description": "protobuf.Lib.bdb",
        "peekOfCode": "__all__ = [\"BdbQuit\", \"Bdb\", \"Breakpoint\"]\nGENERATOR_AND_COROUTINE_FLAGS = CO_GENERATOR | CO_COROUTINE | CO_ASYNC_GENERATOR\nclass BdbQuit(Exception):\n    \"\"\"Exception to give up completely.\"\"\"\nclass Bdb:\n    \"\"\"Generic Python debugger base class.\n    This class takes care of details of the trace facility;\n    a derived class should implement user interaction.\n    The standard debugger class (pdb.Pdb) is an example.\n    The optional skip argument must be an iterable of glob-style",
        "detail": "protobuf.Lib.bdb",
        "documentation": {}
    },
    {
        "label": "GENERATOR_AND_COROUTINE_FLAGS",
        "kind": 5,
        "importPath": "protobuf.Lib.bdb",
        "description": "protobuf.Lib.bdb",
        "peekOfCode": "GENERATOR_AND_COROUTINE_FLAGS = CO_GENERATOR | CO_COROUTINE | CO_ASYNC_GENERATOR\nclass BdbQuit(Exception):\n    \"\"\"Exception to give up completely.\"\"\"\nclass Bdb:\n    \"\"\"Generic Python debugger base class.\n    This class takes care of details of the trace facility;\n    a derived class should implement user interaction.\n    The standard debugger class (pdb.Pdb) is an example.\n    The optional skip argument must be an iterable of glob-style\n    module name patterns.  The debugger will not step into frames",
        "detail": "protobuf.Lib.bdb",
        "documentation": {}
    },
    {
        "label": "Error",
        "kind": 6,
        "importPath": "protobuf.Lib.binhex",
        "description": "protobuf.Lib.binhex",
        "peekOfCode": "class Error(Exception):\n    pass\n# States (what have we written)\n_DID_HEADER = 0\n_DID_DATA = 1\n# Various constants\nREASONABLY_LARGE = 32768  # Minimal amount we pass the rle-coder\nLINELEN = 64\nRUNCHAR = b\"\\x90\"\n#",
        "detail": "protobuf.Lib.binhex",
        "documentation": {}
    },
    {
        "label": "FInfo",
        "kind": 6,
        "importPath": "protobuf.Lib.binhex",
        "description": "protobuf.Lib.binhex",
        "peekOfCode": "class FInfo:\n    def __init__(self):\n        self.Type = '????'\n        self.Creator = '????'\n        self.Flags = 0\ndef getfileinfo(name):\n    finfo = FInfo()\n    with io.open(name, 'rb') as fp:\n        # Quick check for textfile\n        data = fp.read(512)",
        "detail": "protobuf.Lib.binhex",
        "documentation": {}
    },
    {
        "label": "openrsrc",
        "kind": 6,
        "importPath": "protobuf.Lib.binhex",
        "description": "protobuf.Lib.binhex",
        "peekOfCode": "class openrsrc:\n    def __init__(self, *args):\n        pass\n    def read(self, *args):\n        return b''\n    def write(self, *args):\n        pass\n    def close(self):\n        pass\n# DeprecationWarning is already emitted on \"import binhex\". There is no need",
        "detail": "protobuf.Lib.binhex",
        "documentation": {}
    },
    {
        "label": "_Hqxcoderengine",
        "kind": 6,
        "importPath": "protobuf.Lib.binhex",
        "description": "protobuf.Lib.binhex",
        "peekOfCode": "class _Hqxcoderengine:\n    \"\"\"Write data to the coder in 3-byte chunks\"\"\"\n    def __init__(self, ofp):\n        self.ofp = ofp\n        self.data = b''\n        self.hqxdata = b''\n        self.linelen = LINELEN - 1\n    def write(self, data):\n        self.data = self.data + data\n        datalen = len(self.data)",
        "detail": "protobuf.Lib.binhex",
        "documentation": {}
    },
    {
        "label": "_Rlecoderengine",
        "kind": 6,
        "importPath": "protobuf.Lib.binhex",
        "description": "protobuf.Lib.binhex",
        "peekOfCode": "class _Rlecoderengine:\n    \"\"\"Write data to the RLE-coder in suitably large chunks\"\"\"\n    def __init__(self, ofp):\n        self.ofp = ofp\n        self.data = b''\n    def write(self, data):\n        self.data = self.data + data\n        if len(self.data) < REASONABLY_LARGE:\n            return\n        with _ignore_deprecation_warning():",
        "detail": "protobuf.Lib.binhex",
        "documentation": {}
    },
    {
        "label": "BinHex",
        "kind": 6,
        "importPath": "protobuf.Lib.binhex",
        "description": "protobuf.Lib.binhex",
        "peekOfCode": "class BinHex:\n    def __init__(self, name_finfo_dlen_rlen, ofp):\n        name, finfo, dlen, rlen = name_finfo_dlen_rlen\n        close_on_error = False\n        if isinstance(ofp, str):\n            ofname = ofp\n            ofp = io.open(ofname, 'wb')\n            close_on_error = True\n        try:\n            ofp.write(b'(This file must be converted with BinHex 4.0)\\r\\r:')",
        "detail": "protobuf.Lib.binhex",
        "documentation": {}
    },
    {
        "label": "_Hqxdecoderengine",
        "kind": 6,
        "importPath": "protobuf.Lib.binhex",
        "description": "protobuf.Lib.binhex",
        "peekOfCode": "class _Hqxdecoderengine:\n    \"\"\"Read data via the decoder in 4-byte chunks\"\"\"\n    def __init__(self, ifp):\n        self.ifp = ifp\n        self.eof = 0\n    def read(self, totalwtd):\n        \"\"\"Read at least wtd bytes (or until EOF)\"\"\"\n        decdata = b''\n        wtd = totalwtd\n        #",
        "detail": "protobuf.Lib.binhex",
        "documentation": {}
    },
    {
        "label": "_Rledecoderengine",
        "kind": 6,
        "importPath": "protobuf.Lib.binhex",
        "description": "protobuf.Lib.binhex",
        "peekOfCode": "class _Rledecoderengine:\n    \"\"\"Read data via the RLE-coder\"\"\"\n    def __init__(self, ifp):\n        self.ifp = ifp\n        self.pre_buffer = b''\n        self.post_buffer = b''\n        self.eof = 0\n    def read(self, wtd):\n        if wtd > len(self.post_buffer):\n            self._fill(wtd - len(self.post_buffer))",
        "detail": "protobuf.Lib.binhex",
        "documentation": {}
    },
    {
        "label": "HexBin",
        "kind": 6,
        "importPath": "protobuf.Lib.binhex",
        "description": "protobuf.Lib.binhex",
        "peekOfCode": "class HexBin:\n    def __init__(self, ifp):\n        if isinstance(ifp, str):\n            ifp = io.open(ifp, 'rb')\n        #\n        # Find initial colon.\n        #\n        while True:\n            ch = ifp.read(1)\n            if not ch:",
        "detail": "protobuf.Lib.binhex",
        "documentation": {}
    },
    {
        "label": "getfileinfo",
        "kind": 2,
        "importPath": "protobuf.Lib.binhex",
        "description": "protobuf.Lib.binhex",
        "peekOfCode": "def getfileinfo(name):\n    finfo = FInfo()\n    with io.open(name, 'rb') as fp:\n        # Quick check for textfile\n        data = fp.read(512)\n        if 0 not in data:\n            finfo.Type = 'TEXT'\n        fp.seek(0, 2)\n        dsize = fp.tell()\n    dir, file = os.path.split(name)",
        "detail": "protobuf.Lib.binhex",
        "documentation": {}
    },
    {
        "label": "binhex",
        "kind": 2,
        "importPath": "protobuf.Lib.binhex",
        "description": "protobuf.Lib.binhex",
        "peekOfCode": "def binhex(inp, out):\n    \"\"\"binhex(infilename, outfilename): create binhex-encoded copy of a file\"\"\"\n    finfo = getfileinfo(inp)\n    ofp = BinHex(finfo, out)\n    with io.open(inp, 'rb') as ifp:\n        # XXXX Do textfile translation on non-mac systems\n        while True:\n            d = ifp.read(128000)\n            if not d: break\n            ofp.write(d)",
        "detail": "protobuf.Lib.binhex",
        "documentation": {}
    },
    {
        "label": "hexbin",
        "kind": 2,
        "importPath": "protobuf.Lib.binhex",
        "description": "protobuf.Lib.binhex",
        "peekOfCode": "def hexbin(inp, out):\n    \"\"\"hexbin(infilename, outfilename) - Decode binhexed file\"\"\"\n    ifp = HexBin(inp)\n    finfo = ifp.FInfo\n    if not out:\n        out = ifp.FName\n    with io.open(out, 'wb') as ofp:\n        # XXXX Do translation on non-mac systems\n        while True:\n            d = ifp.read(128000)",
        "detail": "protobuf.Lib.binhex",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.binhex",
        "description": "protobuf.Lib.binhex",
        "peekOfCode": "__all__ = [\"binhex\",\"hexbin\",\"Error\"]\nclass Error(Exception):\n    pass\n# States (what have we written)\n_DID_HEADER = 0\n_DID_DATA = 1\n# Various constants\nREASONABLY_LARGE = 32768  # Minimal amount we pass the rle-coder\nLINELEN = 64\nRUNCHAR = b\"\\x90\"",
        "detail": "protobuf.Lib.binhex",
        "documentation": {}
    },
    {
        "label": "_DID_HEADER",
        "kind": 5,
        "importPath": "protobuf.Lib.binhex",
        "description": "protobuf.Lib.binhex",
        "peekOfCode": "_DID_HEADER = 0\n_DID_DATA = 1\n# Various constants\nREASONABLY_LARGE = 32768  # Minimal amount we pass the rle-coder\nLINELEN = 64\nRUNCHAR = b\"\\x90\"\n#\n# This code is no longer byte-order dependent\nclass FInfo:\n    def __init__(self):",
        "detail": "protobuf.Lib.binhex",
        "documentation": {}
    },
    {
        "label": "_DID_DATA",
        "kind": 5,
        "importPath": "protobuf.Lib.binhex",
        "description": "protobuf.Lib.binhex",
        "peekOfCode": "_DID_DATA = 1\n# Various constants\nREASONABLY_LARGE = 32768  # Minimal amount we pass the rle-coder\nLINELEN = 64\nRUNCHAR = b\"\\x90\"\n#\n# This code is no longer byte-order dependent\nclass FInfo:\n    def __init__(self):\n        self.Type = '????'",
        "detail": "protobuf.Lib.binhex",
        "documentation": {}
    },
    {
        "label": "REASONABLY_LARGE",
        "kind": 5,
        "importPath": "protobuf.Lib.binhex",
        "description": "protobuf.Lib.binhex",
        "peekOfCode": "REASONABLY_LARGE = 32768  # Minimal amount we pass the rle-coder\nLINELEN = 64\nRUNCHAR = b\"\\x90\"\n#\n# This code is no longer byte-order dependent\nclass FInfo:\n    def __init__(self):\n        self.Type = '????'\n        self.Creator = '????'\n        self.Flags = 0",
        "detail": "protobuf.Lib.binhex",
        "documentation": {}
    },
    {
        "label": "LINELEN",
        "kind": 5,
        "importPath": "protobuf.Lib.binhex",
        "description": "protobuf.Lib.binhex",
        "peekOfCode": "LINELEN = 64\nRUNCHAR = b\"\\x90\"\n#\n# This code is no longer byte-order dependent\nclass FInfo:\n    def __init__(self):\n        self.Type = '????'\n        self.Creator = '????'\n        self.Flags = 0\ndef getfileinfo(name):",
        "detail": "protobuf.Lib.binhex",
        "documentation": {}
    },
    {
        "label": "RUNCHAR",
        "kind": 5,
        "importPath": "protobuf.Lib.binhex",
        "description": "protobuf.Lib.binhex",
        "peekOfCode": "RUNCHAR = b\"\\x90\"\n#\n# This code is no longer byte-order dependent\nclass FInfo:\n    def __init__(self):\n        self.Type = '????'\n        self.Creator = '????'\n        self.Flags = 0\ndef getfileinfo(name):\n    finfo = FInfo()",
        "detail": "protobuf.Lib.binhex",
        "documentation": {}
    },
    {
        "label": "insort_right",
        "kind": 2,
        "importPath": "protobuf.Lib.bisect",
        "description": "protobuf.Lib.bisect",
        "peekOfCode": "def insort_right(a, x, lo=0, hi=None, *, key=None):\n    \"\"\"Insert item x in list a, and keep it sorted assuming a is sorted.\n    If x is already in a, insert it to the right of the rightmost x.\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n    if key is None:\n        lo = bisect_right(a, x, lo, hi)\n    else:\n        lo = bisect_right(a, key(x), lo, hi, key=key)",
        "detail": "protobuf.Lib.bisect",
        "documentation": {}
    },
    {
        "label": "bisect_right",
        "kind": 2,
        "importPath": "protobuf.Lib.bisect",
        "description": "protobuf.Lib.bisect",
        "peekOfCode": "def bisect_right(a, x, lo=0, hi=None, *, key=None):\n    \"\"\"Return the index where to insert item x in list a, assuming a is sorted.\n    The return value i is such that all e in a[:i] have e <= x, and all e in\n    a[i:] have e > x.  So if x already appears in the list, a.insert(i, x) will\n    insert just after the rightmost x already there.\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n    if lo < 0:\n        raise ValueError('lo must be non-negative')",
        "detail": "protobuf.Lib.bisect",
        "documentation": {}
    },
    {
        "label": "insort_left",
        "kind": 2,
        "importPath": "protobuf.Lib.bisect",
        "description": "protobuf.Lib.bisect",
        "peekOfCode": "def insort_left(a, x, lo=0, hi=None, *, key=None):\n    \"\"\"Insert item x in list a, and keep it sorted assuming a is sorted.\n    If x is already in a, insert it to the left of the leftmost x.\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n    if key is None:\n        lo = bisect_left(a, x, lo, hi)\n    else:\n        lo = bisect_left(a, key(x), lo, hi, key=key)",
        "detail": "protobuf.Lib.bisect",
        "documentation": {}
    },
    {
        "label": "bisect_left",
        "kind": 2,
        "importPath": "protobuf.Lib.bisect",
        "description": "protobuf.Lib.bisect",
        "peekOfCode": "def bisect_left(a, x, lo=0, hi=None, *, key=None):\n    \"\"\"Return the index where to insert item x in list a, assuming a is sorted.\n    The return value i is such that all e in a[:i] have e < x, and all e in\n    a[i:] have e >= x.  So if x already appears in the list, a.insert(i, x) will\n    insert just before the leftmost x already there.\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n    if lo < 0:\n        raise ValueError('lo must be non-negative')",
        "detail": "protobuf.Lib.bisect",
        "documentation": {}
    },
    {
        "label": "bisect",
        "kind": 5,
        "importPath": "protobuf.Lib.bisect",
        "description": "protobuf.Lib.bisect",
        "peekOfCode": "bisect = bisect_right\ninsort = insort_right",
        "detail": "protobuf.Lib.bisect",
        "documentation": {}
    },
    {
        "label": "insort",
        "kind": 5,
        "importPath": "protobuf.Lib.bisect",
        "description": "protobuf.Lib.bisect",
        "peekOfCode": "insort = insort_right",
        "detail": "protobuf.Lib.bisect",
        "documentation": {}
    },
    {
        "label": "BZ2File",
        "kind": 6,
        "importPath": "protobuf.Lib.bz2",
        "description": "protobuf.Lib.bz2",
        "peekOfCode": "class BZ2File(_compression.BaseStream):\n    \"\"\"A file object providing transparent bzip2 (de)compression.\n    A BZ2File can act as a wrapper for an existing file object, or refer\n    directly to a named file on disk.\n    Note that BZ2File provides a *binary* file interface - data read is\n    returned as bytes, and data to be written should be given as bytes.\n    \"\"\"\n    def __init__(self, filename, mode=\"r\", *, compresslevel=9):\n        \"\"\"Open a bzip2-compressed file.\n        If filename is a str, bytes, or PathLike object, it gives the",
        "detail": "protobuf.Lib.bz2",
        "documentation": {}
    },
    {
        "label": "open",
        "kind": 2,
        "importPath": "protobuf.Lib.bz2",
        "description": "protobuf.Lib.bz2",
        "peekOfCode": "def open(filename, mode=\"rb\", compresslevel=9,\n         encoding=None, errors=None, newline=None):\n    \"\"\"Open a bzip2-compressed file in binary or text mode.\n    The filename argument can be an actual filename (a str, bytes, or\n    PathLike object), or an existing file object to read from or write\n    to.\n    The mode argument can be \"r\", \"rb\", \"w\", \"wb\", \"x\", \"xb\", \"a\" or\n    \"ab\" for binary mode, or \"rt\", \"wt\", \"xt\" or \"at\" for text mode.\n    The default mode is \"rb\", and the default compresslevel is 9.\n    For binary mode, this function is equivalent to the BZ2File",
        "detail": "protobuf.Lib.bz2",
        "documentation": {}
    },
    {
        "label": "compress",
        "kind": 2,
        "importPath": "protobuf.Lib.bz2",
        "description": "protobuf.Lib.bz2",
        "peekOfCode": "def compress(data, compresslevel=9):\n    \"\"\"Compress a block of data.\n    compresslevel, if given, must be a number between 1 and 9.\n    For incremental compression, use a BZ2Compressor object instead.\n    \"\"\"\n    comp = BZ2Compressor(compresslevel)\n    return comp.compress(data) + comp.flush()\ndef decompress(data):\n    \"\"\"Decompress a block of data.\n    For incremental decompression, use a BZ2Decompressor object instead.",
        "detail": "protobuf.Lib.bz2",
        "documentation": {}
    },
    {
        "label": "decompress",
        "kind": 2,
        "importPath": "protobuf.Lib.bz2",
        "description": "protobuf.Lib.bz2",
        "peekOfCode": "def decompress(data):\n    \"\"\"Decompress a block of data.\n    For incremental decompression, use a BZ2Decompressor object instead.\n    \"\"\"\n    results = []\n    while data:\n        decomp = BZ2Decompressor()\n        try:\n            res = decomp.decompress(data)\n        except OSError:",
        "detail": "protobuf.Lib.bz2",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.bz2",
        "description": "protobuf.Lib.bz2",
        "peekOfCode": "__all__ = [\"BZ2File\", \"BZ2Compressor\", \"BZ2Decompressor\",\n           \"open\", \"compress\", \"decompress\"]\n__author__ = \"Nadeem Vawda <nadeem.vawda@gmail.com>\"\nfrom builtins import open as _builtin_open\nimport io\nimport os\nimport _compression\nfrom _bz2 import BZ2Compressor, BZ2Decompressor\n_MODE_CLOSED   = 0\n_MODE_READ     = 1",
        "detail": "protobuf.Lib.bz2",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "protobuf.Lib.bz2",
        "description": "protobuf.Lib.bz2",
        "peekOfCode": "__author__ = \"Nadeem Vawda <nadeem.vawda@gmail.com>\"\nfrom builtins import open as _builtin_open\nimport io\nimport os\nimport _compression\nfrom _bz2 import BZ2Compressor, BZ2Decompressor\n_MODE_CLOSED   = 0\n_MODE_READ     = 1\n# Value 2 no longer used\n_MODE_WRITE    = 3",
        "detail": "protobuf.Lib.bz2",
        "documentation": {}
    },
    {
        "label": "IllegalMonthError",
        "kind": 6,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "class IllegalMonthError(ValueError):\n    def __init__(self, month):\n        self.month = month\n    def __str__(self):\n        return \"bad month number %r; must be 1-12\" % self.month\nclass IllegalWeekdayError(ValueError):\n    def __init__(self, weekday):\n        self.weekday = weekday\n    def __str__(self):\n        return \"bad weekday number %r; must be 0 (Monday) to 6 (Sunday)\" % self.weekday",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "IllegalWeekdayError",
        "kind": 6,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "class IllegalWeekdayError(ValueError):\n    def __init__(self, weekday):\n        self.weekday = weekday\n    def __str__(self):\n        return \"bad weekday number %r; must be 0 (Monday) to 6 (Sunday)\" % self.weekday\n# Constants for months referenced later\nJanuary = 1\nFebruary = 2\n# Number of days per month (except for February in leap years)\nmdays = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "_localized_month",
        "kind": 6,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "class _localized_month:\n    _months = [datetime.date(2001, i+1, 1).strftime for i in range(12)]\n    _months.insert(0, lambda x: \"\")\n    def __init__(self, format):\n        self.format = format\n    def __getitem__(self, i):\n        funcs = self._months[i]\n        if isinstance(i, slice):\n            return [f(self.format) for f in funcs]\n        else:",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "_localized_day",
        "kind": 6,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "class _localized_day:\n    # January 1, 2001, was a Monday.\n    _days = [datetime.date(2001, 1, i+1).strftime for i in range(7)]\n    def __init__(self, format):\n        self.format = format\n    def __getitem__(self, i):\n        funcs = self._days[i]\n        if isinstance(i, slice):\n            return [f(self.format) for f in funcs]\n        else:",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "Calendar",
        "kind": 6,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "class Calendar(object):\n    \"\"\"\n    Base calendar class. This class doesn't do any formatting. It simply\n    provides data to subclasses.\n    \"\"\"\n    def __init__(self, firstweekday=0):\n        self.firstweekday = firstweekday # 0 = Monday, 6 = Sunday\n    def getfirstweekday(self):\n        return self._firstweekday % 7\n    def setfirstweekday(self, firstweekday):",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "TextCalendar",
        "kind": 6,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "class TextCalendar(Calendar):\n    \"\"\"\n    Subclass of Calendar that outputs a calendar as a simple plain text\n    similar to the UNIX program cal.\n    \"\"\"\n    def prweek(self, theweek, width):\n        \"\"\"\n        Print a single week (no newline).\n        \"\"\"\n        print(self.formatweek(theweek, width), end='')",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "HTMLCalendar",
        "kind": 6,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "class HTMLCalendar(Calendar):\n    \"\"\"\n    This calendar returns complete HTML pages.\n    \"\"\"\n    # CSS classes for the day <td>s\n    cssclasses = [\"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"]\n    # CSS classes for the day <th>s\n    cssclasses_weekday_head = cssclasses\n    # CSS class for the days before and after current month\n    cssclass_noday = \"noday\"",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "different_locale",
        "kind": 6,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "class different_locale:\n    def __init__(self, locale):\n        self.locale = locale\n    def __enter__(self):\n        self.oldlocale = _locale.getlocale(_locale.LC_TIME)\n        _locale.setlocale(_locale.LC_TIME, self.locale)\n    def __exit__(self, *args):\n        _locale.setlocale(_locale.LC_TIME, self.oldlocale)\nclass LocaleTextCalendar(TextCalendar):\n    \"\"\"",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "LocaleTextCalendar",
        "kind": 6,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "class LocaleTextCalendar(TextCalendar):\n    \"\"\"\n    This class can be passed a locale name in the constructor and will return\n    month and weekday names in the specified locale. If this locale includes\n    an encoding all strings containing month and weekday names will be returned\n    as unicode.\n    \"\"\"\n    def __init__(self, firstweekday=0, locale=None):\n        TextCalendar.__init__(self, firstweekday)\n        if locale is None:",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "LocaleHTMLCalendar",
        "kind": 6,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "class LocaleHTMLCalendar(HTMLCalendar):\n    \"\"\"\n    This class can be passed a locale name in the constructor and will return\n    month and weekday names in the specified locale. If this locale includes\n    an encoding all strings containing month and weekday names will be returned\n    as unicode.\n    \"\"\"\n    def __init__(self, firstweekday=0, locale=None):\n        HTMLCalendar.__init__(self, firstweekday)\n        if locale is None:",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "isleap",
        "kind": 2,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "def isleap(year):\n    \"\"\"Return True for leap years, False for non-leap years.\"\"\"\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\ndef leapdays(y1, y2):\n    \"\"\"Return number of leap years in range [y1, y2).\n       Assume y1 <= y2.\"\"\"\n    y1 -= 1\n    y2 -= 1\n    return (y2//4 - y1//4) - (y2//100 - y1//100) + (y2//400 - y1//400)\ndef weekday(year, month, day):",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "leapdays",
        "kind": 2,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "def leapdays(y1, y2):\n    \"\"\"Return number of leap years in range [y1, y2).\n       Assume y1 <= y2.\"\"\"\n    y1 -= 1\n    y2 -= 1\n    return (y2//4 - y1//4) - (y2//100 - y1//100) + (y2//400 - y1//400)\ndef weekday(year, month, day):\n    \"\"\"Return weekday (0-6 ~ Mon-Sun) for year, month (1-12), day (1-31).\"\"\"\n    if not datetime.MINYEAR <= year <= datetime.MAXYEAR:\n        year = 2000 + year % 400",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "weekday",
        "kind": 2,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "def weekday(year, month, day):\n    \"\"\"Return weekday (0-6 ~ Mon-Sun) for year, month (1-12), day (1-31).\"\"\"\n    if not datetime.MINYEAR <= year <= datetime.MAXYEAR:\n        year = 2000 + year % 400\n    return datetime.date(year, month, day).weekday()\ndef monthrange(year, month):\n    \"\"\"Return weekday (0-6 ~ Mon-Sun) and number of days (28-31) for\n       year, month.\"\"\"\n    if not 1 <= month <= 12:\n        raise IllegalMonthError(month)",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "monthrange",
        "kind": 2,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "def monthrange(year, month):\n    \"\"\"Return weekday (0-6 ~ Mon-Sun) and number of days (28-31) for\n       year, month.\"\"\"\n    if not 1 <= month <= 12:\n        raise IllegalMonthError(month)\n    day1 = weekday(year, month, 1)\n    ndays = mdays[month] + (month == February and isleap(year))\n    return day1, ndays\ndef _monthlen(year, month):\n    return mdays[month] + (month == February and isleap(year))",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "setfirstweekday",
        "kind": 2,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "def setfirstweekday(firstweekday):\n    if not MONDAY <= firstweekday <= SUNDAY:\n        raise IllegalWeekdayError(firstweekday)\n    c.firstweekday = firstweekday\nmonthcalendar = c.monthdayscalendar\nprweek = c.prweek\nweek = c.formatweek\nweekheader = c.formatweekheader\nprmonth = c.prmonth\nmonth = c.formatmonth",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "format",
        "kind": 2,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "def format(cols, colwidth=_colwidth, spacing=_spacing):\n    \"\"\"Prints multi-column formatting for year calendars\"\"\"\n    print(formatstring(cols, colwidth, spacing))\ndef formatstring(cols, colwidth=_colwidth, spacing=_spacing):\n    \"\"\"Returns a string formatted from n strings, centered within n columns.\"\"\"\n    spacing *= ' '\n    return spacing.join(c.center(colwidth) for c in cols)\nEPOCH = 1970\n_EPOCH_ORD = datetime.date(EPOCH, 1, 1).toordinal()\ndef timegm(tuple):",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "formatstring",
        "kind": 2,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "def formatstring(cols, colwidth=_colwidth, spacing=_spacing):\n    \"\"\"Returns a string formatted from n strings, centered within n columns.\"\"\"\n    spacing *= ' '\n    return spacing.join(c.center(colwidth) for c in cols)\nEPOCH = 1970\n_EPOCH_ORD = datetime.date(EPOCH, 1, 1).toordinal()\ndef timegm(tuple):\n    \"\"\"Unrelated but handy function to calculate Unix timestamp from GMT.\"\"\"\n    year, month, day, hour, minute, second = tuple[:6]\n    days = datetime.date(year, month, 1).toordinal() - _EPOCH_ORD + day - 1",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "timegm",
        "kind": 2,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "def timegm(tuple):\n    \"\"\"Unrelated but handy function to calculate Unix timestamp from GMT.\"\"\"\n    year, month, day, hour, minute, second = tuple[:6]\n    days = datetime.date(year, month, 1).toordinal() - _EPOCH_ORD + day - 1\n    hours = days*24 + hour\n    minutes = hours*60 + minute\n    seconds = minutes*60 + second\n    return seconds\ndef main(args):\n    import argparse",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "def main(args):\n    import argparse\n    parser = argparse.ArgumentParser()\n    textgroup = parser.add_argument_group('text only arguments')\n    htmlgroup = parser.add_argument_group('html only arguments')\n    textgroup.add_argument(\n        \"-w\", \"--width\",\n        type=int, default=2,\n        help=\"width of date column (default 2)\"\n    )",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "__all__ = [\"IllegalMonthError\", \"IllegalWeekdayError\", \"setfirstweekday\",\n           \"firstweekday\", \"isleap\", \"leapdays\", \"weekday\", \"monthrange\",\n           \"monthcalendar\", \"prmonth\", \"month\", \"prcal\", \"calendar\",\n           \"timegm\", \"month_name\", \"month_abbr\", \"day_name\", \"day_abbr\",\n           \"Calendar\", \"TextCalendar\", \"HTMLCalendar\", \"LocaleTextCalendar\",\n           \"LocaleHTMLCalendar\", \"weekheader\",\n           \"MONDAY\", \"TUESDAY\", \"WEDNESDAY\", \"THURSDAY\", \"FRIDAY\",\n           \"SATURDAY\", \"SUNDAY\"]\n# Exception raised for bad input (with string parameter for details)\nerror = ValueError",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "error",
        "kind": 5,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "error = ValueError\n# Exceptions raised for bad input\nclass IllegalMonthError(ValueError):\n    def __init__(self, month):\n        self.month = month\n    def __str__(self):\n        return \"bad month number %r; must be 1-12\" % self.month\nclass IllegalWeekdayError(ValueError):\n    def __init__(self, weekday):\n        self.weekday = weekday",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "January",
        "kind": 5,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "January = 1\nFebruary = 2\n# Number of days per month (except for February in leap years)\nmdays = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n# This module used to have hard-coded lists of day and month names, as\n# English strings.  The classes following emulate a read-only version of\n# that, but supply localized names.  Note that the values are computed\n# fresh on each call, in case the user changes locale between calls.\nclass _localized_month:\n    _months = [datetime.date(2001, i+1, 1).strftime for i in range(12)]",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "February",
        "kind": 5,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "February = 2\n# Number of days per month (except for February in leap years)\nmdays = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n# This module used to have hard-coded lists of day and month names, as\n# English strings.  The classes following emulate a read-only version of\n# that, but supply localized names.  Note that the values are computed\n# fresh on each call, in case the user changes locale between calls.\nclass _localized_month:\n    _months = [datetime.date(2001, i+1, 1).strftime for i in range(12)]\n    _months.insert(0, lambda x: \"\")",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "mdays",
        "kind": 5,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "mdays = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n# This module used to have hard-coded lists of day and month names, as\n# English strings.  The classes following emulate a read-only version of\n# that, but supply localized names.  Note that the values are computed\n# fresh on each call, in case the user changes locale between calls.\nclass _localized_month:\n    _months = [datetime.date(2001, i+1, 1).strftime for i in range(12)]\n    _months.insert(0, lambda x: \"\")\n    def __init__(self, format):\n        self.format = format",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "day_name",
        "kind": 5,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "day_name = _localized_day('%A')\nday_abbr = _localized_day('%a')\n# Full and abbreviated names of months (1-based arrays!!!)\nmonth_name = _localized_month('%B')\nmonth_abbr = _localized_month('%b')\n# Constants for weekdays\n(MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY) = range(7)\ndef isleap(year):\n    \"\"\"Return True for leap years, False for non-leap years.\"\"\"\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "day_abbr",
        "kind": 5,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "day_abbr = _localized_day('%a')\n# Full and abbreviated names of months (1-based arrays!!!)\nmonth_name = _localized_month('%B')\nmonth_abbr = _localized_month('%b')\n# Constants for weekdays\n(MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY) = range(7)\ndef isleap(year):\n    \"\"\"Return True for leap years, False for non-leap years.\"\"\"\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\ndef leapdays(y1, y2):",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "month_name",
        "kind": 5,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "month_name = _localized_month('%B')\nmonth_abbr = _localized_month('%b')\n# Constants for weekdays\n(MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY) = range(7)\ndef isleap(year):\n    \"\"\"Return True for leap years, False for non-leap years.\"\"\"\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\ndef leapdays(y1, y2):\n    \"\"\"Return number of leap years in range [y1, y2).\n       Assume y1 <= y2.\"\"\"",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "month_abbr",
        "kind": 5,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "month_abbr = _localized_month('%b')\n# Constants for weekdays\n(MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY) = range(7)\ndef isleap(year):\n    \"\"\"Return True for leap years, False for non-leap years.\"\"\"\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\ndef leapdays(y1, y2):\n    \"\"\"Return number of leap years in range [y1, y2).\n       Assume y1 <= y2.\"\"\"\n    y1 -= 1",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "c",
        "kind": 5,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "c = TextCalendar()\nfirstweekday = c.getfirstweekday\ndef setfirstweekday(firstweekday):\n    if not MONDAY <= firstweekday <= SUNDAY:\n        raise IllegalWeekdayError(firstweekday)\n    c.firstweekday = firstweekday\nmonthcalendar = c.monthdayscalendar\nprweek = c.prweek\nweek = c.formatweek\nweekheader = c.formatweekheader",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "firstweekday",
        "kind": 5,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "firstweekday = c.getfirstweekday\ndef setfirstweekday(firstweekday):\n    if not MONDAY <= firstweekday <= SUNDAY:\n        raise IllegalWeekdayError(firstweekday)\n    c.firstweekday = firstweekday\nmonthcalendar = c.monthdayscalendar\nprweek = c.prweek\nweek = c.formatweek\nweekheader = c.formatweekheader\nprmonth = c.prmonth",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "monthcalendar",
        "kind": 5,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "monthcalendar = c.monthdayscalendar\nprweek = c.prweek\nweek = c.formatweek\nweekheader = c.formatweekheader\nprmonth = c.prmonth\nmonth = c.formatmonth\ncalendar = c.formatyear\nprcal = c.pryear\n# Spacing of month columns for multi-column year calendar\n_colwidth = 7*3 - 1         # Amount printed by prweek()",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "prweek",
        "kind": 5,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "prweek = c.prweek\nweek = c.formatweek\nweekheader = c.formatweekheader\nprmonth = c.prmonth\nmonth = c.formatmonth\ncalendar = c.formatyear\nprcal = c.pryear\n# Spacing of month columns for multi-column year calendar\n_colwidth = 7*3 - 1         # Amount printed by prweek()\n_spacing = 6                # Number of spaces between columns",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "week",
        "kind": 5,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "week = c.formatweek\nweekheader = c.formatweekheader\nprmonth = c.prmonth\nmonth = c.formatmonth\ncalendar = c.formatyear\nprcal = c.pryear\n# Spacing of month columns for multi-column year calendar\n_colwidth = 7*3 - 1         # Amount printed by prweek()\n_spacing = 6                # Number of spaces between columns\ndef format(cols, colwidth=_colwidth, spacing=_spacing):",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "weekheader",
        "kind": 5,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "weekheader = c.formatweekheader\nprmonth = c.prmonth\nmonth = c.formatmonth\ncalendar = c.formatyear\nprcal = c.pryear\n# Spacing of month columns for multi-column year calendar\n_colwidth = 7*3 - 1         # Amount printed by prweek()\n_spacing = 6                # Number of spaces between columns\ndef format(cols, colwidth=_colwidth, spacing=_spacing):\n    \"\"\"Prints multi-column formatting for year calendars\"\"\"",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "prmonth",
        "kind": 5,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "prmonth = c.prmonth\nmonth = c.formatmonth\ncalendar = c.formatyear\nprcal = c.pryear\n# Spacing of month columns for multi-column year calendar\n_colwidth = 7*3 - 1         # Amount printed by prweek()\n_spacing = 6                # Number of spaces between columns\ndef format(cols, colwidth=_colwidth, spacing=_spacing):\n    \"\"\"Prints multi-column formatting for year calendars\"\"\"\n    print(formatstring(cols, colwidth, spacing))",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "month",
        "kind": 5,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "month = c.formatmonth\ncalendar = c.formatyear\nprcal = c.pryear\n# Spacing of month columns for multi-column year calendar\n_colwidth = 7*3 - 1         # Amount printed by prweek()\n_spacing = 6                # Number of spaces between columns\ndef format(cols, colwidth=_colwidth, spacing=_spacing):\n    \"\"\"Prints multi-column formatting for year calendars\"\"\"\n    print(formatstring(cols, colwidth, spacing))\ndef formatstring(cols, colwidth=_colwidth, spacing=_spacing):",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "calendar",
        "kind": 5,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "calendar = c.formatyear\nprcal = c.pryear\n# Spacing of month columns for multi-column year calendar\n_colwidth = 7*3 - 1         # Amount printed by prweek()\n_spacing = 6                # Number of spaces between columns\ndef format(cols, colwidth=_colwidth, spacing=_spacing):\n    \"\"\"Prints multi-column formatting for year calendars\"\"\"\n    print(formatstring(cols, colwidth, spacing))\ndef formatstring(cols, colwidth=_colwidth, spacing=_spacing):\n    \"\"\"Returns a string formatted from n strings, centered within n columns.\"\"\"",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "prcal",
        "kind": 5,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "prcal = c.pryear\n# Spacing of month columns for multi-column year calendar\n_colwidth = 7*3 - 1         # Amount printed by prweek()\n_spacing = 6                # Number of spaces between columns\ndef format(cols, colwidth=_colwidth, spacing=_spacing):\n    \"\"\"Prints multi-column formatting for year calendars\"\"\"\n    print(formatstring(cols, colwidth, spacing))\ndef formatstring(cols, colwidth=_colwidth, spacing=_spacing):\n    \"\"\"Returns a string formatted from n strings, centered within n columns.\"\"\"\n    spacing *= ' '",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "_colwidth",
        "kind": 5,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "_colwidth = 7*3 - 1         # Amount printed by prweek()\n_spacing = 6                # Number of spaces between columns\ndef format(cols, colwidth=_colwidth, spacing=_spacing):\n    \"\"\"Prints multi-column formatting for year calendars\"\"\"\n    print(formatstring(cols, colwidth, spacing))\ndef formatstring(cols, colwidth=_colwidth, spacing=_spacing):\n    \"\"\"Returns a string formatted from n strings, centered within n columns.\"\"\"\n    spacing *= ' '\n    return spacing.join(c.center(colwidth) for c in cols)\nEPOCH = 1970",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "_spacing",
        "kind": 5,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "_spacing = 6                # Number of spaces between columns\ndef format(cols, colwidth=_colwidth, spacing=_spacing):\n    \"\"\"Prints multi-column formatting for year calendars\"\"\"\n    print(formatstring(cols, colwidth, spacing))\ndef formatstring(cols, colwidth=_colwidth, spacing=_spacing):\n    \"\"\"Returns a string formatted from n strings, centered within n columns.\"\"\"\n    spacing *= ' '\n    return spacing.join(c.center(colwidth) for c in cols)\nEPOCH = 1970\n_EPOCH_ORD = datetime.date(EPOCH, 1, 1).toordinal()",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "EPOCH",
        "kind": 5,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "EPOCH = 1970\n_EPOCH_ORD = datetime.date(EPOCH, 1, 1).toordinal()\ndef timegm(tuple):\n    \"\"\"Unrelated but handy function to calculate Unix timestamp from GMT.\"\"\"\n    year, month, day, hour, minute, second = tuple[:6]\n    days = datetime.date(year, month, 1).toordinal() - _EPOCH_ORD + day - 1\n    hours = days*24 + hour\n    minutes = hours*60 + minute\n    seconds = minutes*60 + second\n    return seconds",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "_EPOCH_ORD",
        "kind": 5,
        "importPath": "protobuf.Lib.calendar",
        "description": "protobuf.Lib.calendar",
        "peekOfCode": "_EPOCH_ORD = datetime.date(EPOCH, 1, 1).toordinal()\ndef timegm(tuple):\n    \"\"\"Unrelated but handy function to calculate Unix timestamp from GMT.\"\"\"\n    year, month, day, hour, minute, second = tuple[:6]\n    days = datetime.date(year, month, 1).toordinal() - _EPOCH_ORD + day - 1\n    hours = days*24 + hour\n    minutes = hours*60 + minute\n    seconds = minutes*60 + second\n    return seconds\ndef main(args):",
        "detail": "protobuf.Lib.calendar",
        "documentation": {}
    },
    {
        "label": "MiniFieldStorage",
        "kind": 6,
        "importPath": "protobuf.Lib.cgi",
        "description": "protobuf.Lib.cgi",
        "peekOfCode": "class MiniFieldStorage:\n    \"\"\"Like FieldStorage, for use when no file uploads are possible.\"\"\"\n    # Dummy attributes\n    filename = None\n    list = None\n    type = None\n    file = None\n    type_options = {}\n    disposition = None\n    disposition_options = {}",
        "detail": "protobuf.Lib.cgi",
        "documentation": {}
    },
    {
        "label": "FieldStorage",
        "kind": 6,
        "importPath": "protobuf.Lib.cgi",
        "description": "protobuf.Lib.cgi",
        "peekOfCode": "class FieldStorage:\n    \"\"\"Store a sequence of fields, reading multipart/form-data.\n    This class provides naming, typing, files stored on disk, and\n    more.  At the top level, it is accessible like a dictionary, whose\n    keys are the field names.  (Note: None can occur as a field name.)\n    The items are either a Python list (if there's multiple values) or\n    another FieldStorage or MiniFieldStorage object.  If it's a single\n    object, it has the following attributes:\n    name: the field name, if specified; otherwise None\n    filename: the filename, if specified; otherwise None; this is the",
        "detail": "protobuf.Lib.cgi",
        "documentation": {}
    },
    {
        "label": "initlog",
        "kind": 2,
        "importPath": "protobuf.Lib.cgi",
        "description": "protobuf.Lib.cgi",
        "peekOfCode": "def initlog(*allargs):\n    \"\"\"Write a log message, if there is a log file.\n    Even though this function is called initlog(), you should always\n    use log(); log is a variable that is set either to initlog\n    (initially), to dolog (once the log file has been opened), or to\n    nolog (when logging is disabled).\n    The first argument is a format string; the remaining arguments (if\n    any) are arguments to the % operator, so e.g.\n        log(\"%s: %s\", \"a\", \"b\")\n    will write \"a: b\" to the log file, followed by a newline.",
        "detail": "protobuf.Lib.cgi",
        "documentation": {}
    },
    {
        "label": "dolog",
        "kind": 2,
        "importPath": "protobuf.Lib.cgi",
        "description": "protobuf.Lib.cgi",
        "peekOfCode": "def dolog(fmt, *args):\n    \"\"\"Write a log message to the log file.  See initlog() for docs.\"\"\"\n    logfp.write(fmt%args + \"\\n\")\ndef nolog(*allargs):\n    \"\"\"Dummy function, assigned to log when logging is disabled.\"\"\"\n    pass\ndef closelog():\n    \"\"\"Close the log file.\"\"\"\n    global log, logfile, logfp\n    logfile = ''",
        "detail": "protobuf.Lib.cgi",
        "documentation": {}
    },
    {
        "label": "nolog",
        "kind": 2,
        "importPath": "protobuf.Lib.cgi",
        "description": "protobuf.Lib.cgi",
        "peekOfCode": "def nolog(*allargs):\n    \"\"\"Dummy function, assigned to log when logging is disabled.\"\"\"\n    pass\ndef closelog():\n    \"\"\"Close the log file.\"\"\"\n    global log, logfile, logfp\n    logfile = ''\n    if logfp:\n        logfp.close()\n        logfp = None",
        "detail": "protobuf.Lib.cgi",
        "documentation": {}
    },
    {
        "label": "closelog",
        "kind": 2,
        "importPath": "protobuf.Lib.cgi",
        "description": "protobuf.Lib.cgi",
        "peekOfCode": "def closelog():\n    \"\"\"Close the log file.\"\"\"\n    global log, logfile, logfp\n    logfile = ''\n    if logfp:\n        logfp.close()\n        logfp = None\n    log = initlog\nlog = initlog           # The current logging function\n# Parsing functions",
        "detail": "protobuf.Lib.cgi",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "protobuf.Lib.cgi",
        "description": "protobuf.Lib.cgi",
        "peekOfCode": "def parse(fp=None, environ=os.environ, keep_blank_values=0,\n          strict_parsing=0, separator='&'):\n    \"\"\"Parse a query in the environment or from a file (default stdin)\n        Arguments, all optional:\n        fp              : file pointer; default: sys.stdin.buffer\n        environ         : environment dictionary; default: os.environ\n        keep_blank_values: flag indicating whether blank values in\n            percent-encoded forms should be treated as blank strings.\n            A true value indicates that blanks should be retained as\n            blank strings.  The default false value indicates that",
        "detail": "protobuf.Lib.cgi",
        "documentation": {}
    },
    {
        "label": "parse_multipart",
        "kind": 2,
        "importPath": "protobuf.Lib.cgi",
        "description": "protobuf.Lib.cgi",
        "peekOfCode": "def parse_multipart(fp, pdict, encoding=\"utf-8\", errors=\"replace\", separator='&'):\n    \"\"\"Parse multipart input.\n    Arguments:\n    fp   : input file\n    pdict: dictionary containing other parameters of content-type header\n    encoding, errors: request encoding and error handler, passed to\n        FieldStorage\n    Returns a dictionary just like parse_qs(): keys are the field names, each\n    value is a list of values for that field. For non-file fields, the value\n    is a list of strings.",
        "detail": "protobuf.Lib.cgi",
        "documentation": {}
    },
    {
        "label": "parse_header",
        "kind": 2,
        "importPath": "protobuf.Lib.cgi",
        "description": "protobuf.Lib.cgi",
        "peekOfCode": "def parse_header(line):\n    \"\"\"Parse a Content-type like header.\n    Return the main content-type and a dictionary of options.\n    \"\"\"\n    parts = _parseparam(';' + line)\n    key = parts.__next__()\n    pdict = {}\n    for p in parts:\n        i = p.find('=')\n        if i >= 0:",
        "detail": "protobuf.Lib.cgi",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "protobuf.Lib.cgi",
        "description": "protobuf.Lib.cgi",
        "peekOfCode": "def test(environ=os.environ):\n    \"\"\"Robust test CGI script, usable as main program.\n    Write minimal HTTP headers and dump all information provided to\n    the script in HTML form.\n    \"\"\"\n    print(\"Content-type: text/html\")\n    print()\n    sys.stderr = sys.stdout\n    try:\n        form = FieldStorage()   # Replace with other classes to test those",
        "detail": "protobuf.Lib.cgi",
        "documentation": {}
    },
    {
        "label": "print_exception",
        "kind": 2,
        "importPath": "protobuf.Lib.cgi",
        "description": "protobuf.Lib.cgi",
        "peekOfCode": "def print_exception(type=None, value=None, tb=None, limit=None):\n    if type is None:\n        type, value, tb = sys.exc_info()\n    import traceback\n    print()\n    print(\"<H3>Traceback (most recent call last):</H3>\")\n    list = traceback.format_tb(tb, limit) + \\\n           traceback.format_exception_only(type, value)\n    print(\"<PRE>%s<B>%s</B></PRE>\" % (\n        html.escape(\"\".join(list[:-1])),",
        "detail": "protobuf.Lib.cgi",
        "documentation": {}
    },
    {
        "label": "print_environ",
        "kind": 2,
        "importPath": "protobuf.Lib.cgi",
        "description": "protobuf.Lib.cgi",
        "peekOfCode": "def print_environ(environ=os.environ):\n    \"\"\"Dump the shell environment as HTML.\"\"\"\n    keys = sorted(environ.keys())\n    print()\n    print(\"<H3>Shell Environment:</H3>\")\n    print(\"<DL>\")\n    for key in keys:\n        print(\"<DT>\", html.escape(key), \"<DD>\", html.escape(environ[key]))\n    print(\"</DL>\")\n    print()",
        "detail": "protobuf.Lib.cgi",
        "documentation": {}
    },
    {
        "label": "print_form",
        "kind": 2,
        "importPath": "protobuf.Lib.cgi",
        "description": "protobuf.Lib.cgi",
        "peekOfCode": "def print_form(form):\n    \"\"\"Dump the contents of a form as HTML.\"\"\"\n    keys = sorted(form.keys())\n    print()\n    print(\"<H3>Form Contents:</H3>\")\n    if not keys:\n        print(\"<P>No form fields.\")\n    print(\"<DL>\")\n    for key in keys:\n        print(\"<DT>\" + html.escape(key) + \":\", end=' ')",
        "detail": "protobuf.Lib.cgi",
        "documentation": {}
    },
    {
        "label": "print_directory",
        "kind": 2,
        "importPath": "protobuf.Lib.cgi",
        "description": "protobuf.Lib.cgi",
        "peekOfCode": "def print_directory():\n    \"\"\"Dump the current directory as HTML.\"\"\"\n    print()\n    print(\"<H3>Current Working Directory:</H3>\")\n    try:\n        pwd = os.getcwd()\n    except OSError as msg:\n        print(\"OSError:\", html.escape(str(msg)))\n    else:\n        print(html.escape(pwd))",
        "detail": "protobuf.Lib.cgi",
        "documentation": {}
    },
    {
        "label": "print_arguments",
        "kind": 2,
        "importPath": "protobuf.Lib.cgi",
        "description": "protobuf.Lib.cgi",
        "peekOfCode": "def print_arguments():\n    print()\n    print(\"<H3>Command Line Arguments:</H3>\")\n    print()\n    print(sys.argv)\n    print()\ndef print_environ_usage():\n    \"\"\"Dump a list of environment variables used by CGI as HTML.\"\"\"\n    print(\"\"\"\n<H3>These environment variables could have been set:</H3>",
        "detail": "protobuf.Lib.cgi",
        "documentation": {}
    },
    {
        "label": "print_environ_usage",
        "kind": 2,
        "importPath": "protobuf.Lib.cgi",
        "description": "protobuf.Lib.cgi",
        "peekOfCode": "def print_environ_usage():\n    \"\"\"Dump a list of environment variables used by CGI as HTML.\"\"\"\n    print(\"\"\"\n<H3>These environment variables could have been set:</H3>\n<UL>\n<LI>AUTH_TYPE\n<LI>CONTENT_LENGTH\n<LI>CONTENT_TYPE\n<LI>DATE_GMT\n<LI>DATE_LOCAL",
        "detail": "protobuf.Lib.cgi",
        "documentation": {}
    },
    {
        "label": "valid_boundary",
        "kind": 2,
        "importPath": "protobuf.Lib.cgi",
        "description": "protobuf.Lib.cgi",
        "peekOfCode": "def valid_boundary(s):\n    import re\n    if isinstance(s, bytes):\n        _vb_pattern = b\"^[ -~]{0,200}[!-~]$\"\n    else:\n        _vb_pattern = \"^[ -~]{0,200}[!-~]$\"\n    return re.match(_vb_pattern, s)\n# Invoke mainline\n# ===============\n# Call test() when this file is run as a script (not imported as a module)",
        "detail": "protobuf.Lib.cgi",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "protobuf.Lib.cgi",
        "description": "protobuf.Lib.cgi",
        "peekOfCode": "__version__ = \"2.6\"\n# Imports\n# =======\nfrom io import StringIO, BytesIO, TextIOWrapper\nfrom collections.abc import Mapping\nimport sys\nimport os\nimport urllib.parse\nfrom email.parser import FeedParser\nfrom email.message import Message",
        "detail": "protobuf.Lib.cgi",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.cgi",
        "description": "protobuf.Lib.cgi",
        "peekOfCode": "__all__ = [\"MiniFieldStorage\", \"FieldStorage\", \"parse\", \"parse_multipart\",\n           \"parse_header\", \"test\", \"print_exception\", \"print_environ\",\n           \"print_form\", \"print_directory\", \"print_arguments\",\n           \"print_environ_usage\"]\n# Logging support\n# ===============\nlogfile = \"\"            # Filename to log to, if not empty\nlogfp = None            # File object to log to, if not None\ndef initlog(*allargs):\n    \"\"\"Write a log message, if there is a log file.",
        "detail": "protobuf.Lib.cgi",
        "documentation": {}
    },
    {
        "label": "logfile",
        "kind": 5,
        "importPath": "protobuf.Lib.cgi",
        "description": "protobuf.Lib.cgi",
        "peekOfCode": "logfile = \"\"            # Filename to log to, if not empty\nlogfp = None            # File object to log to, if not None\ndef initlog(*allargs):\n    \"\"\"Write a log message, if there is a log file.\n    Even though this function is called initlog(), you should always\n    use log(); log is a variable that is set either to initlog\n    (initially), to dolog (once the log file has been opened), or to\n    nolog (when logging is disabled).\n    The first argument is a format string; the remaining arguments (if\n    any) are arguments to the % operator, so e.g.",
        "detail": "protobuf.Lib.cgi",
        "documentation": {}
    },
    {
        "label": "logfp",
        "kind": 5,
        "importPath": "protobuf.Lib.cgi",
        "description": "protobuf.Lib.cgi",
        "peekOfCode": "logfp = None            # File object to log to, if not None\ndef initlog(*allargs):\n    \"\"\"Write a log message, if there is a log file.\n    Even though this function is called initlog(), you should always\n    use log(); log is a variable that is set either to initlog\n    (initially), to dolog (once the log file has been opened), or to\n    nolog (when logging is disabled).\n    The first argument is a format string; the remaining arguments (if\n    any) are arguments to the % operator, so e.g.\n        log(\"%s: %s\", \"a\", \"b\")",
        "detail": "protobuf.Lib.cgi",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "protobuf.Lib.cgi",
        "description": "protobuf.Lib.cgi",
        "peekOfCode": "log = initlog           # The current logging function\n# Parsing functions\n# =================\n# Maximum input we will accept when REQUEST_METHOD is POST\n# 0 ==> unlimited input\nmaxlen = 0\ndef parse(fp=None, environ=os.environ, keep_blank_values=0,\n          strict_parsing=0, separator='&'):\n    \"\"\"Parse a query in the environment or from a file (default stdin)\n        Arguments, all optional:",
        "detail": "protobuf.Lib.cgi",
        "documentation": {}
    },
    {
        "label": "maxlen",
        "kind": 5,
        "importPath": "protobuf.Lib.cgi",
        "description": "protobuf.Lib.cgi",
        "peekOfCode": "maxlen = 0\ndef parse(fp=None, environ=os.environ, keep_blank_values=0,\n          strict_parsing=0, separator='&'):\n    \"\"\"Parse a query in the environment or from a file (default stdin)\n        Arguments, all optional:\n        fp              : file pointer; default: sys.stdin.buffer\n        environ         : environment dictionary; default: os.environ\n        keep_blank_values: flag indicating whether blank values in\n            percent-encoded forms should be treated as blank strings.\n            A true value indicates that blanks should be retained as",
        "detail": "protobuf.Lib.cgi",
        "documentation": {}
    },
    {
        "label": "Hook",
        "kind": 6,
        "importPath": "protobuf.Lib.cgitb",
        "description": "protobuf.Lib.cgitb",
        "peekOfCode": "class Hook:\n    \"\"\"A hook to replace sys.excepthook that shows tracebacks in HTML.\"\"\"\n    def __init__(self, display=1, logdir=None, context=5, file=None,\n                 format=\"html\"):\n        self.display = display          # send tracebacks to browser if true\n        self.logdir = logdir            # log tracebacks to files if not None\n        self.context = context          # number of source code lines per frame\n        self.file = file or sys.stdout  # place to send the output\n        self.format = format\n    def __call__(self, etype, evalue, etb):",
        "detail": "protobuf.Lib.cgitb",
        "documentation": {}
    },
    {
        "label": "reset",
        "kind": 2,
        "importPath": "protobuf.Lib.cgitb",
        "description": "protobuf.Lib.cgitb",
        "peekOfCode": "def reset():\n    \"\"\"Return a string that resets the CGI and browser to a known state.\"\"\"\n    return '''<!--: spam\nContent-Type: text/html\n<body bgcolor=\"#f0f0f8\"><font color=\"#f0f0f8\" size=\"-5\"> -->\n<body bgcolor=\"#f0f0f8\"><font color=\"#f0f0f8\" size=\"-5\"> --> -->\n</font> </font> </font> </script> </object> </blockquote> </pre>\n</table> </table> </table> </table> </table> </font> </font> </font>'''\n__UNDEF__ = []                          # a special sentinel object\ndef small(text):",
        "detail": "protobuf.Lib.cgitb",
        "documentation": {}
    },
    {
        "label": "small",
        "kind": 2,
        "importPath": "protobuf.Lib.cgitb",
        "description": "protobuf.Lib.cgitb",
        "peekOfCode": "def small(text):\n    if text:\n        return '<small>' + text + '</small>'\n    else:\n        return ''\ndef strong(text):\n    if text:\n        return '<strong>' + text + '</strong>'\n    else:\n        return ''",
        "detail": "protobuf.Lib.cgitb",
        "documentation": {}
    },
    {
        "label": "strong",
        "kind": 2,
        "importPath": "protobuf.Lib.cgitb",
        "description": "protobuf.Lib.cgitb",
        "peekOfCode": "def strong(text):\n    if text:\n        return '<strong>' + text + '</strong>'\n    else:\n        return ''\ndef grey(text):\n    if text:\n        return '<font color=\"#909090\">' + text + '</font>'\n    else:\n        return ''",
        "detail": "protobuf.Lib.cgitb",
        "documentation": {}
    },
    {
        "label": "grey",
        "kind": 2,
        "importPath": "protobuf.Lib.cgitb",
        "description": "protobuf.Lib.cgitb",
        "peekOfCode": "def grey(text):\n    if text:\n        return '<font color=\"#909090\">' + text + '</font>'\n    else:\n        return ''\ndef lookup(name, frame, locals):\n    \"\"\"Find the value for a given name in the given environment.\"\"\"\n    if name in locals:\n        return 'local', locals[name]\n    if name in frame.f_globals:",
        "detail": "protobuf.Lib.cgitb",
        "documentation": {}
    },
    {
        "label": "lookup",
        "kind": 2,
        "importPath": "protobuf.Lib.cgitb",
        "description": "protobuf.Lib.cgitb",
        "peekOfCode": "def lookup(name, frame, locals):\n    \"\"\"Find the value for a given name in the given environment.\"\"\"\n    if name in locals:\n        return 'local', locals[name]\n    if name in frame.f_globals:\n        return 'global', frame.f_globals[name]\n    if '__builtins__' in frame.f_globals:\n        builtins = frame.f_globals['__builtins__']\n        if type(builtins) is type({}):\n            if name in builtins:",
        "detail": "protobuf.Lib.cgitb",
        "documentation": {}
    },
    {
        "label": "scanvars",
        "kind": 2,
        "importPath": "protobuf.Lib.cgitb",
        "description": "protobuf.Lib.cgitb",
        "peekOfCode": "def scanvars(reader, frame, locals):\n    \"\"\"Scan one logical line of Python and look up values of variables used.\"\"\"\n    vars, lasttoken, parent, prefix, value = [], None, None, '', __UNDEF__\n    for ttype, token, start, end, line in tokenize.generate_tokens(reader):\n        if ttype == tokenize.NEWLINE: break\n        if ttype == tokenize.NAME and token not in keyword.kwlist:\n            if lasttoken == '.':\n                if parent is not __UNDEF__:\n                    value = getattr(parent, token, __UNDEF__)\n                    vars.append((prefix + token, prefix, value))",
        "detail": "protobuf.Lib.cgitb",
        "documentation": {}
    },
    {
        "label": "html",
        "kind": 2,
        "importPath": "protobuf.Lib.cgitb",
        "description": "protobuf.Lib.cgitb",
        "peekOfCode": "def html(einfo, context=5):\n    \"\"\"Return a nice HTML document describing a given traceback.\"\"\"\n    etype, evalue, etb = einfo\n    if isinstance(etype, type):\n        etype = etype.__name__\n    pyver = 'Python ' + sys.version.split()[0] + ': ' + sys.executable\n    date = time.ctime(time.time())\n    head = '<body bgcolor=\"#f0f0f8\">' + pydoc.html.heading(\n        '<big><big>%s</big></big>' %\n        strong(pydoc.html.escape(str(etype))),",
        "detail": "protobuf.Lib.cgitb",
        "documentation": {}
    },
    {
        "label": "text",
        "kind": 2,
        "importPath": "protobuf.Lib.cgitb",
        "description": "protobuf.Lib.cgitb",
        "peekOfCode": "def text(einfo, context=5):\n    \"\"\"Return a plain text document describing a given traceback.\"\"\"\n    etype, evalue, etb = einfo\n    if isinstance(etype, type):\n        etype = etype.__name__\n    pyver = 'Python ' + sys.version.split()[0] + ': ' + sys.executable\n    date = time.ctime(time.time())\n    head = \"%s\\n%s\\n%s\\n\" % (str(etype), pyver, date) + '''\nA problem occurred in a Python script.  Here is the sequence of\nfunction calls leading up to the error, in the order they occurred.",
        "detail": "protobuf.Lib.cgitb",
        "documentation": {}
    },
    {
        "label": "enable",
        "kind": 2,
        "importPath": "protobuf.Lib.cgitb",
        "description": "protobuf.Lib.cgitb",
        "peekOfCode": "def enable(display=1, logdir=None, context=5, format=\"html\"):\n    \"\"\"Install an exception handler that formats tracebacks as HTML.\n    The optional argument 'display' can be set to 0 to suppress sending the\n    traceback to the browser, and 'logdir' can be set to a directory to cause\n    tracebacks to be written to files there.\"\"\"\n    sys.excepthook = Hook(display=display, logdir=logdir,\n                          context=context, format=format)",
        "detail": "protobuf.Lib.cgitb",
        "documentation": {}
    },
    {
        "label": "__UNDEF__",
        "kind": 5,
        "importPath": "protobuf.Lib.cgitb",
        "description": "protobuf.Lib.cgitb",
        "peekOfCode": "__UNDEF__ = []                          # a special sentinel object\ndef small(text):\n    if text:\n        return '<small>' + text + '</small>'\n    else:\n        return ''\ndef strong(text):\n    if text:\n        return '<strong>' + text + '</strong>'\n    else:",
        "detail": "protobuf.Lib.cgitb",
        "documentation": {}
    },
    {
        "label": "handler",
        "kind": 5,
        "importPath": "protobuf.Lib.cgitb",
        "description": "protobuf.Lib.cgitb",
        "peekOfCode": "handler = Hook().handle\ndef enable(display=1, logdir=None, context=5, format=\"html\"):\n    \"\"\"Install an exception handler that formats tracebacks as HTML.\n    The optional argument 'display' can be set to 0 to suppress sending the\n    traceback to the browser, and 'logdir' can be set to a directory to cause\n    tracebacks to be written to files there.\"\"\"\n    sys.excepthook = Hook(display=display, logdir=logdir,\n                          context=context, format=format)",
        "detail": "protobuf.Lib.cgitb",
        "documentation": {}
    },
    {
        "label": "Chunk",
        "kind": 6,
        "importPath": "protobuf.Lib.chunk",
        "description": "protobuf.Lib.chunk",
        "peekOfCode": "class Chunk:\n    def __init__(self, file, align=True, bigendian=True, inclheader=False):\n        import struct\n        self.closed = False\n        self.align = align      # whether to align to word (2-byte) boundaries\n        if bigendian:\n            strflag = '>'\n        else:\n            strflag = '<'\n        self.file = file",
        "detail": "protobuf.Lib.chunk",
        "documentation": {}
    },
    {
        "label": "Cmd",
        "kind": 6,
        "importPath": "protobuf.Lib.cmd",
        "description": "protobuf.Lib.cmd",
        "peekOfCode": "class Cmd:\n    \"\"\"A simple framework for writing line-oriented command interpreters.\n    These are often useful for test harnesses, administrative tools, and\n    prototypes that will later be wrapped in a more sophisticated interface.\n    A Cmd instance or subclass instance is a line-oriented interpreter\n    framework.  There is no good reason to instantiate Cmd itself; rather,\n    it's useful as a superclass of an interpreter class you define yourself\n    in order to inherit Cmd's methods and encapsulate action methods.\n    \"\"\"\n    prompt = PROMPT",
        "detail": "protobuf.Lib.cmd",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.cmd",
        "description": "protobuf.Lib.cmd",
        "peekOfCode": "__all__ = [\"Cmd\"]\nPROMPT = '(Cmd) '\nIDENTCHARS = string.ascii_letters + string.digits + '_'\nclass Cmd:\n    \"\"\"A simple framework for writing line-oriented command interpreters.\n    These are often useful for test harnesses, administrative tools, and\n    prototypes that will later be wrapped in a more sophisticated interface.\n    A Cmd instance or subclass instance is a line-oriented interpreter\n    framework.  There is no good reason to instantiate Cmd itself; rather,\n    it's useful as a superclass of an interpreter class you define yourself",
        "detail": "protobuf.Lib.cmd",
        "documentation": {}
    },
    {
        "label": "PROMPT",
        "kind": 5,
        "importPath": "protobuf.Lib.cmd",
        "description": "protobuf.Lib.cmd",
        "peekOfCode": "PROMPT = '(Cmd) '\nIDENTCHARS = string.ascii_letters + string.digits + '_'\nclass Cmd:\n    \"\"\"A simple framework for writing line-oriented command interpreters.\n    These are often useful for test harnesses, administrative tools, and\n    prototypes that will later be wrapped in a more sophisticated interface.\n    A Cmd instance or subclass instance is a line-oriented interpreter\n    framework.  There is no good reason to instantiate Cmd itself; rather,\n    it's useful as a superclass of an interpreter class you define yourself\n    in order to inherit Cmd's methods and encapsulate action methods.",
        "detail": "protobuf.Lib.cmd",
        "documentation": {}
    },
    {
        "label": "IDENTCHARS",
        "kind": 5,
        "importPath": "protobuf.Lib.cmd",
        "description": "protobuf.Lib.cmd",
        "peekOfCode": "IDENTCHARS = string.ascii_letters + string.digits + '_'\nclass Cmd:\n    \"\"\"A simple framework for writing line-oriented command interpreters.\n    These are often useful for test harnesses, administrative tools, and\n    prototypes that will later be wrapped in a more sophisticated interface.\n    A Cmd instance or subclass instance is a line-oriented interpreter\n    framework.  There is no good reason to instantiate Cmd itself; rather,\n    it's useful as a superclass of an interpreter class you define yourself\n    in order to inherit Cmd's methods and encapsulate action methods.\n    \"\"\"",
        "detail": "protobuf.Lib.cmd",
        "documentation": {}
    },
    {
        "label": "InteractiveInterpreter",
        "kind": 6,
        "importPath": "protobuf.Lib.code",
        "description": "protobuf.Lib.code",
        "peekOfCode": "class InteractiveInterpreter:\n    \"\"\"Base class for InteractiveConsole.\n    This class deals with parsing and interpreter state (the user's\n    namespace); it doesn't deal with input buffering or prompting or\n    input file naming (the filename is always passed in explicitly).\n    \"\"\"\n    def __init__(self, locals=None):\n        \"\"\"Constructor.\n        The optional 'locals' argument specifies the dictionary in\n        which code will be executed; it defaults to a newly created",
        "detail": "protobuf.Lib.code",
        "documentation": {}
    },
    {
        "label": "InteractiveConsole",
        "kind": 6,
        "importPath": "protobuf.Lib.code",
        "description": "protobuf.Lib.code",
        "peekOfCode": "class InteractiveConsole(InteractiveInterpreter):\n    \"\"\"Closely emulate the behavior of the interactive Python interpreter.\n    This class builds on InteractiveInterpreter and adds prompting\n    using the familiar sys.ps1 and sys.ps2, and input buffering.\n    \"\"\"\n    def __init__(self, locals=None, filename=\"<console>\"):\n        \"\"\"Constructor.\n        The optional locals argument will be passed to the\n        InteractiveInterpreter base class.\n        The optional filename argument should specify the (file)name",
        "detail": "protobuf.Lib.code",
        "documentation": {}
    },
    {
        "label": "interact",
        "kind": 2,
        "importPath": "protobuf.Lib.code",
        "description": "protobuf.Lib.code",
        "peekOfCode": "def interact(banner=None, readfunc=None, local=None, exitmsg=None):\n    \"\"\"Closely emulate the interactive Python interpreter.\n    This is a backwards compatible interface to the InteractiveConsole\n    class.  When readfunc is not specified, it attempts to import the\n    readline module to enable GNU readline if it is available.\n    Arguments (all optional, all default to None):\n    banner -- passed to InteractiveConsole.interact()\n    readfunc -- if not None, replaces InteractiveConsole.raw_input()\n    local -- passed to InteractiveInterpreter.__init__()\n    exitmsg -- passed to InteractiveConsole.interact()",
        "detail": "protobuf.Lib.code",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.code",
        "description": "protobuf.Lib.code",
        "peekOfCode": "__all__ = [\"InteractiveInterpreter\", \"InteractiveConsole\", \"interact\",\n           \"compile_command\"]\nclass InteractiveInterpreter:\n    \"\"\"Base class for InteractiveConsole.\n    This class deals with parsing and interpreter state (the user's\n    namespace); it doesn't deal with input buffering or prompting or\n    input file naming (the filename is always passed in explicitly).\n    \"\"\"\n    def __init__(self, locals=None):\n        \"\"\"Constructor.",
        "detail": "protobuf.Lib.code",
        "documentation": {}
    },
    {
        "label": "CodecInfo",
        "kind": 6,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "class CodecInfo(tuple):\n    \"\"\"Codec details when looking up the codec registry\"\"\"\n    # Private API to allow Python 3.4 to denylist the known non-Unicode\n    # codecs in the standard library. A more general mechanism to\n    # reliably distinguish test encodings from other codecs will hopefully\n    # be defined for Python 3.5\n    #\n    # See http://bugs.python.org/issue19619\n    _is_text_encoding = True # Assume codecs are text encodings by default\n    def __new__(cls, encode, decode, streamreader=None, streamwriter=None,",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "class Codec:\n    \"\"\" Defines the interface for stateless encoders/decoders.\n        The .encode()/.decode() methods may use different error\n        handling schemes by providing the errors argument. These\n        string values are predefined:\n         'strict' - raise a ValueError error (or a subclass)\n         'ignore' - ignore the character and continue with the next\n         'replace' - replace with a suitable replacement character;\n                    Python will use the official U+FFFD REPLACEMENT\n                    CHARACTER for the builtin Unicode codecs on",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "class IncrementalEncoder(object):\n    \"\"\"\n    An IncrementalEncoder encodes an input in multiple steps. The input can\n    be passed piece by piece to the encode() method. The IncrementalEncoder\n    remembers the state of the encoding process between calls to encode().\n    \"\"\"\n    def __init__(self, errors='strict'):\n        \"\"\"\n        Creates an IncrementalEncoder instance.\n        The IncrementalEncoder may use different error handling schemes by",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "BufferedIncrementalEncoder",
        "kind": 6,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "class BufferedIncrementalEncoder(IncrementalEncoder):\n    \"\"\"\n    This subclass of IncrementalEncoder can be used as the baseclass for an\n    incremental encoder if the encoder must keep some of the output in a\n    buffer between calls to encode().\n    \"\"\"\n    def __init__(self, errors='strict'):\n        IncrementalEncoder.__init__(self, errors)\n        # unencoded input that is kept between calls to encode()\n        self.buffer = \"\"",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "class IncrementalDecoder(object):\n    \"\"\"\n    An IncrementalDecoder decodes an input in multiple steps. The input can\n    be passed piece by piece to the decode() method. The IncrementalDecoder\n    remembers the state of the decoding process between calls to decode().\n    \"\"\"\n    def __init__(self, errors='strict'):\n        \"\"\"\n        Create an IncrementalDecoder instance.\n        The IncrementalDecoder may use different error handling schemes by",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "BufferedIncrementalDecoder",
        "kind": 6,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "class BufferedIncrementalDecoder(IncrementalDecoder):\n    \"\"\"\n    This subclass of IncrementalDecoder can be used as the baseclass for an\n    incremental decoder if the decoder must be able to handle incomplete\n    byte sequences.\n    \"\"\"\n    def __init__(self, errors='strict'):\n        IncrementalDecoder.__init__(self, errors)\n        # undecoded input that is kept between calls to decode()\n        self.buffer = b\"\"",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "class StreamWriter(Codec):\n    def __init__(self, stream, errors='strict'):\n        \"\"\" Creates a StreamWriter instance.\n            stream must be a file-like object open for writing.\n            The StreamWriter may use different error handling\n            schemes by providing the errors keyword argument. These\n            parameters are predefined:\n             'strict' - raise a ValueError (or a subclass)\n             'ignore' - ignore the character and continue with the next\n             'replace'- replace with a suitable replacement character",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "class StreamReader(Codec):\n    charbuffertype = str\n    def __init__(self, stream, errors='strict'):\n        \"\"\" Creates a StreamReader instance.\n            stream must be a file-like object open for reading.\n            The StreamReader may use different error handling\n            schemes by providing the errors keyword argument. These\n            parameters are predefined:\n             'strict' - raise a ValueError (or a subclass)\n             'ignore' - ignore the character and continue with the next",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "StreamReaderWriter",
        "kind": 6,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "class StreamReaderWriter:\n    \"\"\" StreamReaderWriter instances allow wrapping streams which\n        work in both read and write modes.\n        The design is such that one can use the factory functions\n        returned by the codec.lookup() function to construct the\n        instance.\n    \"\"\"\n    # Optional attributes set by the file wrappers below\n    encoding = 'unknown'\n    def __init__(self, stream, Reader, Writer, errors='strict'):",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "StreamRecoder",
        "kind": 6,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "class StreamRecoder:\n    \"\"\" StreamRecoder instances translate data from one encoding to another.\n        They use the complete set of APIs returned by the\n        codecs.lookup() function to implement their task.\n        Data written to the StreamRecoder is first decoded into an\n        intermediate format (depending on the \"decode\" codec) and then\n        written to the underlying stream using an instance of the provided\n        Writer class.\n        In the other direction, data is read from the underlying stream using\n        a Reader instance and then encoded and returned to the caller.",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "open",
        "kind": 2,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "def open(filename, mode='r', encoding=None, errors='strict', buffering=-1):\n    \"\"\" Open an encoded file using the given mode and return\n        a wrapped version providing transparent encoding/decoding.\n        Note: The wrapped version will only accept the object format\n        defined by the codecs, i.e. Unicode objects for most builtin\n        codecs. Output is also codec dependent and will usually be\n        Unicode as well.\n        If encoding is not None, then the\n        underlying encoded files are always opened in binary mode.\n        The default file mode is 'r', meaning to open the file in read mode.",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "EncodedFile",
        "kind": 2,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "def EncodedFile(file, data_encoding, file_encoding=None, errors='strict'):\n    \"\"\" Return a wrapped version of file which provides transparent\n        encoding translation.\n        Data written to the wrapped file is decoded according\n        to the given data_encoding and then encoded to the underlying\n        file using file_encoding. The intermediate data type\n        will usually be Unicode but depends on the specified codecs.\n        Bytes read from the file are decoded using file_encoding and then\n        passed back to the caller encoded using data_encoding.\n        If file_encoding is not given, it defaults to data_encoding.",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "getencoder",
        "kind": 2,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "def getencoder(encoding):\n    \"\"\" Lookup up the codec for the given encoding and return\n        its encoder function.\n        Raises a LookupError in case the encoding cannot be found.\n    \"\"\"\n    return lookup(encoding).encode\ndef getdecoder(encoding):\n    \"\"\" Lookup up the codec for the given encoding and return\n        its decoder function.\n        Raises a LookupError in case the encoding cannot be found.",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "getdecoder",
        "kind": 2,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "def getdecoder(encoding):\n    \"\"\" Lookup up the codec for the given encoding and return\n        its decoder function.\n        Raises a LookupError in case the encoding cannot be found.\n    \"\"\"\n    return lookup(encoding).decode\ndef getincrementalencoder(encoding):\n    \"\"\" Lookup up the codec for the given encoding and return\n        its IncrementalEncoder class or factory function.\n        Raises a LookupError in case the encoding cannot be found",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "getincrementalencoder",
        "kind": 2,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "def getincrementalencoder(encoding):\n    \"\"\" Lookup up the codec for the given encoding and return\n        its IncrementalEncoder class or factory function.\n        Raises a LookupError in case the encoding cannot be found\n        or the codecs doesn't provide an incremental encoder.\n    \"\"\"\n    encoder = lookup(encoding).incrementalencoder\n    if encoder is None:\n        raise LookupError(encoding)\n    return encoder",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "getincrementaldecoder",
        "kind": 2,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "def getincrementaldecoder(encoding):\n    \"\"\" Lookup up the codec for the given encoding and return\n        its IncrementalDecoder class or factory function.\n        Raises a LookupError in case the encoding cannot be found\n        or the codecs doesn't provide an incremental decoder.\n    \"\"\"\n    decoder = lookup(encoding).incrementaldecoder\n    if decoder is None:\n        raise LookupError(encoding)\n    return decoder",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "getreader",
        "kind": 2,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "def getreader(encoding):\n    \"\"\" Lookup up the codec for the given encoding and return\n        its StreamReader class or factory function.\n        Raises a LookupError in case the encoding cannot be found.\n    \"\"\"\n    return lookup(encoding).streamreader\ndef getwriter(encoding):\n    \"\"\" Lookup up the codec for the given encoding and return\n        its StreamWriter class or factory function.\n        Raises a LookupError in case the encoding cannot be found.",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "getwriter",
        "kind": 2,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "def getwriter(encoding):\n    \"\"\" Lookup up the codec for the given encoding and return\n        its StreamWriter class or factory function.\n        Raises a LookupError in case the encoding cannot be found.\n    \"\"\"\n    return lookup(encoding).streamwriter\ndef iterencode(iterator, encoding, errors='strict', **kwargs):\n    \"\"\"\n    Encoding iterator.\n    Encodes the input strings from the iterator using an IncrementalEncoder.",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "iterencode",
        "kind": 2,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "def iterencode(iterator, encoding, errors='strict', **kwargs):\n    \"\"\"\n    Encoding iterator.\n    Encodes the input strings from the iterator using an IncrementalEncoder.\n    errors and kwargs are passed through to the IncrementalEncoder\n    constructor.\n    \"\"\"\n    encoder = getincrementalencoder(encoding)(errors, **kwargs)\n    for input in iterator:\n        output = encoder.encode(input)",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "iterdecode",
        "kind": 2,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "def iterdecode(iterator, encoding, errors='strict', **kwargs):\n    \"\"\"\n    Decoding iterator.\n    Decodes the input strings from the iterator using an IncrementalDecoder.\n    errors and kwargs are passed through to the IncrementalDecoder\n    constructor.\n    \"\"\"\n    decoder = getincrementaldecoder(encoding)(errors, **kwargs)\n    for input in iterator:\n        output = decoder.decode(input)",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "make_identity_dict",
        "kind": 2,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "def make_identity_dict(rng):\n    \"\"\" make_identity_dict(rng) -> dict\n        Return a dictionary where elements of the rng sequence are\n        mapped to themselves.\n    \"\"\"\n    return {i:i for i in rng}\ndef make_encoding_map(decoding_map):\n    \"\"\" Creates an encoding map from a decoding map.\n        If a target mapping in the decoding map occurs multiple\n        times, then that target is mapped to None (undefined mapping),",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "make_encoding_map",
        "kind": 2,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "def make_encoding_map(decoding_map):\n    \"\"\" Creates an encoding map from a decoding map.\n        If a target mapping in the decoding map occurs multiple\n        times, then that target is mapped to None (undefined mapping),\n        causing an exception when encountered by the charmap codec\n        during translation.\n        One example where this happens is cp875.py which decodes\n        multiple character to \\\\u001a.\n    \"\"\"\n    m = {}",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "__all__ = [\"register\", \"lookup\", \"open\", \"EncodedFile\", \"BOM\", \"BOM_BE\",\n           \"BOM_LE\", \"BOM32_BE\", \"BOM32_LE\", \"BOM64_BE\", \"BOM64_LE\",\n           \"BOM_UTF8\", \"BOM_UTF16\", \"BOM_UTF16_LE\", \"BOM_UTF16_BE\",\n           \"BOM_UTF32\", \"BOM_UTF32_LE\", \"BOM_UTF32_BE\",\n           \"CodecInfo\", \"Codec\", \"IncrementalEncoder\", \"IncrementalDecoder\",\n           \"StreamReader\", \"StreamWriter\",\n           \"StreamReaderWriter\", \"StreamRecoder\",\n           \"getencoder\", \"getdecoder\", \"getincrementalencoder\",\n           \"getincrementaldecoder\", \"getreader\", \"getwriter\",\n           \"encode\", \"decode\", \"iterencode\", \"iterdecode\",",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "BOM_UTF8",
        "kind": 5,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "BOM_UTF8 = b'\\xef\\xbb\\xbf'\n# UTF-16, little endian\nBOM_LE = BOM_UTF16_LE = b'\\xff\\xfe'\n# UTF-16, big endian\nBOM_BE = BOM_UTF16_BE = b'\\xfe\\xff'\n# UTF-32, little endian\nBOM_UTF32_LE = b'\\xff\\xfe\\x00\\x00'\n# UTF-32, big endian\nBOM_UTF32_BE = b'\\x00\\x00\\xfe\\xff'\nif sys.byteorder == 'little':",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "BOM_LE",
        "kind": 5,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "BOM_LE = BOM_UTF16_LE = b'\\xff\\xfe'\n# UTF-16, big endian\nBOM_BE = BOM_UTF16_BE = b'\\xfe\\xff'\n# UTF-32, little endian\nBOM_UTF32_LE = b'\\xff\\xfe\\x00\\x00'\n# UTF-32, big endian\nBOM_UTF32_BE = b'\\x00\\x00\\xfe\\xff'\nif sys.byteorder == 'little':\n    # UTF-16, native endianness\n    BOM = BOM_UTF16 = BOM_UTF16_LE",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "BOM_BE",
        "kind": 5,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "BOM_BE = BOM_UTF16_BE = b'\\xfe\\xff'\n# UTF-32, little endian\nBOM_UTF32_LE = b'\\xff\\xfe\\x00\\x00'\n# UTF-32, big endian\nBOM_UTF32_BE = b'\\x00\\x00\\xfe\\xff'\nif sys.byteorder == 'little':\n    # UTF-16, native endianness\n    BOM = BOM_UTF16 = BOM_UTF16_LE\n    # UTF-32, native endianness\n    BOM_UTF32 = BOM_UTF32_LE",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "BOM_UTF32_LE",
        "kind": 5,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "BOM_UTF32_LE = b'\\xff\\xfe\\x00\\x00'\n# UTF-32, big endian\nBOM_UTF32_BE = b'\\x00\\x00\\xfe\\xff'\nif sys.byteorder == 'little':\n    # UTF-16, native endianness\n    BOM = BOM_UTF16 = BOM_UTF16_LE\n    # UTF-32, native endianness\n    BOM_UTF32 = BOM_UTF32_LE\nelse:\n    # UTF-16, native endianness",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "BOM_UTF32_BE",
        "kind": 5,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "BOM_UTF32_BE = b'\\x00\\x00\\xfe\\xff'\nif sys.byteorder == 'little':\n    # UTF-16, native endianness\n    BOM = BOM_UTF16 = BOM_UTF16_LE\n    # UTF-32, native endianness\n    BOM_UTF32 = BOM_UTF32_LE\nelse:\n    # UTF-16, native endianness\n    BOM = BOM_UTF16 = BOM_UTF16_BE\n    # UTF-32, native endianness",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "BOM32_LE",
        "kind": 5,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "BOM32_LE = BOM_UTF16_LE\nBOM32_BE = BOM_UTF16_BE\nBOM64_LE = BOM_UTF32_LE\nBOM64_BE = BOM_UTF32_BE\n### Codec base classes (defining the API)\nclass CodecInfo(tuple):\n    \"\"\"Codec details when looking up the codec registry\"\"\"\n    # Private API to allow Python 3.4 to denylist the known non-Unicode\n    # codecs in the standard library. A more general mechanism to\n    # reliably distinguish test encodings from other codecs will hopefully",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "BOM32_BE",
        "kind": 5,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "BOM32_BE = BOM_UTF16_BE\nBOM64_LE = BOM_UTF32_LE\nBOM64_BE = BOM_UTF32_BE\n### Codec base classes (defining the API)\nclass CodecInfo(tuple):\n    \"\"\"Codec details when looking up the codec registry\"\"\"\n    # Private API to allow Python 3.4 to denylist the known non-Unicode\n    # codecs in the standard library. A more general mechanism to\n    # reliably distinguish test encodings from other codecs will hopefully\n    # be defined for Python 3.5",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "BOM64_LE",
        "kind": 5,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "BOM64_LE = BOM_UTF32_LE\nBOM64_BE = BOM_UTF32_BE\n### Codec base classes (defining the API)\nclass CodecInfo(tuple):\n    \"\"\"Codec details when looking up the codec registry\"\"\"\n    # Private API to allow Python 3.4 to denylist the known non-Unicode\n    # codecs in the standard library. A more general mechanism to\n    # reliably distinguish test encodings from other codecs will hopefully\n    # be defined for Python 3.5\n    #",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "BOM64_BE",
        "kind": 5,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "BOM64_BE = BOM_UTF32_BE\n### Codec base classes (defining the API)\nclass CodecInfo(tuple):\n    \"\"\"Codec details when looking up the codec registry\"\"\"\n    # Private API to allow Python 3.4 to denylist the known non-Unicode\n    # codecs in the standard library. A more general mechanism to\n    # reliably distinguish test encodings from other codecs will hopefully\n    # be defined for Python 3.5\n    #\n    # See http://bugs.python.org/issue19619",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "_false",
        "kind": 5,
        "importPath": "protobuf.Lib.codecs",
        "description": "protobuf.Lib.codecs",
        "peekOfCode": "_false = 0\nif _false:\n    import encodings\n### Tests\nif __name__ == '__main__':\n    # Make stdout translate Latin-1 output into UTF-8 output\n    sys.stdout = EncodedFile(sys.stdout, 'latin-1', 'utf-8')\n    # Have stdin translate Latin-1 input into UTF-8 input\n    sys.stdin = EncodedFile(sys.stdin, 'utf-8', 'latin-1')",
        "detail": "protobuf.Lib.codecs",
        "documentation": {}
    },
    {
        "label": "Compile",
        "kind": 6,
        "importPath": "protobuf.Lib.codeop",
        "description": "protobuf.Lib.codeop",
        "peekOfCode": "class Compile:\n    \"\"\"Instances of this class behave much like the built-in compile\n    function, but if one is used to compile text containing a future\n    statement, it \"remembers\" and compiles all subsequent program texts\n    with the statement in force.\"\"\"\n    def __init__(self):\n        self.flags = PyCF_DONT_IMPLY_DEDENT | PyCF_ALLOW_INCOMPLETE_INPUT\n    def __call__(self, source, filename, symbol):\n        codeob = compile(source, filename, symbol, self.flags, True)\n        for feature in _features:",
        "detail": "protobuf.Lib.codeop",
        "documentation": {}
    },
    {
        "label": "CommandCompiler",
        "kind": 6,
        "importPath": "protobuf.Lib.codeop",
        "description": "protobuf.Lib.codeop",
        "peekOfCode": "class CommandCompiler:\n    \"\"\"Instances of this class have __call__ methods identical in\n    signature to compile_command; the difference is that if the\n    instance compiles program text containing a __future__ statement,\n    the instance 'remembers' and compiles all subsequent program texts\n    with the statement in force.\"\"\"\n    def __init__(self,):\n        self.compiler = Compile()\n    def __call__(self, source, filename=\"<input>\", symbol=\"single\"):\n        r\"\"\"Compile a command and determine whether it is incomplete.",
        "detail": "protobuf.Lib.codeop",
        "documentation": {}
    },
    {
        "label": "compile_command",
        "kind": 2,
        "importPath": "protobuf.Lib.codeop",
        "description": "protobuf.Lib.codeop",
        "peekOfCode": "def compile_command(source, filename=\"<input>\", symbol=\"single\"):\n    r\"\"\"Compile a command and determine whether it is incomplete.\n    Arguments:\n    source -- the source string; may contain \\n characters\n    filename -- optional filename from which source was read; default\n                \"<input>\"\n    symbol -- optional grammar start symbol; \"single\" (default), \"exec\"\n              or \"eval\"\n    Return value / exceptions raised:\n    - Return a code object if the command is complete and valid",
        "detail": "protobuf.Lib.codeop",
        "documentation": {}
    },
    {
        "label": "_features",
        "kind": 5,
        "importPath": "protobuf.Lib.codeop",
        "description": "protobuf.Lib.codeop",
        "peekOfCode": "_features = [getattr(__future__, fname)\n             for fname in __future__.all_feature_names]\n__all__ = [\"compile_command\", \"Compile\", \"CommandCompiler\"]\n# The following flags match the values from Include/cpython/compile.h\n# Caveat emptor: These flags are undocumented on purpose and depending\n# on their effect outside the standard library is **unsupported**.\nPyCF_DONT_IMPLY_DEDENT = 0x200          \nPyCF_ALLOW_INCOMPLETE_INPUT = 0x4000\ndef _maybe_compile(compiler, source, filename, symbol):\n    # Check for source consisting of only blank lines and comments.",
        "detail": "protobuf.Lib.codeop",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.codeop",
        "description": "protobuf.Lib.codeop",
        "peekOfCode": "__all__ = [\"compile_command\", \"Compile\", \"CommandCompiler\"]\n# The following flags match the values from Include/cpython/compile.h\n# Caveat emptor: These flags are undocumented on purpose and depending\n# on their effect outside the standard library is **unsupported**.\nPyCF_DONT_IMPLY_DEDENT = 0x200          \nPyCF_ALLOW_INCOMPLETE_INPUT = 0x4000\ndef _maybe_compile(compiler, source, filename, symbol):\n    # Check for source consisting of only blank lines and comments.\n    for line in source.split(\"\\n\"):\n        line = line.strip()",
        "detail": "protobuf.Lib.codeop",
        "documentation": {}
    },
    {
        "label": "PyCF_DONT_IMPLY_DEDENT",
        "kind": 5,
        "importPath": "protobuf.Lib.codeop",
        "description": "protobuf.Lib.codeop",
        "peekOfCode": "PyCF_DONT_IMPLY_DEDENT = 0x200          \nPyCF_ALLOW_INCOMPLETE_INPUT = 0x4000\ndef _maybe_compile(compiler, source, filename, symbol):\n    # Check for source consisting of only blank lines and comments.\n    for line in source.split(\"\\n\"):\n        line = line.strip()\n        if line and line[0] != '#':\n            break               # Leave it alone.\n    else:\n        if symbol != \"eval\":",
        "detail": "protobuf.Lib.codeop",
        "documentation": {}
    },
    {
        "label": "PyCF_ALLOW_INCOMPLETE_INPUT",
        "kind": 5,
        "importPath": "protobuf.Lib.codeop",
        "description": "protobuf.Lib.codeop",
        "peekOfCode": "PyCF_ALLOW_INCOMPLETE_INPUT = 0x4000\ndef _maybe_compile(compiler, source, filename, symbol):\n    # Check for source consisting of only blank lines and comments.\n    for line in source.split(\"\\n\"):\n        line = line.strip()\n        if line and line[0] != '#':\n            break               # Leave it alone.\n    else:\n        if symbol != \"eval\":\n            source = \"pass\"     # Replace it with a 'pass' statement",
        "detail": "protobuf.Lib.codeop",
        "documentation": {}
    },
    {
        "label": "rgb_to_yiq",
        "kind": 2,
        "importPath": "protobuf.Lib.colorsys",
        "description": "protobuf.Lib.colorsys",
        "peekOfCode": "def rgb_to_yiq(r, g, b):\n    y = 0.30*r + 0.59*g + 0.11*b\n    i = 0.74*(r-y) - 0.27*(b-y)\n    q = 0.48*(r-y) + 0.41*(b-y)\n    return (y, i, q)\ndef yiq_to_rgb(y, i, q):\n    # r = y + (0.27*q + 0.41*i) / (0.74*0.41 + 0.27*0.48)\n    # b = y + (0.74*q - 0.48*i) / (0.74*0.41 + 0.27*0.48)\n    # g = y - (0.30*(r-y) + 0.11*(b-y)) / 0.59\n    r = y + 0.9468822170900693*i + 0.6235565819861433*q",
        "detail": "protobuf.Lib.colorsys",
        "documentation": {}
    },
    {
        "label": "yiq_to_rgb",
        "kind": 2,
        "importPath": "protobuf.Lib.colorsys",
        "description": "protobuf.Lib.colorsys",
        "peekOfCode": "def yiq_to_rgb(y, i, q):\n    # r = y + (0.27*q + 0.41*i) / (0.74*0.41 + 0.27*0.48)\n    # b = y + (0.74*q - 0.48*i) / (0.74*0.41 + 0.27*0.48)\n    # g = y - (0.30*(r-y) + 0.11*(b-y)) / 0.59\n    r = y + 0.9468822170900693*i + 0.6235565819861433*q\n    g = y - 0.27478764629897834*i - 0.6356910791873801*q\n    b = y - 1.1085450346420322*i + 1.7090069284064666*q\n    if r < 0.0:\n        r = 0.0\n    if g < 0.0:",
        "detail": "protobuf.Lib.colorsys",
        "documentation": {}
    },
    {
        "label": "rgb_to_hls",
        "kind": 2,
        "importPath": "protobuf.Lib.colorsys",
        "description": "protobuf.Lib.colorsys",
        "peekOfCode": "def rgb_to_hls(r, g, b):\n    maxc = max(r, g, b)\n    minc = min(r, g, b)\n    sumc = (maxc+minc)\n    rangec = (maxc-minc)\n    l = sumc/2.0\n    if minc == maxc:\n        return 0.0, l, 0.0\n    if l <= 0.5:\n        s = rangec / sumc",
        "detail": "protobuf.Lib.colorsys",
        "documentation": {}
    },
    {
        "label": "hls_to_rgb",
        "kind": 2,
        "importPath": "protobuf.Lib.colorsys",
        "description": "protobuf.Lib.colorsys",
        "peekOfCode": "def hls_to_rgb(h, l, s):\n    if s == 0.0:\n        return l, l, l\n    if l <= 0.5:\n        m2 = l * (1.0+s)\n    else:\n        m2 = l+s-(l*s)\n    m1 = 2.0*l - m2\n    return (_v(m1, m2, h+ONE_THIRD), _v(m1, m2, h), _v(m1, m2, h-ONE_THIRD))\ndef _v(m1, m2, hue):",
        "detail": "protobuf.Lib.colorsys",
        "documentation": {}
    },
    {
        "label": "rgb_to_hsv",
        "kind": 2,
        "importPath": "protobuf.Lib.colorsys",
        "description": "protobuf.Lib.colorsys",
        "peekOfCode": "def rgb_to_hsv(r, g, b):\n    maxc = max(r, g, b)\n    minc = min(r, g, b)\n    v = maxc\n    if minc == maxc:\n        return 0.0, 0.0, v\n    s = (maxc-minc) / maxc\n    rc = (maxc-r) / (maxc-minc)\n    gc = (maxc-g) / (maxc-minc)\n    bc = (maxc-b) / (maxc-minc)",
        "detail": "protobuf.Lib.colorsys",
        "documentation": {}
    },
    {
        "label": "hsv_to_rgb",
        "kind": 2,
        "importPath": "protobuf.Lib.colorsys",
        "description": "protobuf.Lib.colorsys",
        "peekOfCode": "def hsv_to_rgb(h, s, v):\n    if s == 0.0:\n        return v, v, v\n    i = int(h*6.0) # XXX assume int() truncates!\n    f = (h*6.0) - i\n    p = v*(1.0 - s)\n    q = v*(1.0 - s*f)\n    t = v*(1.0 - s*(1.0-f))\n    i = i%6\n    if i == 0:",
        "detail": "protobuf.Lib.colorsys",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.colorsys",
        "description": "protobuf.Lib.colorsys",
        "peekOfCode": "__all__ = [\"rgb_to_yiq\",\"yiq_to_rgb\",\"rgb_to_hls\",\"hls_to_rgb\",\n           \"rgb_to_hsv\",\"hsv_to_rgb\"]\n# Some floating point constants\nONE_THIRD = 1.0/3.0\nONE_SIXTH = 1.0/6.0\nTWO_THIRD = 2.0/3.0\n# YIQ: used by composite video signals (linear combinations of RGB)\n# Y: perceived grey level (0.0 == black, 1.0 == white)\n# I, Q: color components\n#",
        "detail": "protobuf.Lib.colorsys",
        "documentation": {}
    },
    {
        "label": "ONE_THIRD",
        "kind": 5,
        "importPath": "protobuf.Lib.colorsys",
        "description": "protobuf.Lib.colorsys",
        "peekOfCode": "ONE_THIRD = 1.0/3.0\nONE_SIXTH = 1.0/6.0\nTWO_THIRD = 2.0/3.0\n# YIQ: used by composite video signals (linear combinations of RGB)\n# Y: perceived grey level (0.0 == black, 1.0 == white)\n# I, Q: color components\n#\n# There are a great many versions of the constants used in these formulae.\n# The ones in this library uses constants from the FCC version of NTSC.\ndef rgb_to_yiq(r, g, b):",
        "detail": "protobuf.Lib.colorsys",
        "documentation": {}
    },
    {
        "label": "ONE_SIXTH",
        "kind": 5,
        "importPath": "protobuf.Lib.colorsys",
        "description": "protobuf.Lib.colorsys",
        "peekOfCode": "ONE_SIXTH = 1.0/6.0\nTWO_THIRD = 2.0/3.0\n# YIQ: used by composite video signals (linear combinations of RGB)\n# Y: perceived grey level (0.0 == black, 1.0 == white)\n# I, Q: color components\n#\n# There are a great many versions of the constants used in these formulae.\n# The ones in this library uses constants from the FCC version of NTSC.\ndef rgb_to_yiq(r, g, b):\n    y = 0.30*r + 0.59*g + 0.11*b",
        "detail": "protobuf.Lib.colorsys",
        "documentation": {}
    },
    {
        "label": "TWO_THIRD",
        "kind": 5,
        "importPath": "protobuf.Lib.colorsys",
        "description": "protobuf.Lib.colorsys",
        "peekOfCode": "TWO_THIRD = 2.0/3.0\n# YIQ: used by composite video signals (linear combinations of RGB)\n# Y: perceived grey level (0.0 == black, 1.0 == white)\n# I, Q: color components\n#\n# There are a great many versions of the constants used in these formulae.\n# The ones in this library uses constants from the FCC version of NTSC.\ndef rgb_to_yiq(r, g, b):\n    y = 0.30*r + 0.59*g + 0.11*b\n    i = 0.74*(r-y) - 0.27*(b-y)",
        "detail": "protobuf.Lib.colorsys",
        "documentation": {}
    },
    {
        "label": "compile_dir",
        "kind": 2,
        "importPath": "protobuf.Lib.compileall",
        "description": "protobuf.Lib.compileall",
        "peekOfCode": "def compile_dir(dir, maxlevels=None, ddir=None, force=False,\n                rx=None, quiet=0, legacy=False, optimize=-1, workers=1,\n                invalidation_mode=None, *, stripdir=None,\n                prependdir=None, limit_sl_dest=None, hardlink_dupes=False):\n    \"\"\"Byte-compile all modules in the given directory tree.\n    Arguments (only dir is required):\n    dir:       the directory to byte-compile\n    maxlevels: maximum recursion level (default `sys.getrecursionlimit()`)\n    ddir:      the directory that will be prepended to the path to the\n               file as it is compiled into each byte-code file.",
        "detail": "protobuf.Lib.compileall",
        "documentation": {}
    },
    {
        "label": "compile_file",
        "kind": 2,
        "importPath": "protobuf.Lib.compileall",
        "description": "protobuf.Lib.compileall",
        "peekOfCode": "def compile_file(fullname, ddir=None, force=False, rx=None, quiet=0,\n                 legacy=False, optimize=-1,\n                 invalidation_mode=None, *, stripdir=None, prependdir=None,\n                 limit_sl_dest=None, hardlink_dupes=False):\n    \"\"\"Byte-compile one file.\n    Arguments (only fullname is required):\n    fullname:  the file to byte-compile\n    ddir:      if given, the directory name compiled in to the\n               byte-code file.\n    force:     if True, force compilation, even if timestamps are up-to-date",
        "detail": "protobuf.Lib.compileall",
        "documentation": {}
    },
    {
        "label": "compile_path",
        "kind": 2,
        "importPath": "protobuf.Lib.compileall",
        "description": "protobuf.Lib.compileall",
        "peekOfCode": "def compile_path(skip_curdir=1, maxlevels=0, force=False, quiet=0,\n                 legacy=False, optimize=-1,\n                 invalidation_mode=None):\n    \"\"\"Byte-compile all module on sys.path.\n    Arguments (all optional):\n    skip_curdir: if true, skip current directory (default True)\n    maxlevels:   max recursion level (default 0)\n    force: as for compile_dir() (default False)\n    quiet: as for compile_dir() (default 0)\n    legacy: as for compile_dir() (default False)",
        "detail": "protobuf.Lib.compileall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "protobuf.Lib.compileall",
        "description": "protobuf.Lib.compileall",
        "peekOfCode": "def main():\n    \"\"\"Script main program.\"\"\"\n    import argparse\n    parser = argparse.ArgumentParser(\n        description='Utilities to support installing Python libraries.')\n    parser.add_argument('-l', action='store_const', const=0,\n                        default=None, dest='maxlevels',\n                        help=\"don't recurse into subdirectories\")\n    parser.add_argument('-r', type=int, dest='recursion',\n                        help=('control the maximum recursion level. '",
        "detail": "protobuf.Lib.compileall",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.compileall",
        "description": "protobuf.Lib.compileall",
        "peekOfCode": "__all__ = [\"compile_dir\",\"compile_file\",\"compile_path\"]\ndef _walk_dir(dir, maxlevels, quiet=0):\n    if quiet < 2 and isinstance(dir, os.PathLike):\n        dir = os.fspath(dir)\n    if not quiet:\n        print('Listing {!r}...'.format(dir))\n    try:\n        names = os.listdir(dir)\n    except OSError:\n        if quiet < 2:",
        "detail": "protobuf.Lib.compileall",
        "documentation": {}
    },
    {
        "label": "Error",
        "kind": 6,
        "importPath": "protobuf.Lib.configparser",
        "description": "protobuf.Lib.configparser",
        "peekOfCode": "class Error(Exception):\n    \"\"\"Base class for ConfigParser exceptions.\"\"\"\n    def __init__(self, msg=''):\n        self.message = msg\n        Exception.__init__(self, msg)\n    def __repr__(self):\n        return self.message\n    __str__ = __repr__\nclass NoSectionError(Error):\n    \"\"\"Raised when no section matches a requested option.\"\"\"",
        "detail": "protobuf.Lib.configparser",
        "documentation": {}
    },
    {
        "label": "NoSectionError",
        "kind": 6,
        "importPath": "protobuf.Lib.configparser",
        "description": "protobuf.Lib.configparser",
        "peekOfCode": "class NoSectionError(Error):\n    \"\"\"Raised when no section matches a requested option.\"\"\"\n    def __init__(self, section):\n        Error.__init__(self, 'No section: %r' % (section,))\n        self.section = section\n        self.args = (section, )\nclass DuplicateSectionError(Error):\n    \"\"\"Raised when a section is repeated in an input source.\n    Possible repetitions that raise this exception are: multiple creation\n    using the API or in strict parsers when a section is found more than once",
        "detail": "protobuf.Lib.configparser",
        "documentation": {}
    },
    {
        "label": "DuplicateSectionError",
        "kind": 6,
        "importPath": "protobuf.Lib.configparser",
        "description": "protobuf.Lib.configparser",
        "peekOfCode": "class DuplicateSectionError(Error):\n    \"\"\"Raised when a section is repeated in an input source.\n    Possible repetitions that raise this exception are: multiple creation\n    using the API or in strict parsers when a section is found more than once\n    in a single input file, string or dictionary.\n    \"\"\"\n    def __init__(self, section, source=None, lineno=None):\n        msg = [repr(section), \" already exists\"]\n        if source is not None:\n            message = [\"While reading from \", repr(source)]",
        "detail": "protobuf.Lib.configparser",
        "documentation": {}
    },
    {
        "label": "DuplicateOptionError",
        "kind": 6,
        "importPath": "protobuf.Lib.configparser",
        "description": "protobuf.Lib.configparser",
        "peekOfCode": "class DuplicateOptionError(Error):\n    \"\"\"Raised by strict parsers when an option is repeated in an input source.\n    Current implementation raises this exception only when an option is found\n    more than once in a single file, string or dictionary.\n    \"\"\"\n    def __init__(self, section, option, source=None, lineno=None):\n        msg = [repr(option), \" in section \", repr(section),\n               \" already exists\"]\n        if source is not None:\n            message = [\"While reading from \", repr(source)]",
        "detail": "protobuf.Lib.configparser",
        "documentation": {}
    },
    {
        "label": "NoOptionError",
        "kind": 6,
        "importPath": "protobuf.Lib.configparser",
        "description": "protobuf.Lib.configparser",
        "peekOfCode": "class NoOptionError(Error):\n    \"\"\"A requested option was not found.\"\"\"\n    def __init__(self, option, section):\n        Error.__init__(self, \"No option %r in section: %r\" %\n                       (option, section))\n        self.option = option\n        self.section = section\n        self.args = (option, section)\nclass InterpolationError(Error):\n    \"\"\"Base class for interpolation-related exceptions.\"\"\"",
        "detail": "protobuf.Lib.configparser",
        "documentation": {}
    },
    {
        "label": "InterpolationError",
        "kind": 6,
        "importPath": "protobuf.Lib.configparser",
        "description": "protobuf.Lib.configparser",
        "peekOfCode": "class InterpolationError(Error):\n    \"\"\"Base class for interpolation-related exceptions.\"\"\"\n    def __init__(self, option, section, msg):\n        Error.__init__(self, msg)\n        self.option = option\n        self.section = section\n        self.args = (option, section, msg)\nclass InterpolationMissingOptionError(InterpolationError):\n    \"\"\"A string substitution required a setting which was not available.\"\"\"\n    def __init__(self, option, section, rawval, reference):",
        "detail": "protobuf.Lib.configparser",
        "documentation": {}
    },
    {
        "label": "InterpolationMissingOptionError",
        "kind": 6,
        "importPath": "protobuf.Lib.configparser",
        "description": "protobuf.Lib.configparser",
        "peekOfCode": "class InterpolationMissingOptionError(InterpolationError):\n    \"\"\"A string substitution required a setting which was not available.\"\"\"\n    def __init__(self, option, section, rawval, reference):\n        msg = (\"Bad value substitution: option {!r} in section {!r} contains \"\n               \"an interpolation key {!r} which is not a valid option name. \"\n               \"Raw value: {!r}\".format(option, section, reference, rawval))\n        InterpolationError.__init__(self, option, section, msg)\n        self.reference = reference\n        self.args = (option, section, rawval, reference)\nclass InterpolationSyntaxError(InterpolationError):",
        "detail": "protobuf.Lib.configparser",
        "documentation": {}
    },
    {
        "label": "InterpolationSyntaxError",
        "kind": 6,
        "importPath": "protobuf.Lib.configparser",
        "description": "protobuf.Lib.configparser",
        "peekOfCode": "class InterpolationSyntaxError(InterpolationError):\n    \"\"\"Raised when the source text contains invalid syntax.\n    Current implementation raises this exception when the source text into\n    which substitutions are made does not conform to the required syntax.\n    \"\"\"\nclass InterpolationDepthError(InterpolationError):\n    \"\"\"Raised when substitutions are nested too deeply.\"\"\"\n    def __init__(self, option, section, rawval):\n        msg = (\"Recursion limit exceeded in value substitution: option {!r} \"\n               \"in section {!r} contains an interpolation key which \"",
        "detail": "protobuf.Lib.configparser",
        "documentation": {}
    },
    {
        "label": "InterpolationDepthError",
        "kind": 6,
        "importPath": "protobuf.Lib.configparser",
        "description": "protobuf.Lib.configparser",
        "peekOfCode": "class InterpolationDepthError(InterpolationError):\n    \"\"\"Raised when substitutions are nested too deeply.\"\"\"\n    def __init__(self, option, section, rawval):\n        msg = (\"Recursion limit exceeded in value substitution: option {!r} \"\n               \"in section {!r} contains an interpolation key which \"\n               \"cannot be substituted in {} steps. Raw value: {!r}\"\n               \"\".format(option, section, MAX_INTERPOLATION_DEPTH,\n                         rawval))\n        InterpolationError.__init__(self, option, section, msg)\n        self.args = (option, section, rawval)",
        "detail": "protobuf.Lib.configparser",
        "documentation": {}
    },
    {
        "label": "ParsingError",
        "kind": 6,
        "importPath": "protobuf.Lib.configparser",
        "description": "protobuf.Lib.configparser",
        "peekOfCode": "class ParsingError(Error):\n    \"\"\"Raised when a configuration file does not follow legal syntax.\"\"\"\n    def __init__(self, source=None, filename=None):\n        # Exactly one of `source'/`filename' arguments has to be given.\n        # `filename' kept for compatibility.\n        if filename and source:\n            raise ValueError(\"Cannot specify both `filename' and `source'. \"\n                             \"Use `source'.\")\n        elif not filename and not source:\n            raise ValueError(\"Required argument `source' not given.\")",
        "detail": "protobuf.Lib.configparser",
        "documentation": {}
    },
    {
        "label": "MissingSectionHeaderError",
        "kind": 6,
        "importPath": "protobuf.Lib.configparser",
        "description": "protobuf.Lib.configparser",
        "peekOfCode": "class MissingSectionHeaderError(ParsingError):\n    \"\"\"Raised when a key-value pair is found before any section header.\"\"\"\n    def __init__(self, filename, lineno, line):\n        Error.__init__(\n            self,\n            'File contains no section headers.\\nfile: %r, line: %d\\n%r' %\n            (filename, lineno, line))\n        self.source = filename\n        self.lineno = lineno\n        self.line = line",
        "detail": "protobuf.Lib.configparser",
        "documentation": {}
    },
    {
        "label": "Interpolation",
        "kind": 6,
        "importPath": "protobuf.Lib.configparser",
        "description": "protobuf.Lib.configparser",
        "peekOfCode": "class Interpolation:\n    \"\"\"Dummy interpolation that passes the value through with no changes.\"\"\"\n    def before_get(self, parser, section, option, value, defaults):\n        return value\n    def before_set(self, parser, section, option, value):\n        return value\n    def before_read(self, parser, section, option, value):\n        return value\n    def before_write(self, parser, section, option, value):\n        return value",
        "detail": "protobuf.Lib.configparser",
        "documentation": {}
    },
    {
        "label": "BasicInterpolation",
        "kind": 6,
        "importPath": "protobuf.Lib.configparser",
        "description": "protobuf.Lib.configparser",
        "peekOfCode": "class BasicInterpolation(Interpolation):\n    \"\"\"Interpolation as implemented in the classic ConfigParser.\n    The option values can contain format strings which refer to other values in\n    the same section, or values in the special default section.\n    For example:\n        something: %(dir)s/whatever\n    would resolve the \"%(dir)s\" to the value of dir.  All reference\n    expansions are done late, on demand. If a user needs to use a bare % in\n    a configuration file, she can escape it by writing %%. Other % usage\n    is considered a user error and raises `InterpolationSyntaxError`.\"\"\"",
        "detail": "protobuf.Lib.configparser",
        "documentation": {}
    },
    {
        "label": "ExtendedInterpolation",
        "kind": 6,
        "importPath": "protobuf.Lib.configparser",
        "description": "protobuf.Lib.configparser",
        "peekOfCode": "class ExtendedInterpolation(Interpolation):\n    \"\"\"Advanced variant of interpolation, supports the syntax used by\n    `zc.buildout`. Enables interpolation between sections.\"\"\"\n    _KEYCRE = re.compile(r\"\\$\\{([^}]+)\\}\")\n    def before_get(self, parser, section, option, value, defaults):\n        L = []\n        self._interpolate_some(parser, option, L, value, section, defaults, 1)\n        return ''.join(L)\n    def before_set(self, parser, section, option, value):\n        tmp_value = value.replace('$$', '') # escaped dollar signs",
        "detail": "protobuf.Lib.configparser",
        "documentation": {}
    },
    {
        "label": "LegacyInterpolation",
        "kind": 6,
        "importPath": "protobuf.Lib.configparser",
        "description": "protobuf.Lib.configparser",
        "peekOfCode": "class LegacyInterpolation(Interpolation):\n    \"\"\"Deprecated interpolation used in old versions of ConfigParser.\n    Use BasicInterpolation or ExtendedInterpolation instead.\"\"\"\n    _KEYCRE = re.compile(r\"%\\(([^)]*)\\)s|.\")\n    def before_get(self, parser, section, option, value, vars):\n        rawval = value\n        depth = MAX_INTERPOLATION_DEPTH\n        while depth:                    # Loop through this until it's done\n            depth -= 1\n            if value and \"%(\" in value:",
        "detail": "protobuf.Lib.configparser",
        "documentation": {}
    },
    {
        "label": "RawConfigParser",
        "kind": 6,
        "importPath": "protobuf.Lib.configparser",
        "description": "protobuf.Lib.configparser",
        "peekOfCode": "class RawConfigParser(MutableMapping):\n    \"\"\"ConfigParser that does not do interpolation.\"\"\"\n    # Regular expressions for parsing section headers and options\n    _SECT_TMPL = r\"\"\"\n        \\[                                 # [\n        (?P<header>.+)                     # very permissive!\n        \\]                                 # ]\n        \"\"\"\n    _OPT_TMPL = r\"\"\"\n        (?P<option>.*?)                    # very permissive!",
        "detail": "protobuf.Lib.configparser",
        "documentation": {}
    },
    {
        "label": "ConfigParser",
        "kind": 6,
        "importPath": "protobuf.Lib.configparser",
        "description": "protobuf.Lib.configparser",
        "peekOfCode": "class ConfigParser(RawConfigParser):\n    \"\"\"ConfigParser implementing interpolation.\"\"\"\n    _DEFAULT_INTERPOLATION = BasicInterpolation()\n    def set(self, section, option, value=None):\n        \"\"\"Set an option.  Extends RawConfigParser.set by validating type and\n        interpolation syntax on the value.\"\"\"\n        self._validate_value_types(option=option, value=value)\n        super().set(section, option, value)\n    def add_section(self, section):\n        \"\"\"Create a new section in the configuration.  Extends",
        "detail": "protobuf.Lib.configparser",
        "documentation": {}
    },
    {
        "label": "SafeConfigParser",
        "kind": 6,
        "importPath": "protobuf.Lib.configparser",
        "description": "protobuf.Lib.configparser",
        "peekOfCode": "class SafeConfigParser(ConfigParser):\n    \"\"\"ConfigParser alias for backwards compatibility purposes.\"\"\"\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        warnings.warn(\n            \"The SafeConfigParser class has been renamed to ConfigParser \"\n            \"in Python 3.2. This alias will be removed in Python 3.12.\"\n            \" Use ConfigParser directly instead.\",\n            DeprecationWarning, stacklevel=2\n        )",
        "detail": "protobuf.Lib.configparser",
        "documentation": {}
    },
    {
        "label": "SectionProxy",
        "kind": 6,
        "importPath": "protobuf.Lib.configparser",
        "description": "protobuf.Lib.configparser",
        "peekOfCode": "class SectionProxy(MutableMapping):\n    \"\"\"A proxy for a single section from a parser.\"\"\"\n    def __init__(self, parser, name):\n        \"\"\"Creates a view on a section of the specified `name` in `parser`.\"\"\"\n        self._parser = parser\n        self._name = name\n        for conv in parser.converters:\n            key = 'get' + conv\n            getter = functools.partial(self.get, _impl=getattr(parser, key))\n            setattr(self, key, getter)",
        "detail": "protobuf.Lib.configparser",
        "documentation": {}
    },
    {
        "label": "ConverterMapping",
        "kind": 6,
        "importPath": "protobuf.Lib.configparser",
        "description": "protobuf.Lib.configparser",
        "peekOfCode": "class ConverterMapping(MutableMapping):\n    \"\"\"Enables reuse of get*() methods between the parser and section proxies.\n    If a parser class implements a getter directly, the value for the given\n    key will be ``None``. The presence of the converter name here enables\n    section proxies to find and use the implementation on the parser class.\n    \"\"\"\n    GETTERCRE = re.compile(r\"^get(?P<name>.+)$\")\n    def __init__(self, parser):\n        self._parser = parser\n        self._data = {}",
        "detail": "protobuf.Lib.configparser",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.configparser",
        "description": "protobuf.Lib.configparser",
        "peekOfCode": "__all__ = [\"NoSectionError\", \"DuplicateOptionError\", \"DuplicateSectionError\",\n           \"NoOptionError\", \"InterpolationError\", \"InterpolationDepthError\",\n           \"InterpolationMissingOptionError\", \"InterpolationSyntaxError\",\n           \"ParsingError\", \"MissingSectionHeaderError\",\n           \"ConfigParser\", \"SafeConfigParser\", \"RawConfigParser\",\n           \"Interpolation\", \"BasicInterpolation\",  \"ExtendedInterpolation\",\n           \"LegacyInterpolation\", \"SectionProxy\", \"ConverterMapping\",\n           \"DEFAULTSECT\", \"MAX_INTERPOLATION_DEPTH\"]\n_default_dict = dict\nDEFAULTSECT = \"DEFAULT\"",
        "detail": "protobuf.Lib.configparser",
        "documentation": {}
    },
    {
        "label": "_default_dict",
        "kind": 5,
        "importPath": "protobuf.Lib.configparser",
        "description": "protobuf.Lib.configparser",
        "peekOfCode": "_default_dict = dict\nDEFAULTSECT = \"DEFAULT\"\nMAX_INTERPOLATION_DEPTH = 10\n# exception classes\nclass Error(Exception):\n    \"\"\"Base class for ConfigParser exceptions.\"\"\"\n    def __init__(self, msg=''):\n        self.message = msg\n        Exception.__init__(self, msg)\n    def __repr__(self):",
        "detail": "protobuf.Lib.configparser",
        "documentation": {}
    },
    {
        "label": "DEFAULTSECT",
        "kind": 5,
        "importPath": "protobuf.Lib.configparser",
        "description": "protobuf.Lib.configparser",
        "peekOfCode": "DEFAULTSECT = \"DEFAULT\"\nMAX_INTERPOLATION_DEPTH = 10\n# exception classes\nclass Error(Exception):\n    \"\"\"Base class for ConfigParser exceptions.\"\"\"\n    def __init__(self, msg=''):\n        self.message = msg\n        Exception.__init__(self, msg)\n    def __repr__(self):\n        return self.message",
        "detail": "protobuf.Lib.configparser",
        "documentation": {}
    },
    {
        "label": "MAX_INTERPOLATION_DEPTH",
        "kind": 5,
        "importPath": "protobuf.Lib.configparser",
        "description": "protobuf.Lib.configparser",
        "peekOfCode": "MAX_INTERPOLATION_DEPTH = 10\n# exception classes\nclass Error(Exception):\n    \"\"\"Base class for ConfigParser exceptions.\"\"\"\n    def __init__(self, msg=''):\n        self.message = msg\n        Exception.__init__(self, msg)\n    def __repr__(self):\n        return self.message\n    __str__ = __repr__",
        "detail": "protobuf.Lib.configparser",
        "documentation": {}
    },
    {
        "label": "_UNSET",
        "kind": 5,
        "importPath": "protobuf.Lib.configparser",
        "description": "protobuf.Lib.configparser",
        "peekOfCode": "_UNSET = object()\nclass Interpolation:\n    \"\"\"Dummy interpolation that passes the value through with no changes.\"\"\"\n    def before_get(self, parser, section, option, value, defaults):\n        return value\n    def before_set(self, parser, section, option, value):\n        return value\n    def before_read(self, parser, section, option, value):\n        return value\n    def before_write(self, parser, section, option, value):",
        "detail": "protobuf.Lib.configparser",
        "documentation": {}
    },
    {
        "label": "AbstractContextManager",
        "kind": 6,
        "importPath": "protobuf.Lib.contextlib",
        "description": "protobuf.Lib.contextlib",
        "peekOfCode": "class AbstractContextManager(abc.ABC):\n    \"\"\"An abstract base class for context managers.\"\"\"\n    __class_getitem__ = classmethod(GenericAlias)\n    def __enter__(self):\n        \"\"\"Return `self` upon entering the runtime context.\"\"\"\n        return self\n    @abc.abstractmethod\n    def __exit__(self, exc_type, exc_value, traceback):\n        \"\"\"Raise any exception triggered within the runtime context.\"\"\"\n        return None",
        "detail": "protobuf.Lib.contextlib",
        "documentation": {}
    },
    {
        "label": "AbstractAsyncContextManager",
        "kind": 6,
        "importPath": "protobuf.Lib.contextlib",
        "description": "protobuf.Lib.contextlib",
        "peekOfCode": "class AbstractAsyncContextManager(abc.ABC):\n    \"\"\"An abstract base class for asynchronous context managers.\"\"\"\n    __class_getitem__ = classmethod(GenericAlias)\n    async def __aenter__(self):\n        \"\"\"Return `self` upon entering the runtime context.\"\"\"\n        return self\n    @abc.abstractmethod\n    async def __aexit__(self, exc_type, exc_value, traceback):\n        \"\"\"Raise any exception triggered within the runtime context.\"\"\"\n        return None",
        "detail": "protobuf.Lib.contextlib",
        "documentation": {}
    },
    {
        "label": "ContextDecorator",
        "kind": 6,
        "importPath": "protobuf.Lib.contextlib",
        "description": "protobuf.Lib.contextlib",
        "peekOfCode": "class ContextDecorator(object):\n    \"A base class or mixin that enables context managers to work as decorators.\"\n    def _recreate_cm(self):\n        \"\"\"Return a recreated instance of self.\n        Allows an otherwise one-shot context manager like\n        _GeneratorContextManager to support use as\n        a decorator via implicit recreation.\n        This is a private interface just for _GeneratorContextManager.\n        See issue #11647 for details.\n        \"\"\"",
        "detail": "protobuf.Lib.contextlib",
        "documentation": {}
    },
    {
        "label": "AsyncContextDecorator",
        "kind": 6,
        "importPath": "protobuf.Lib.contextlib",
        "description": "protobuf.Lib.contextlib",
        "peekOfCode": "class AsyncContextDecorator(object):\n    \"A base class or mixin that enables async context managers to work as decorators.\"\n    def _recreate_cm(self):\n        \"\"\"Return a recreated instance of self.\n        \"\"\"\n        return self\n    def __call__(self, func):\n        @wraps(func)\n        async def inner(*args, **kwds):\n            async with self._recreate_cm():",
        "detail": "protobuf.Lib.contextlib",
        "documentation": {}
    },
    {
        "label": "_GeneratorContextManagerBase",
        "kind": 6,
        "importPath": "protobuf.Lib.contextlib",
        "description": "protobuf.Lib.contextlib",
        "peekOfCode": "class _GeneratorContextManagerBase:\n    \"\"\"Shared functionality for @contextmanager and @asynccontextmanager.\"\"\"\n    def __init__(self, func, args, kwds):\n        self.gen = func(*args, **kwds)\n        self.func, self.args, self.kwds = func, args, kwds\n        # Issue 19330: ensure context manager instances have good docstrings\n        doc = getattr(func, \"__doc__\", None)\n        if doc is None:\n            doc = type(self).__doc__\n        self.__doc__ = doc",
        "detail": "protobuf.Lib.contextlib",
        "documentation": {}
    },
    {
        "label": "_GeneratorContextManager",
        "kind": 6,
        "importPath": "protobuf.Lib.contextlib",
        "description": "protobuf.Lib.contextlib",
        "peekOfCode": "class _GeneratorContextManager(\n    _GeneratorContextManagerBase,\n    AbstractContextManager,\n    ContextDecorator,\n):\n    \"\"\"Helper for @contextmanager decorator.\"\"\"\n    def __enter__(self):\n        # do not keep args and kwds alive unnecessarily\n        # they are only needed for recreation, which is not possible anymore\n        del self.args, self.kwds, self.func",
        "detail": "protobuf.Lib.contextlib",
        "documentation": {}
    },
    {
        "label": "_AsyncGeneratorContextManager",
        "kind": 6,
        "importPath": "protobuf.Lib.contextlib",
        "description": "protobuf.Lib.contextlib",
        "peekOfCode": "class _AsyncGeneratorContextManager(\n    _GeneratorContextManagerBase,\n    AbstractAsyncContextManager,\n    AsyncContextDecorator,\n):\n    \"\"\"Helper for @asynccontextmanager decorator.\"\"\"\n    async def __aenter__(self):\n        # do not keep args and kwds alive unnecessarily\n        # they are only needed for recreation, which is not possible anymore\n        del self.args, self.kwds, self.func",
        "detail": "protobuf.Lib.contextlib",
        "documentation": {}
    },
    {
        "label": "closing",
        "kind": 6,
        "importPath": "protobuf.Lib.contextlib",
        "description": "protobuf.Lib.contextlib",
        "peekOfCode": "class closing(AbstractContextManager):\n    \"\"\"Context to automatically close something at the end of a block.\n    Code like this:\n        with closing(<module>.open(<arguments>)) as f:\n            <block>\n    is equivalent to this:\n        f = <module>.open(<arguments>)\n        try:\n            <block>\n        finally:",
        "detail": "protobuf.Lib.contextlib",
        "documentation": {}
    },
    {
        "label": "aclosing",
        "kind": 6,
        "importPath": "protobuf.Lib.contextlib",
        "description": "protobuf.Lib.contextlib",
        "peekOfCode": "class aclosing(AbstractAsyncContextManager):\n    \"\"\"Async context manager for safely finalizing an asynchronously cleaned-up\n    resource such as an async generator, calling its ``aclose()`` method.\n    Code like this:\n        async with aclosing(<module>.fetch(<arguments>)) as agen:\n            <block>\n    is equivalent to this:\n        agen = <module>.fetch(<arguments>)\n        try:\n            <block>",
        "detail": "protobuf.Lib.contextlib",
        "documentation": {}
    },
    {
        "label": "_RedirectStream",
        "kind": 6,
        "importPath": "protobuf.Lib.contextlib",
        "description": "protobuf.Lib.contextlib",
        "peekOfCode": "class _RedirectStream(AbstractContextManager):\n    _stream = None\n    def __init__(self, new_target):\n        self._new_target = new_target\n        # We use a list of old targets to make this CM re-entrant\n        self._old_targets = []\n    def __enter__(self):\n        self._old_targets.append(getattr(sys, self._stream))\n        setattr(sys, self._stream, self._new_target)\n        return self._new_target",
        "detail": "protobuf.Lib.contextlib",
        "documentation": {}
    },
    {
        "label": "redirect_stdout",
        "kind": 6,
        "importPath": "protobuf.Lib.contextlib",
        "description": "protobuf.Lib.contextlib",
        "peekOfCode": "class redirect_stdout(_RedirectStream):\n    \"\"\"Context manager for temporarily redirecting stdout to another file.\n        # How to send help() to stderr\n        with redirect_stdout(sys.stderr):\n            help(dir)\n        # How to write help() to a file\n        with open('help.txt', 'w') as f:\n            with redirect_stdout(f):\n                help(pow)\n    \"\"\"",
        "detail": "protobuf.Lib.contextlib",
        "documentation": {}
    },
    {
        "label": "redirect_stderr",
        "kind": 6,
        "importPath": "protobuf.Lib.contextlib",
        "description": "protobuf.Lib.contextlib",
        "peekOfCode": "class redirect_stderr(_RedirectStream):\n    \"\"\"Context manager for temporarily redirecting stderr to another file.\"\"\"\n    _stream = \"stderr\"\nclass suppress(AbstractContextManager):\n    \"\"\"Context manager to suppress specified exceptions\n    After the exception is suppressed, execution proceeds with the next\n    statement following the with statement.\n         with suppress(FileNotFoundError):\n             os.remove(somefile)\n         # Execution still resumes here if the file was already removed",
        "detail": "protobuf.Lib.contextlib",
        "documentation": {}
    },
    {
        "label": "suppress",
        "kind": 6,
        "importPath": "protobuf.Lib.contextlib",
        "description": "protobuf.Lib.contextlib",
        "peekOfCode": "class suppress(AbstractContextManager):\n    \"\"\"Context manager to suppress specified exceptions\n    After the exception is suppressed, execution proceeds with the next\n    statement following the with statement.\n         with suppress(FileNotFoundError):\n             os.remove(somefile)\n         # Execution still resumes here if the file was already removed\n    \"\"\"\n    def __init__(self, *exceptions):\n        self._exceptions = exceptions",
        "detail": "protobuf.Lib.contextlib",
        "documentation": {}
    },
    {
        "label": "_BaseExitStack",
        "kind": 6,
        "importPath": "protobuf.Lib.contextlib",
        "description": "protobuf.Lib.contextlib",
        "peekOfCode": "class _BaseExitStack:\n    \"\"\"A base class for ExitStack and AsyncExitStack.\"\"\"\n    @staticmethod\n    def _create_exit_wrapper(cm, cm_exit):\n        return MethodType(cm_exit, cm)\n    @staticmethod\n    def _create_cb_wrapper(callback, /, *args, **kwds):\n        def _exit_wrapper(exc_type, exc, tb):\n            callback(*args, **kwds)\n        return _exit_wrapper",
        "detail": "protobuf.Lib.contextlib",
        "documentation": {}
    },
    {
        "label": "ExitStack",
        "kind": 6,
        "importPath": "protobuf.Lib.contextlib",
        "description": "protobuf.Lib.contextlib",
        "peekOfCode": "class ExitStack(_BaseExitStack, AbstractContextManager):\n    \"\"\"Context manager for dynamic management of a stack of exit callbacks.\n    For example:\n        with ExitStack() as stack:\n            files = [stack.enter_context(open(fname)) for fname in filenames]\n            # All opened files will automatically be closed at the end of\n            # the with statement, even if attempts to open files later\n            # in the list raise an exception.\n    \"\"\"\n    def __enter__(self):",
        "detail": "protobuf.Lib.contextlib",
        "documentation": {}
    },
    {
        "label": "AsyncExitStack",
        "kind": 6,
        "importPath": "protobuf.Lib.contextlib",
        "description": "protobuf.Lib.contextlib",
        "peekOfCode": "class AsyncExitStack(_BaseExitStack, AbstractAsyncContextManager):\n    \"\"\"Async context manager for dynamic management of a stack of exit\n    callbacks.\n    For example:\n        async with AsyncExitStack() as stack:\n            connections = [await stack.enter_async_context(get_connection())\n                for i in range(5)]\n            # All opened connections will automatically be released at the\n            # end of the async with statement, even if attempts to open a\n            # connection later in the list raise an exception.",
        "detail": "protobuf.Lib.contextlib",
        "documentation": {}
    },
    {
        "label": "nullcontext",
        "kind": 6,
        "importPath": "protobuf.Lib.contextlib",
        "description": "protobuf.Lib.contextlib",
        "peekOfCode": "class nullcontext(AbstractContextManager, AbstractAsyncContextManager):\n    \"\"\"Context manager that does no additional processing.\n    Used as a stand-in for a normal context manager, when a particular\n    block of code is only sometimes used with a normal context manager:\n    cm = optional_cm if condition else nullcontext()\n    with cm:\n        # Perform operation, using optional_cm if condition is True\n    \"\"\"\n    def __init__(self, enter_result=None):\n        self.enter_result = enter_result",
        "detail": "protobuf.Lib.contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "kind": 2,
        "importPath": "protobuf.Lib.contextlib",
        "description": "protobuf.Lib.contextlib",
        "peekOfCode": "def contextmanager(func):\n    \"\"\"@contextmanager decorator.\n    Typical usage:\n        @contextmanager\n        def some_generator(<arguments>):\n            <setup>\n            try:\n                yield <value>\n            finally:\n                <cleanup>",
        "detail": "protobuf.Lib.contextlib",
        "documentation": {}
    },
    {
        "label": "asynccontextmanager",
        "kind": 2,
        "importPath": "protobuf.Lib.contextlib",
        "description": "protobuf.Lib.contextlib",
        "peekOfCode": "def asynccontextmanager(func):\n    \"\"\"@asynccontextmanager decorator.\n    Typical usage:\n        @asynccontextmanager\n        async def some_async_generator(<arguments>):\n            <setup>\n            try:\n                yield <value>\n            finally:\n                <cleanup>",
        "detail": "protobuf.Lib.contextlib",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.contextlib",
        "description": "protobuf.Lib.contextlib",
        "peekOfCode": "__all__ = [\"asynccontextmanager\", \"contextmanager\", \"closing\", \"nullcontext\",\n           \"AbstractContextManager\", \"AbstractAsyncContextManager\",\n           \"AsyncExitStack\", \"ContextDecorator\", \"ExitStack\",\n           \"redirect_stdout\", \"redirect_stderr\", \"suppress\", \"aclosing\"]\nclass AbstractContextManager(abc.ABC):\n    \"\"\"An abstract base class for context managers.\"\"\"\n    __class_getitem__ = classmethod(GenericAlias)\n    def __enter__(self):\n        \"\"\"Return `self` upon entering the runtime context.\"\"\"\n        return self",
        "detail": "protobuf.Lib.contextlib",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.contextvars",
        "description": "protobuf.Lib.contextvars",
        "peekOfCode": "__all__ = ('Context', 'ContextVar', 'Token', 'copy_context')",
        "detail": "protobuf.Lib.contextvars",
        "documentation": {}
    },
    {
        "label": "instances)",
        "kind": 6,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "class instances).\n- A shallow copy constructs a new compound object and then (to the\n  extent possible) inserts *the same objects* into it that the\n  original contains.\n- A deep copy constructs a new compound object and then, recursively,\n  inserts *copies* into it of the objects found in the original.\nTwo problems often exist with deep copy operations that don't exist\nwith shallow copy operations:\n a) recursive objects (compound objects that, directly or indirectly,\n    contain a reference to themselves) may cause a recursive loop",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "Error",
        "kind": 6,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "class Error(Exception):\n    pass\nerror = Error   # backward compatibility\ntry:\n    from org.python.core import PyStringMap\nexcept ImportError:\n    PyStringMap = None\n__all__ = [\"Error\", \"copy\", \"deepcopy\"]\ndef copy(x):\n    \"\"\"Shallow copy operation on arbitrary Python objects.",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 2,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "def copy(x):\n    \"\"\"Shallow copy operation on arbitrary Python objects.\n    See the module's __doc__ string for more info.\n    \"\"\"\n    cls = type(x)\n    copier = _copy_dispatch.get(cls)\n    if copier:\n        return copier(x)\n    if issubclass(cls, type):\n        # treat it as a regular class:",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "kind": 2,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "def deepcopy(x, memo=None, _nil=[]):\n    \"\"\"Deep copy operation on arbitrary Python objects.\n    See the module's __doc__ string for more info.\n    \"\"\"\n    if memo is None:\n        memo = {}\n    d = id(x)\n    y = memo.get(d, _nil)\n    if y is not _nil:\n        return y",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "error",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "error = Error   # backward compatibility\ntry:\n    from org.python.core import PyStringMap\nexcept ImportError:\n    PyStringMap = None\n__all__ = [\"Error\", \"copy\", \"deepcopy\"]\ndef copy(x):\n    \"\"\"Shallow copy operation on arbitrary Python objects.\n    See the module's __doc__ string for more info.\n    \"\"\"",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "__all__ = [\"Error\", \"copy\", \"deepcopy\"]\ndef copy(x):\n    \"\"\"Shallow copy operation on arbitrary Python objects.\n    See the module's __doc__ string for more info.\n    \"\"\"\n    cls = type(x)\n    copier = _copy_dispatch.get(cls)\n    if copier:\n        return copier(x)\n    if issubclass(cls, type):",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "_copy_dispatch",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "_copy_dispatch = d = {}\ndef _copy_immutable(x):\n    return x\nfor t in (type(None), int, float, bool, complex, str, tuple,\n          bytes, frozenset, type, range, slice, property,\n          types.BuiltinFunctionType, type(Ellipsis), type(NotImplemented),\n          types.FunctionType, weakref.ref):\n    d[t] = _copy_immutable\nt = getattr(types, \"CodeType\", None)\nif t is not None:",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "t = getattr(types, \"CodeType\", None)\nif t is not None:\n    d[t] = _copy_immutable\nd[list] = list.copy\nd[dict] = dict.copy\nd[set] = set.copy\nd[bytearray] = bytearray.copy\nif PyStringMap is not None:\n    d[PyStringMap] = PyStringMap.copy\ndel d, t",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[list]",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "d[list] = list.copy\nd[dict] = dict.copy\nd[set] = set.copy\nd[bytearray] = bytearray.copy\nif PyStringMap is not None:\n    d[PyStringMap] = PyStringMap.copy\ndel d, t\ndef deepcopy(x, memo=None, _nil=[]):\n    \"\"\"Deep copy operation on arbitrary Python objects.\n    See the module's __doc__ string for more info.",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[dict]",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "d[dict] = dict.copy\nd[set] = set.copy\nd[bytearray] = bytearray.copy\nif PyStringMap is not None:\n    d[PyStringMap] = PyStringMap.copy\ndel d, t\ndef deepcopy(x, memo=None, _nil=[]):\n    \"\"\"Deep copy operation on arbitrary Python objects.\n    See the module's __doc__ string for more info.\n    \"\"\"",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[set]",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "d[set] = set.copy\nd[bytearray] = bytearray.copy\nif PyStringMap is not None:\n    d[PyStringMap] = PyStringMap.copy\ndel d, t\ndef deepcopy(x, memo=None, _nil=[]):\n    \"\"\"Deep copy operation on arbitrary Python objects.\n    See the module's __doc__ string for more info.\n    \"\"\"\n    if memo is None:",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[bytearray]",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "d[bytearray] = bytearray.copy\nif PyStringMap is not None:\n    d[PyStringMap] = PyStringMap.copy\ndel d, t\ndef deepcopy(x, memo=None, _nil=[]):\n    \"\"\"Deep copy operation on arbitrary Python objects.\n    See the module's __doc__ string for more info.\n    \"\"\"\n    if memo is None:\n        memo = {}",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "_deepcopy_dispatch",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "_deepcopy_dispatch = d = {}\ndef _deepcopy_atomic(x, memo):\n    return x\nd[type(None)] = _deepcopy_atomic\nd[type(Ellipsis)] = _deepcopy_atomic\nd[type(NotImplemented)] = _deepcopy_atomic\nd[int] = _deepcopy_atomic\nd[float] = _deepcopy_atomic\nd[bool] = _deepcopy_atomic\nd[complex] = _deepcopy_atomic",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[type(None)]",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "d[type(None)] = _deepcopy_atomic\nd[type(Ellipsis)] = _deepcopy_atomic\nd[type(NotImplemented)] = _deepcopy_atomic\nd[int] = _deepcopy_atomic\nd[float] = _deepcopy_atomic\nd[bool] = _deepcopy_atomic\nd[complex] = _deepcopy_atomic\nd[bytes] = _deepcopy_atomic\nd[str] = _deepcopy_atomic\nd[types.CodeType] = _deepcopy_atomic",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[type(Ellipsis)]",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "d[type(Ellipsis)] = _deepcopy_atomic\nd[type(NotImplemented)] = _deepcopy_atomic\nd[int] = _deepcopy_atomic\nd[float] = _deepcopy_atomic\nd[bool] = _deepcopy_atomic\nd[complex] = _deepcopy_atomic\nd[bytes] = _deepcopy_atomic\nd[str] = _deepcopy_atomic\nd[types.CodeType] = _deepcopy_atomic\nd[type] = _deepcopy_atomic",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[type(NotImplemented)]",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "d[type(NotImplemented)] = _deepcopy_atomic\nd[int] = _deepcopy_atomic\nd[float] = _deepcopy_atomic\nd[bool] = _deepcopy_atomic\nd[complex] = _deepcopy_atomic\nd[bytes] = _deepcopy_atomic\nd[str] = _deepcopy_atomic\nd[types.CodeType] = _deepcopy_atomic\nd[type] = _deepcopy_atomic\nd[range] = _deepcopy_atomic",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[int]",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "d[int] = _deepcopy_atomic\nd[float] = _deepcopy_atomic\nd[bool] = _deepcopy_atomic\nd[complex] = _deepcopy_atomic\nd[bytes] = _deepcopy_atomic\nd[str] = _deepcopy_atomic\nd[types.CodeType] = _deepcopy_atomic\nd[type] = _deepcopy_atomic\nd[range] = _deepcopy_atomic\nd[types.BuiltinFunctionType] = _deepcopy_atomic",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[float]",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "d[float] = _deepcopy_atomic\nd[bool] = _deepcopy_atomic\nd[complex] = _deepcopy_atomic\nd[bytes] = _deepcopy_atomic\nd[str] = _deepcopy_atomic\nd[types.CodeType] = _deepcopy_atomic\nd[type] = _deepcopy_atomic\nd[range] = _deepcopy_atomic\nd[types.BuiltinFunctionType] = _deepcopy_atomic\nd[types.FunctionType] = _deepcopy_atomic",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[bool]",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "d[bool] = _deepcopy_atomic\nd[complex] = _deepcopy_atomic\nd[bytes] = _deepcopy_atomic\nd[str] = _deepcopy_atomic\nd[types.CodeType] = _deepcopy_atomic\nd[type] = _deepcopy_atomic\nd[range] = _deepcopy_atomic\nd[types.BuiltinFunctionType] = _deepcopy_atomic\nd[types.FunctionType] = _deepcopy_atomic\nd[weakref.ref] = _deepcopy_atomic",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[complex]",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "d[complex] = _deepcopy_atomic\nd[bytes] = _deepcopy_atomic\nd[str] = _deepcopy_atomic\nd[types.CodeType] = _deepcopy_atomic\nd[type] = _deepcopy_atomic\nd[range] = _deepcopy_atomic\nd[types.BuiltinFunctionType] = _deepcopy_atomic\nd[types.FunctionType] = _deepcopy_atomic\nd[weakref.ref] = _deepcopy_atomic\nd[property] = _deepcopy_atomic",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[bytes]",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "d[bytes] = _deepcopy_atomic\nd[str] = _deepcopy_atomic\nd[types.CodeType] = _deepcopy_atomic\nd[type] = _deepcopy_atomic\nd[range] = _deepcopy_atomic\nd[types.BuiltinFunctionType] = _deepcopy_atomic\nd[types.FunctionType] = _deepcopy_atomic\nd[weakref.ref] = _deepcopy_atomic\nd[property] = _deepcopy_atomic\ndef _deepcopy_list(x, memo, deepcopy=deepcopy):",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[str]",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "d[str] = _deepcopy_atomic\nd[types.CodeType] = _deepcopy_atomic\nd[type] = _deepcopy_atomic\nd[range] = _deepcopy_atomic\nd[types.BuiltinFunctionType] = _deepcopy_atomic\nd[types.FunctionType] = _deepcopy_atomic\nd[weakref.ref] = _deepcopy_atomic\nd[property] = _deepcopy_atomic\ndef _deepcopy_list(x, memo, deepcopy=deepcopy):\n    y = []",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[types.CodeType]",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "d[types.CodeType] = _deepcopy_atomic\nd[type] = _deepcopy_atomic\nd[range] = _deepcopy_atomic\nd[types.BuiltinFunctionType] = _deepcopy_atomic\nd[types.FunctionType] = _deepcopy_atomic\nd[weakref.ref] = _deepcopy_atomic\nd[property] = _deepcopy_atomic\ndef _deepcopy_list(x, memo, deepcopy=deepcopy):\n    y = []\n    memo[id(x)] = y",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[type]",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "d[type] = _deepcopy_atomic\nd[range] = _deepcopy_atomic\nd[types.BuiltinFunctionType] = _deepcopy_atomic\nd[types.FunctionType] = _deepcopy_atomic\nd[weakref.ref] = _deepcopy_atomic\nd[property] = _deepcopy_atomic\ndef _deepcopy_list(x, memo, deepcopy=deepcopy):\n    y = []\n    memo[id(x)] = y\n    append = y.append",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[range]",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "d[range] = _deepcopy_atomic\nd[types.BuiltinFunctionType] = _deepcopy_atomic\nd[types.FunctionType] = _deepcopy_atomic\nd[weakref.ref] = _deepcopy_atomic\nd[property] = _deepcopy_atomic\ndef _deepcopy_list(x, memo, deepcopy=deepcopy):\n    y = []\n    memo[id(x)] = y\n    append = y.append\n    for a in x:",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[types.BuiltinFunctionType]",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "d[types.BuiltinFunctionType] = _deepcopy_atomic\nd[types.FunctionType] = _deepcopy_atomic\nd[weakref.ref] = _deepcopy_atomic\nd[property] = _deepcopy_atomic\ndef _deepcopy_list(x, memo, deepcopy=deepcopy):\n    y = []\n    memo[id(x)] = y\n    append = y.append\n    for a in x:\n        append(deepcopy(a, memo))",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[types.FunctionType]",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "d[types.FunctionType] = _deepcopy_atomic\nd[weakref.ref] = _deepcopy_atomic\nd[property] = _deepcopy_atomic\ndef _deepcopy_list(x, memo, deepcopy=deepcopy):\n    y = []\n    memo[id(x)] = y\n    append = y.append\n    for a in x:\n        append(deepcopy(a, memo))\n    return y",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[weakref.ref]",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "d[weakref.ref] = _deepcopy_atomic\nd[property] = _deepcopy_atomic\ndef _deepcopy_list(x, memo, deepcopy=deepcopy):\n    y = []\n    memo[id(x)] = y\n    append = y.append\n    for a in x:\n        append(deepcopy(a, memo))\n    return y\nd[list] = _deepcopy_list",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[property]",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "d[property] = _deepcopy_atomic\ndef _deepcopy_list(x, memo, deepcopy=deepcopy):\n    y = []\n    memo[id(x)] = y\n    append = y.append\n    for a in x:\n        append(deepcopy(a, memo))\n    return y\nd[list] = _deepcopy_list\ndef _deepcopy_tuple(x, memo, deepcopy=deepcopy):",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[list]",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "d[list] = _deepcopy_list\ndef _deepcopy_tuple(x, memo, deepcopy=deepcopy):\n    y = [deepcopy(a, memo) for a in x]\n    # We're not going to put the tuple in the memo, but it's still important we\n    # check for it, in case the tuple contains recursive mutable structures.\n    try:\n        return memo[id(x)]\n    except KeyError:\n        pass\n    for k, j in zip(x, y):",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[tuple]",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "d[tuple] = _deepcopy_tuple\ndef _deepcopy_dict(x, memo, deepcopy=deepcopy):\n    y = {}\n    memo[id(x)] = y\n    for key, value in x.items():\n        y[deepcopy(key, memo)] = deepcopy(value, memo)\n    return y\nd[dict] = _deepcopy_dict\nif PyStringMap is not None:\n    d[PyStringMap] = _deepcopy_dict",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[dict]",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "d[dict] = _deepcopy_dict\nif PyStringMap is not None:\n    d[PyStringMap] = _deepcopy_dict\ndef _deepcopy_method(x, memo): # Copy instance methods\n    return type(x)(x.__func__, deepcopy(x.__self__, memo))\nd[types.MethodType] = _deepcopy_method\ndel d\ndef _keep_alive(x, memo):\n    \"\"\"Keeps a reference to the object x in the memo.\n    Because we remember objects by their id, we have",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[types.MethodType]",
        "kind": 5,
        "importPath": "protobuf.Lib.copy",
        "description": "protobuf.Lib.copy",
        "peekOfCode": "d[types.MethodType] = _deepcopy_method\ndel d\ndef _keep_alive(x, memo):\n    \"\"\"Keeps a reference to the object x in the memo.\n    Because we remember objects by their id, we have\n    to assure that possibly temporary objects are kept\n    alive by referencing them.\n    We store a reference at the id of the memo, which should\n    normally not be used unless someone tries to deepcopy\n    the memo itself...",
        "detail": "protobuf.Lib.copy",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 2,
        "importPath": "protobuf.Lib.copyreg",
        "description": "protobuf.Lib.copyreg",
        "peekOfCode": "def pickle(ob_type, pickle_function, constructor_ob=None):\n    if not callable(pickle_function):\n        raise TypeError(\"reduction functions must be callable\")\n    dispatch_table[ob_type] = pickle_function\n    # The constructor_ob function is a vestige of safe for unpickling.\n    # There is no reason for the caller to pass it anymore.\n    if constructor_ob is not None:\n        constructor(constructor_ob)\ndef constructor(object):\n    if not callable(object):",
        "detail": "protobuf.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "constructor",
        "kind": 2,
        "importPath": "protobuf.Lib.copyreg",
        "description": "protobuf.Lib.copyreg",
        "peekOfCode": "def constructor(object):\n    if not callable(object):\n        raise TypeError(\"constructors must be callable\")\n# Example: provide pickling support for complex numbers.\ntry:\n    complex\nexcept NameError:\n    pass\nelse:\n    def pickle_complex(c):",
        "detail": "protobuf.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "pickle_union",
        "kind": 2,
        "importPath": "protobuf.Lib.copyreg",
        "description": "protobuf.Lib.copyreg",
        "peekOfCode": "def pickle_union(obj):\n    import functools, operator\n    return functools.reduce, (operator.or_, obj.__args__)\npickle(type(int | str), pickle_union)\n# Support for pickling new-style objects\ndef _reconstructor(cls, base, state):\n    if base is object:\n        obj = object.__new__(cls)\n    else:\n        obj = base.__new__(cls, state)",
        "detail": "protobuf.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "add_extension",
        "kind": 2,
        "importPath": "protobuf.Lib.copyreg",
        "description": "protobuf.Lib.copyreg",
        "peekOfCode": "def add_extension(module, name, code):\n    \"\"\"Register an extension code.\"\"\"\n    code = int(code)\n    if not 1 <= code <= 0x7fffffff:\n        raise ValueError(\"code out of range\")\n    key = (module, name)\n    if (_extension_registry.get(key) == code and\n        _inverted_registry.get(code) == key):\n        return # Redundant registrations are benign\n    if key in _extension_registry:",
        "detail": "protobuf.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "remove_extension",
        "kind": 2,
        "importPath": "protobuf.Lib.copyreg",
        "description": "protobuf.Lib.copyreg",
        "peekOfCode": "def remove_extension(module, name, code):\n    \"\"\"Unregister an extension code.  For testing only.\"\"\"\n    key = (module, name)\n    if (_extension_registry.get(key) != code or\n        _inverted_registry.get(code) != key):\n        raise ValueError(\"key %s is not registered with code %s\" %\n                         (key, code))\n    del _extension_registry[key]\n    del _inverted_registry[code]\n    if code in _extension_cache:",
        "detail": "protobuf.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "clear_extension_cache",
        "kind": 2,
        "importPath": "protobuf.Lib.copyreg",
        "description": "protobuf.Lib.copyreg",
        "peekOfCode": "def clear_extension_cache():\n    _extension_cache.clear()\n# Standard extension code assignments\n# Reserved ranges\n# First  Last Count  Purpose\n#     1   127   127  Reserved for Python standard library\n#   128   191    64  Reserved for Zope\n#   192   239    48  Reserved for 3rd parties\n#   240   255    16  Reserved for private use (will never be assigned)\n#   256   Inf   Inf  Reserved for future assignment",
        "detail": "protobuf.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.copyreg",
        "description": "protobuf.Lib.copyreg",
        "peekOfCode": "__all__ = [\"pickle\", \"constructor\",\n           \"add_extension\", \"remove_extension\", \"clear_extension_cache\"]\ndispatch_table = {}\ndef pickle(ob_type, pickle_function, constructor_ob=None):\n    if not callable(pickle_function):\n        raise TypeError(\"reduction functions must be callable\")\n    dispatch_table[ob_type] = pickle_function\n    # The constructor_ob function is a vestige of safe for unpickling.\n    # There is no reason for the caller to pass it anymore.\n    if constructor_ob is not None:",
        "detail": "protobuf.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "dispatch_table",
        "kind": 5,
        "importPath": "protobuf.Lib.copyreg",
        "description": "protobuf.Lib.copyreg",
        "peekOfCode": "dispatch_table = {}\ndef pickle(ob_type, pickle_function, constructor_ob=None):\n    if not callable(pickle_function):\n        raise TypeError(\"reduction functions must be callable\")\n    dispatch_table[ob_type] = pickle_function\n    # The constructor_ob function is a vestige of safe for unpickling.\n    # There is no reason for the caller to pass it anymore.\n    if constructor_ob is not None:\n        constructor(constructor_ob)\ndef constructor(object):",
        "detail": "protobuf.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "_HEAPTYPE",
        "kind": 5,
        "importPath": "protobuf.Lib.copyreg",
        "description": "protobuf.Lib.copyreg",
        "peekOfCode": "_HEAPTYPE = 1<<9\n_new_type = type(int.__new__)\n# Python code for object.__reduce_ex__ for protocols 0 and 1\ndef _reduce_ex(self, proto):\n    assert proto < 2\n    cls = self.__class__\n    for base in cls.__mro__:\n        if hasattr(base, '__flags__') and not base.__flags__ & _HEAPTYPE:\n            break\n        new = base.__new__",
        "detail": "protobuf.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "_new_type",
        "kind": 5,
        "importPath": "protobuf.Lib.copyreg",
        "description": "protobuf.Lib.copyreg",
        "peekOfCode": "_new_type = type(int.__new__)\n# Python code for object.__reduce_ex__ for protocols 0 and 1\ndef _reduce_ex(self, proto):\n    assert proto < 2\n    cls = self.__class__\n    for base in cls.__mro__:\n        if hasattr(base, '__flags__') and not base.__flags__ & _HEAPTYPE:\n            break\n        new = base.__new__\n        if isinstance(new, _new_type) and new.__self__ is base:",
        "detail": "protobuf.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "_extension_registry",
        "kind": 5,
        "importPath": "protobuf.Lib.copyreg",
        "description": "protobuf.Lib.copyreg",
        "peekOfCode": "_extension_registry = {}                # key -> code\n_inverted_registry = {}                 # code -> key\n_extension_cache = {}                   # code -> object\n# Don't ever rebind those names:  pickling grabs a reference to them when\n# it's initialized, and won't see a rebinding.\ndef add_extension(module, name, code):\n    \"\"\"Register an extension code.\"\"\"\n    code = int(code)\n    if not 1 <= code <= 0x7fffffff:\n        raise ValueError(\"code out of range\")",
        "detail": "protobuf.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "_inverted_registry",
        "kind": 5,
        "importPath": "protobuf.Lib.copyreg",
        "description": "protobuf.Lib.copyreg",
        "peekOfCode": "_inverted_registry = {}                 # code -> key\n_extension_cache = {}                   # code -> object\n# Don't ever rebind those names:  pickling grabs a reference to them when\n# it's initialized, and won't see a rebinding.\ndef add_extension(module, name, code):\n    \"\"\"Register an extension code.\"\"\"\n    code = int(code)\n    if not 1 <= code <= 0x7fffffff:\n        raise ValueError(\"code out of range\")\n    key = (module, name)",
        "detail": "protobuf.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "_extension_cache",
        "kind": 5,
        "importPath": "protobuf.Lib.copyreg",
        "description": "protobuf.Lib.copyreg",
        "peekOfCode": "_extension_cache = {}                   # code -> object\n# Don't ever rebind those names:  pickling grabs a reference to them when\n# it's initialized, and won't see a rebinding.\ndef add_extension(module, name, code):\n    \"\"\"Register an extension code.\"\"\"\n    code = int(code)\n    if not 1 <= code <= 0x7fffffff:\n        raise ValueError(\"code out of range\")\n    key = (module, name)\n    if (_extension_registry.get(key) == code and",
        "detail": "protobuf.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "Profile",
        "kind": 6,
        "importPath": "protobuf.Lib.cProfile",
        "description": "protobuf.Lib.cProfile",
        "peekOfCode": "class Profile(_lsprof.Profiler):\n    \"\"\"Profile(timer=None, timeunit=None, subcalls=True, builtins=True)\n    Builds a profiler object using the specified timer function.\n    The default timer is a fast built-in one based on real time.\n    For custom timer functions returning integers, timeunit can\n    be a float specifying a scale (i.e. how long each integer unit\n    is, in seconds).\n    \"\"\"\n    # Most of the functionality is in the base class.\n    # This subclass only adds convenient and backward-compatible methods.",
        "detail": "protobuf.Lib.cProfile",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "protobuf.Lib.cProfile",
        "description": "protobuf.Lib.cProfile",
        "peekOfCode": "def run(statement, filename=None, sort=-1):\n    return _pyprofile._Utils(Profile).run(statement, filename, sort)\ndef runctx(statement, globals, locals, filename=None, sort=-1):\n    return _pyprofile._Utils(Profile).runctx(statement, globals, locals,\n                                             filename, sort)\nrun.__doc__ = _pyprofile.run.__doc__\nrunctx.__doc__ = _pyprofile.runctx.__doc__\n# ____________________________________________________________\nclass Profile(_lsprof.Profiler):\n    \"\"\"Profile(timer=None, timeunit=None, subcalls=True, builtins=True)",
        "detail": "protobuf.Lib.cProfile",
        "documentation": {}
    },
    {
        "label": "runctx",
        "kind": 2,
        "importPath": "protobuf.Lib.cProfile",
        "description": "protobuf.Lib.cProfile",
        "peekOfCode": "def runctx(statement, globals, locals, filename=None, sort=-1):\n    return _pyprofile._Utils(Profile).runctx(statement, globals, locals,\n                                             filename, sort)\nrun.__doc__ = _pyprofile.run.__doc__\nrunctx.__doc__ = _pyprofile.runctx.__doc__\n# ____________________________________________________________\nclass Profile(_lsprof.Profiler):\n    \"\"\"Profile(timer=None, timeunit=None, subcalls=True, builtins=True)\n    Builds a profiler object using the specified timer function.\n    The default timer is a fast built-in one based on real time.",
        "detail": "protobuf.Lib.cProfile",
        "documentation": {}
    },
    {
        "label": "label",
        "kind": 2,
        "importPath": "protobuf.Lib.cProfile",
        "description": "protobuf.Lib.cProfile",
        "peekOfCode": "def label(code):\n    if isinstance(code, str):\n        return ('~', 0, code)    # built-in functions ('~' sorts at the end)\n    else:\n        return (code.co_filename, code.co_firstlineno, code.co_name)\n# ____________________________________________________________\ndef main():\n    import os\n    import sys\n    import runpy",
        "detail": "protobuf.Lib.cProfile",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "protobuf.Lib.cProfile",
        "description": "protobuf.Lib.cProfile",
        "peekOfCode": "def main():\n    import os\n    import sys\n    import runpy\n    import pstats\n    from optparse import OptionParser\n    usage = \"cProfile.py [-o output_file_path] [-s sort] [-m module | scriptfile] [arg] ...\"\n    parser = OptionParser(usage=usage)\n    parser.allow_interspersed_args = False\n    parser.add_option('-o', '--outfile', dest=\"outfile\",",
        "detail": "protobuf.Lib.cProfile",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.cProfile",
        "description": "protobuf.Lib.cProfile",
        "peekOfCode": "__all__ = [\"run\", \"runctx\", \"Profile\"]\nimport _lsprof\nimport io\nimport profile as _pyprofile\n# ____________________________________________________________\n# Simple interface\ndef run(statement, filename=None, sort=-1):\n    return _pyprofile._Utils(Profile).run(statement, filename, sort)\ndef runctx(statement, globals, locals, filename=None, sort=-1):\n    return _pyprofile._Utils(Profile).runctx(statement, globals, locals,",
        "detail": "protobuf.Lib.cProfile",
        "documentation": {}
    },
    {
        "label": "run.__doc__",
        "kind": 5,
        "importPath": "protobuf.Lib.cProfile",
        "description": "protobuf.Lib.cProfile",
        "peekOfCode": "run.__doc__ = _pyprofile.run.__doc__\nrunctx.__doc__ = _pyprofile.runctx.__doc__\n# ____________________________________________________________\nclass Profile(_lsprof.Profiler):\n    \"\"\"Profile(timer=None, timeunit=None, subcalls=True, builtins=True)\n    Builds a profiler object using the specified timer function.\n    The default timer is a fast built-in one based on real time.\n    For custom timer functions returning integers, timeunit can\n    be a float specifying a scale (i.e. how long each integer unit\n    is, in seconds).",
        "detail": "protobuf.Lib.cProfile",
        "documentation": {}
    },
    {
        "label": "runctx.__doc__",
        "kind": 5,
        "importPath": "protobuf.Lib.cProfile",
        "description": "protobuf.Lib.cProfile",
        "peekOfCode": "runctx.__doc__ = _pyprofile.runctx.__doc__\n# ____________________________________________________________\nclass Profile(_lsprof.Profiler):\n    \"\"\"Profile(timer=None, timeunit=None, subcalls=True, builtins=True)\n    Builds a profiler object using the specified timer function.\n    The default timer is a fast built-in one based on real time.\n    For custom timer functions returning integers, timeunit can\n    be a float specifying a scale (i.e. how long each integer unit\n    is, in seconds).\n    \"\"\"",
        "detail": "protobuf.Lib.cProfile",
        "documentation": {}
    },
    {
        "label": "_Method",
        "kind": 6,
        "importPath": "protobuf.Lib.crypt",
        "description": "protobuf.Lib.crypt",
        "peekOfCode": "class _Method(_namedtuple('_Method', 'name ident salt_chars total_size')):\n    \"\"\"Class representing a salt method per the Modular Crypt Format or the\n    legacy 2-character crypt method.\"\"\"\n    def __repr__(self):\n        return '<crypt.METHOD_{}>'.format(self.name)\ndef mksalt(method=None, *, rounds=None):\n    \"\"\"Generate a salt for the specified method.\n    If not specified, the strongest available method will be used.\n    \"\"\"\n    if method is None:",
        "detail": "protobuf.Lib.crypt",
        "documentation": {}
    },
    {
        "label": "mksalt",
        "kind": 2,
        "importPath": "protobuf.Lib.crypt",
        "description": "protobuf.Lib.crypt",
        "peekOfCode": "def mksalt(method=None, *, rounds=None):\n    \"\"\"Generate a salt for the specified method.\n    If not specified, the strongest available method will be used.\n    \"\"\"\n    if method is None:\n        method = methods[0]\n    if rounds is not None and not isinstance(rounds, int):\n        raise TypeError(f'{rounds.__class__.__name__} object cannot be '\n                        f'interpreted as an integer')\n    if not method.ident:  # traditional",
        "detail": "protobuf.Lib.crypt",
        "documentation": {}
    },
    {
        "label": "crypt",
        "kind": 2,
        "importPath": "protobuf.Lib.crypt",
        "description": "protobuf.Lib.crypt",
        "peekOfCode": "def crypt(word, salt=None):\n    \"\"\"Return a string representing the one-way hash of a password, with a salt\n    prepended.\n    If ``salt`` is not specified or is ``None``, the strongest\n    available method will be selected and a salt generated.  Otherwise,\n    ``salt`` may be one of the ``crypt.METHOD_*`` values, or a string as\n    returned by ``crypt.mksalt()``.\n    \"\"\"\n    if salt is None or isinstance(salt, _Method):\n        salt = mksalt(salt)",
        "detail": "protobuf.Lib.crypt",
        "documentation": {}
    },
    {
        "label": "_saltchars",
        "kind": 5,
        "importPath": "protobuf.Lib.crypt",
        "description": "protobuf.Lib.crypt",
        "peekOfCode": "_saltchars = _string.ascii_letters + _string.digits + './'\n_sr = _SystemRandom()\nclass _Method(_namedtuple('_Method', 'name ident salt_chars total_size')):\n    \"\"\"Class representing a salt method per the Modular Crypt Format or the\n    legacy 2-character crypt method.\"\"\"\n    def __repr__(self):\n        return '<crypt.METHOD_{}>'.format(self.name)\ndef mksalt(method=None, *, rounds=None):\n    \"\"\"Generate a salt for the specified method.\n    If not specified, the strongest available method will be used.",
        "detail": "protobuf.Lib.crypt",
        "documentation": {}
    },
    {
        "label": "_sr",
        "kind": 5,
        "importPath": "protobuf.Lib.crypt",
        "description": "protobuf.Lib.crypt",
        "peekOfCode": "_sr = _SystemRandom()\nclass _Method(_namedtuple('_Method', 'name ident salt_chars total_size')):\n    \"\"\"Class representing a salt method per the Modular Crypt Format or the\n    legacy 2-character crypt method.\"\"\"\n    def __repr__(self):\n        return '<crypt.METHOD_{}>'.format(self.name)\ndef mksalt(method=None, *, rounds=None):\n    \"\"\"Generate a salt for the specified method.\n    If not specified, the strongest available method will be used.\n    \"\"\"",
        "detail": "protobuf.Lib.crypt",
        "documentation": {}
    },
    {
        "label": "methods",
        "kind": 5,
        "importPath": "protobuf.Lib.crypt",
        "description": "protobuf.Lib.crypt",
        "peekOfCode": "methods = []\ndef _add_method(name, *args, rounds=None):\n    method = _Method(name, *args)\n    globals()['METHOD_' + name] = method\n    salt = mksalt(method, rounds=rounds)\n    result = None\n    try:\n        result = crypt('', salt)\n    except OSError as e:\n        # Not all libc libraries support all encryption methods.",
        "detail": "protobuf.Lib.crypt",
        "documentation": {}
    },
    {
        "label": "Dialect",
        "kind": 6,
        "importPath": "protobuf.Lib.csv",
        "description": "protobuf.Lib.csv",
        "peekOfCode": "class Dialect:\n    \"\"\"Describe a CSV dialect.\n    This must be subclassed (see csv.excel).  Valid attributes are:\n    delimiter, quotechar, escapechar, doublequote, skipinitialspace,\n    lineterminator, quoting.\n    \"\"\"\n    _name = \"\"\n    _valid = False\n    # placeholders\n    delimiter = None",
        "detail": "protobuf.Lib.csv",
        "documentation": {}
    },
    {
        "label": "excel",
        "kind": 6,
        "importPath": "protobuf.Lib.csv",
        "description": "protobuf.Lib.csv",
        "peekOfCode": "class excel(Dialect):\n    \"\"\"Describe the usual properties of Excel-generated CSV files.\"\"\"\n    delimiter = ','\n    quotechar = '\"'\n    doublequote = True\n    skipinitialspace = False\n    lineterminator = '\\r\\n'\n    quoting = QUOTE_MINIMAL\nregister_dialect(\"excel\", excel)\nclass excel_tab(excel):",
        "detail": "protobuf.Lib.csv",
        "documentation": {}
    },
    {
        "label": "excel_tab",
        "kind": 6,
        "importPath": "protobuf.Lib.csv",
        "description": "protobuf.Lib.csv",
        "peekOfCode": "class excel_tab(excel):\n    \"\"\"Describe the usual properties of Excel-generated TAB-delimited files.\"\"\"\n    delimiter = '\\t'\nregister_dialect(\"excel-tab\", excel_tab)\nclass unix_dialect(Dialect):\n    \"\"\"Describe the usual properties of Unix-generated CSV files.\"\"\"\n    delimiter = ','\n    quotechar = '\"'\n    doublequote = True\n    skipinitialspace = False",
        "detail": "protobuf.Lib.csv",
        "documentation": {}
    },
    {
        "label": "unix_dialect",
        "kind": 6,
        "importPath": "protobuf.Lib.csv",
        "description": "protobuf.Lib.csv",
        "peekOfCode": "class unix_dialect(Dialect):\n    \"\"\"Describe the usual properties of Unix-generated CSV files.\"\"\"\n    delimiter = ','\n    quotechar = '\"'\n    doublequote = True\n    skipinitialspace = False\n    lineterminator = '\\n'\n    quoting = QUOTE_ALL\nregister_dialect(\"unix\", unix_dialect)\nclass DictReader:",
        "detail": "protobuf.Lib.csv",
        "documentation": {}
    },
    {
        "label": "DictReader",
        "kind": 6,
        "importPath": "protobuf.Lib.csv",
        "description": "protobuf.Lib.csv",
        "peekOfCode": "class DictReader:\n    def __init__(self, f, fieldnames=None, restkey=None, restval=None,\n                 dialect=\"excel\", *args, **kwds):\n        self._fieldnames = fieldnames   # list of keys for the dict\n        self.restkey = restkey          # key to catch long rows\n        self.restval = restval          # default value for short rows\n        self.reader = reader(f, dialect, *args, **kwds)\n        self.dialect = dialect\n        self.line_num = 0\n    def __iter__(self):",
        "detail": "protobuf.Lib.csv",
        "documentation": {}
    },
    {
        "label": "DictWriter",
        "kind": 6,
        "importPath": "protobuf.Lib.csv",
        "description": "protobuf.Lib.csv",
        "peekOfCode": "class DictWriter:\n    def __init__(self, f, fieldnames, restval=\"\", extrasaction=\"raise\",\n                 dialect=\"excel\", *args, **kwds):\n        self.fieldnames = fieldnames    # list of keys for the dict\n        self.restval = restval          # for writing short dicts\n        if extrasaction.lower() not in (\"raise\", \"ignore\"):\n            raise ValueError(\"extrasaction (%s) must be 'raise' or 'ignore'\"\n                             % extrasaction)\n        self.extrasaction = extrasaction\n        self.writer = writer(f, dialect, *args, **kwds)",
        "detail": "protobuf.Lib.csv",
        "documentation": {}
    },
    {
        "label": "Sniffer",
        "kind": 6,
        "importPath": "protobuf.Lib.csv",
        "description": "protobuf.Lib.csv",
        "peekOfCode": "class Sniffer:\n    '''\n    \"Sniffs\" the format of a CSV file (i.e. delimiter, quotechar)\n    Returns a Dialect object.\n    '''\n    def __init__(self):\n        # in case there is more than one possible delimiter\n        self.preferred = [',', '\\t', ';', ' ', ':']\n    def sniff(self, sample, delimiters=None):\n        \"\"\"",
        "detail": "protobuf.Lib.csv",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.csv",
        "description": "protobuf.Lib.csv",
        "peekOfCode": "__all__ = [\"QUOTE_MINIMAL\", \"QUOTE_ALL\", \"QUOTE_NONNUMERIC\", \"QUOTE_NONE\",\n           \"Error\", \"Dialect\", \"__doc__\", \"excel\", \"excel_tab\",\n           \"field_size_limit\", \"reader\", \"writer\",\n           \"register_dialect\", \"get_dialect\", \"list_dialects\", \"Sniffer\",\n           \"unregister_dialect\", \"__version__\", \"DictReader\", \"DictWriter\",\n           \"unix_dialect\"]\nclass Dialect:\n    \"\"\"Describe a CSV dialect.\n    This must be subclassed (see csv.excel).  Valid attributes are:\n    delimiter, quotechar, escapechar, doublequote, skipinitialspace,",
        "detail": "protobuf.Lib.csv",
        "documentation": {}
    },
    {
        "label": "FrozenInstanceError",
        "kind": 6,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "class FrozenInstanceError(AttributeError): pass\n# A sentinel object for default values to signal that a default\n# factory will be used.  This is given a nice repr() which will appear\n# in the function signature of dataclasses' constructors.\nclass _HAS_DEFAULT_FACTORY_CLASS:\n    def __repr__(self):\n        return '<factory>'\n_HAS_DEFAULT_FACTORY = _HAS_DEFAULT_FACTORY_CLASS()\n# A sentinel object to detect if a parameter is supplied or not.  Use\n# a class to give it a better repr.",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "_HAS_DEFAULT_FACTORY_CLASS",
        "kind": 6,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "class _HAS_DEFAULT_FACTORY_CLASS:\n    def __repr__(self):\n        return '<factory>'\n_HAS_DEFAULT_FACTORY = _HAS_DEFAULT_FACTORY_CLASS()\n# A sentinel object to detect if a parameter is supplied or not.  Use\n# a class to give it a better repr.\nclass _MISSING_TYPE:\n    pass\nMISSING = _MISSING_TYPE()\n# A sentinel object to indicate that following fields are keyword-only by",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "_MISSING_TYPE",
        "kind": 6,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "class _MISSING_TYPE:\n    pass\nMISSING = _MISSING_TYPE()\n# A sentinel object to indicate that following fields are keyword-only by\n# default.  Use a class to give it a better repr.\nclass _KW_ONLY_TYPE:\n    pass\nKW_ONLY = _KW_ONLY_TYPE()\n# Since most per-field metadata will be unused, create an empty\n# read-only proxy that can be shared among all fields.",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "_KW_ONLY_TYPE",
        "kind": 6,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "class _KW_ONLY_TYPE:\n    pass\nKW_ONLY = _KW_ONLY_TYPE()\n# Since most per-field metadata will be unused, create an empty\n# read-only proxy that can be shared among all fields.\n_EMPTY_METADATA = types.MappingProxyType({})\n# Markers for the various kinds of fields and pseudo-fields.\nclass _FIELD_BASE:\n    def __init__(self, name):\n        self.name = name",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "_FIELD_BASE",
        "kind": 6,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "class _FIELD_BASE:\n    def __init__(self, name):\n        self.name = name\n    def __repr__(self):\n        return self.name\n_FIELD = _FIELD_BASE('_FIELD')\n_FIELD_CLASSVAR = _FIELD_BASE('_FIELD_CLASSVAR')\n_FIELD_INITVAR = _FIELD_BASE('_FIELD_INITVAR')\n# The name of an attribute on the class where we store the Field\n# objects.  Also used to check if a class is a Data Class.",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "InitVar",
        "kind": 6,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "class InitVar:\n    __slots__ = ('type', )\n    def __init__(self, type):\n        self.type = type\n    def __repr__(self):\n        if isinstance(self.type, type) and not isinstance(self.type, GenericAlias):\n            type_name = self.type.__name__\n        else:\n            # typing objects, e.g. List[int]\n            type_name = repr(self.type)",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "Field",
        "kind": 6,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "class Field:\n    __slots__ = ('name',\n                 'type',\n                 'default',\n                 'default_factory',\n                 'repr',\n                 'hash',\n                 'init',\n                 'compare',\n                 'metadata',",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "_DataclassParams",
        "kind": 6,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "class _DataclassParams:\n    __slots__ = ('init',\n                 'repr',\n                 'eq',\n                 'order',\n                 'unsafe_hash',\n                 'frozen',\n                 )\n    def __init__(self, init, repr, eq, order, unsafe_hash, frozen):\n        self.init = init",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "kind": 2,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "def field(*, default=MISSING, default_factory=MISSING, init=True, repr=True,\n          hash=None, compare=True, metadata=None, kw_only=MISSING):\n    \"\"\"Return an object to identify dataclass fields.\n    default is the default value of the field.  default_factory is a\n    0-argument function called to initialize a field's value.  If init\n    is true, the field will be a parameter to the class's __init__()\n    function.  If repr is true, the field will be included in the\n    object's repr().  If hash is true, the field will be included in the\n    object's hash().  If compare is true, the field will be used in\n    comparison functions.  metadata, if specified, must be a mapping",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "kind": 2,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "def dataclass(cls=None, /, *, init=True, repr=True, eq=True, order=False,\n              unsafe_hash=False, frozen=False, match_args=True,\n              kw_only=False, slots=False):\n    \"\"\"Returns the same class as was passed in, with dunder methods\n    added based on the fields defined in the class.\n    Examines PEP 526 __annotations__ to determine fields.\n    If init is true, an __init__() method is added to the class. If\n    repr is true, a __repr__() method is added. If order is true, rich\n    comparison dunder methods are added. If unsafe_hash is true, a\n    __hash__() method function is added. If frozen is true, fields may",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "fields",
        "kind": 2,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "def fields(class_or_instance):\n    \"\"\"Return a tuple describing the fields of this dataclass.\n    Accepts a dataclass or an instance of one. Tuple elements are of\n    type Field.\n    \"\"\"\n    # Might it be worth caching this, per class?\n    try:\n        fields = getattr(class_or_instance, _FIELDS)\n    except AttributeError:\n        raise TypeError('must be called with a dataclass type or instance') from None",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "kind": 2,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "def is_dataclass(obj):\n    \"\"\"Returns True if obj is a dataclass or an instance of a\n    dataclass.\"\"\"\n    cls = obj if isinstance(obj, type) and not isinstance(obj, GenericAlias) else type(obj)\n    return hasattr(cls, _FIELDS)\ndef asdict(obj, *, dict_factory=dict):\n    \"\"\"Return the fields of a dataclass instance as a new dictionary mapping\n    field names to field values.\n    Example usage:\n      @dataclass",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "asdict",
        "kind": 2,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "def asdict(obj, *, dict_factory=dict):\n    \"\"\"Return the fields of a dataclass instance as a new dictionary mapping\n    field names to field values.\n    Example usage:\n      @dataclass\n      class C:\n          x: int\n          y: int\n      c = C(1, 2)\n      assert asdict(c) == {'x': 1, 'y': 2}",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "astuple",
        "kind": 2,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "def astuple(obj, *, tuple_factory=tuple):\n    \"\"\"Return the fields of a dataclass instance as a new tuple of field values.\n    Example usage::\n      @dataclass\n      class C:\n          x: int\n          y: int\n    c = C(1, 2)\n    assert astuple(c) == (1, 2)\n    If given, 'tuple_factory' will be used instead of built-in tuple.",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "make_dataclass",
        "kind": 2,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "def make_dataclass(cls_name, fields, *, bases=(), namespace=None, init=True,\n                   repr=True, eq=True, order=False, unsafe_hash=False,\n                   frozen=False, match_args=True, kw_only=False, slots=False):\n    \"\"\"Return a new dynamically created dataclass.\n    The dataclass name will be 'cls_name'.  'fields' is an iterable\n    of either (name), (name, type) or (name, type, Field) objects. If type is\n    omitted, use the string 'typing.Any'.  Field objects are created by\n    the equivalent of calling 'field(name, type [, Field-info])'.\n      C = make_dataclass('C', ['x', ('y', int), ('z', int, field(init=False))], bases=(Base,))\n    is equivalent to:",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "replace",
        "kind": 2,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "def replace(obj, /, **changes):\n    \"\"\"Return a new object replacing specified fields with new values.\n    This is especially useful for frozen classes.  Example usage:\n      @dataclass(frozen=True)\n      class C:\n          x: int\n          y: int\n      c = C(1, 2)\n      c1 = replace(c, x=3)\n      assert c1.x == 3 and c1.y == 2",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "__all__ = ['dataclass',\n           'field',\n           'Field',\n           'FrozenInstanceError',\n           'InitVar',\n           'KW_ONLY',\n           'MISSING',\n           # Helper functions.\n           'fields',\n           'asdict',",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "_HAS_DEFAULT_FACTORY",
        "kind": 5,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "_HAS_DEFAULT_FACTORY = _HAS_DEFAULT_FACTORY_CLASS()\n# A sentinel object to detect if a parameter is supplied or not.  Use\n# a class to give it a better repr.\nclass _MISSING_TYPE:\n    pass\nMISSING = _MISSING_TYPE()\n# A sentinel object to indicate that following fields are keyword-only by\n# default.  Use a class to give it a better repr.\nclass _KW_ONLY_TYPE:\n    pass",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "MISSING",
        "kind": 5,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "MISSING = _MISSING_TYPE()\n# A sentinel object to indicate that following fields are keyword-only by\n# default.  Use a class to give it a better repr.\nclass _KW_ONLY_TYPE:\n    pass\nKW_ONLY = _KW_ONLY_TYPE()\n# Since most per-field metadata will be unused, create an empty\n# read-only proxy that can be shared among all fields.\n_EMPTY_METADATA = types.MappingProxyType({})\n# Markers for the various kinds of fields and pseudo-fields.",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "KW_ONLY",
        "kind": 5,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "KW_ONLY = _KW_ONLY_TYPE()\n# Since most per-field metadata will be unused, create an empty\n# read-only proxy that can be shared among all fields.\n_EMPTY_METADATA = types.MappingProxyType({})\n# Markers for the various kinds of fields and pseudo-fields.\nclass _FIELD_BASE:\n    def __init__(self, name):\n        self.name = name\n    def __repr__(self):\n        return self.name",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "_EMPTY_METADATA",
        "kind": 5,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "_EMPTY_METADATA = types.MappingProxyType({})\n# Markers for the various kinds of fields and pseudo-fields.\nclass _FIELD_BASE:\n    def __init__(self, name):\n        self.name = name\n    def __repr__(self):\n        return self.name\n_FIELD = _FIELD_BASE('_FIELD')\n_FIELD_CLASSVAR = _FIELD_BASE('_FIELD_CLASSVAR')\n_FIELD_INITVAR = _FIELD_BASE('_FIELD_INITVAR')",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "_FIELD",
        "kind": 5,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "_FIELD = _FIELD_BASE('_FIELD')\n_FIELD_CLASSVAR = _FIELD_BASE('_FIELD_CLASSVAR')\n_FIELD_INITVAR = _FIELD_BASE('_FIELD_INITVAR')\n# The name of an attribute on the class where we store the Field\n# objects.  Also used to check if a class is a Data Class.\n_FIELDS = '__dataclass_fields__'\n# The name of an attribute on the class that stores the parameters to\n# @dataclass.\n_PARAMS = '__dataclass_params__'\n# The name of the function, that if it exists, is called at the end of",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "_FIELD_CLASSVAR",
        "kind": 5,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "_FIELD_CLASSVAR = _FIELD_BASE('_FIELD_CLASSVAR')\n_FIELD_INITVAR = _FIELD_BASE('_FIELD_INITVAR')\n# The name of an attribute on the class where we store the Field\n# objects.  Also used to check if a class is a Data Class.\n_FIELDS = '__dataclass_fields__'\n# The name of an attribute on the class that stores the parameters to\n# @dataclass.\n_PARAMS = '__dataclass_params__'\n# The name of the function, that if it exists, is called at the end of\n# __init__.",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "_FIELD_INITVAR",
        "kind": 5,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "_FIELD_INITVAR = _FIELD_BASE('_FIELD_INITVAR')\n# The name of an attribute on the class where we store the Field\n# objects.  Also used to check if a class is a Data Class.\n_FIELDS = '__dataclass_fields__'\n# The name of an attribute on the class that stores the parameters to\n# @dataclass.\n_PARAMS = '__dataclass_params__'\n# The name of the function, that if it exists, is called at the end of\n# __init__.\n_POST_INIT_NAME = '__post_init__'",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "_FIELDS",
        "kind": 5,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "_FIELDS = '__dataclass_fields__'\n# The name of an attribute on the class that stores the parameters to\n# @dataclass.\n_PARAMS = '__dataclass_params__'\n# The name of the function, that if it exists, is called at the end of\n# __init__.\n_POST_INIT_NAME = '__post_init__'\n# String regex that string annotations for ClassVar or InitVar must match.\n# Allows \"identifier.identifier[\" or \"identifier[\".\n# https://bugs.python.org/issue33453 for details.",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "_PARAMS",
        "kind": 5,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "_PARAMS = '__dataclass_params__'\n# The name of the function, that if it exists, is called at the end of\n# __init__.\n_POST_INIT_NAME = '__post_init__'\n# String regex that string annotations for ClassVar or InitVar must match.\n# Allows \"identifier.identifier[\" or \"identifier[\".\n# https://bugs.python.org/issue33453 for details.\n_MODULE_IDENTIFIER_RE = re.compile(r'^(?:\\s*(\\w+)\\s*\\.)?\\s*(\\w+)')\n# This function's logic is copied from \"recursive_repr\" function in\n# reprlib module to avoid dependency.",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "_POST_INIT_NAME",
        "kind": 5,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "_POST_INIT_NAME = '__post_init__'\n# String regex that string annotations for ClassVar or InitVar must match.\n# Allows \"identifier.identifier[\" or \"identifier[\".\n# https://bugs.python.org/issue33453 for details.\n_MODULE_IDENTIFIER_RE = re.compile(r'^(?:\\s*(\\w+)\\s*\\.)?\\s*(\\w+)')\n# This function's logic is copied from \"recursive_repr\" function in\n# reprlib module to avoid dependency.\ndef _recursive_repr(user_function):\n    # Decorator to make a repr function return \"...\" for a recursive\n    # call.",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "_MODULE_IDENTIFIER_RE",
        "kind": 5,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "_MODULE_IDENTIFIER_RE = re.compile(r'^(?:\\s*(\\w+)\\s*\\.)?\\s*(\\w+)')\n# This function's logic is copied from \"recursive_repr\" function in\n# reprlib module to avoid dependency.\ndef _recursive_repr(user_function):\n    # Decorator to make a repr function return \"...\" for a recursive\n    # call.\n    repr_running = set()\n    @functools.wraps(user_function)\n    def wrapper(self):\n        key = id(self), _thread.get_ident()",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "_hash_action",
        "kind": 5,
        "importPath": "protobuf.Lib.dataclasses",
        "description": "protobuf.Lib.dataclasses",
        "peekOfCode": "_hash_action = {(False, False, False, False): None,\n                (False, False, False, True ): None,\n                (False, False, True,  False): None,\n                (False, False, True,  True ): None,\n                (False, True,  False, False): _hash_set_none,\n                (False, True,  False, True ): None,\n                (False, True,  True,  False): _hash_add,\n                (False, True,  True,  True ): None,\n                (True,  False, False, False): _hash_add,\n                (True,  False, False, True ): _hash_exception,",
        "detail": "protobuf.Lib.dataclasses",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "kind": 6,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "class timedelta:\n    \"\"\"Represent the difference between two datetime objects.\n    Supported operators:\n    - add, subtract timedelta\n    - unary plus, minus, abs\n    - compare to timedelta\n    - multiply, divide by int\n    In addition, datetime supports subtraction of two datetime objects\n    returning a timedelta, and addition or subtraction of a datetime\n    and a timedelta giving a datetime.",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "date",
        "kind": 6,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "class date:\n    \"\"\"Concrete date type.\n    Constructors:\n    __new__()\n    fromtimestamp()\n    today()\n    fromordinal()\n    Operators:\n    __repr__, __str__\n    __eq__, __le__, __lt__, __ge__, __gt__, __hash__",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "tzinfo",
        "kind": 6,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "class tzinfo:\n    \"\"\"Abstract base class for time zone info classes.\n    Subclasses must override the name(), utcoffset() and dst() methods.\n    \"\"\"\n    __slots__ = ()\n    def tzname(self, dt):\n        \"datetime -> string name of time zone.\"\n        raise NotImplementedError(\"tzinfo subclass must override tzname()\")\n    def utcoffset(self, dt):\n        \"datetime -> timedelta, positive for east of UTC, negative for west of UTC\"",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "IsoCalendarDate",
        "kind": 6,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "class IsoCalendarDate(tuple):\n    def __new__(cls, year, week, weekday, /):\n        return super().__new__(cls, (year, week, weekday))\n    @property\n    def year(self):\n        return self[0]\n    @property\n    def week(self):\n        return self[1]\n    @property",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "class time:\n    \"\"\"Time with time zone.\n    Constructors:\n    __new__()\n    Operators:\n    __repr__, __str__\n    __eq__, __le__, __lt__, __ge__, __gt__, __hash__\n    Methods:\n    strftime()\n    isoformat()",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "class datetime(date):\n    \"\"\"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n    The year, month and day arguments are required. tzinfo may be None, or an\n    instance of a tzinfo subclass. The remaining arguments may be ints.\n    \"\"\"\n    __slots__ = date.__slots__ + time.__slots__\n    def __new__(cls, year, month=None, day=None, hour=0, minute=0, second=0,\n                microsecond=0, tzinfo=None, *, fold=0):\n        if (isinstance(year, (bytes, str)) and len(year) == 10 and\n            1 <= ord(year[2:3])&0x7F <= 12):",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "kind": 6,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "class timezone(tzinfo):\n    __slots__ = '_offset', '_name'\n    # Sentinel value to disallow None\n    _Omitted = object()\n    def __new__(cls, offset, name=_Omitted):\n        if not isinstance(offset, timedelta):\n            raise TypeError(\"offset must be a timedelta\")\n        if name is cls._Omitted:\n            if not offset:\n                return cls.utc",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "__all__ = (\"date\", \"datetime\", \"time\", \"timedelta\", \"timezone\", \"tzinfo\",\n           \"MINYEAR\", \"MAXYEAR\")\nimport time as _time\nimport math as _math\nimport sys\nfrom operator import index as _index\ndef _cmp(x, y):\n    return 0 if x == y else 1 if x > y else -1\nMINYEAR = 1\nMAXYEAR = 9999",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "MINYEAR",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "MINYEAR = 1\nMAXYEAR = 9999\n_MAXORDINAL = 3652059  # date.max.toordinal()\n# Utility functions, adapted from Python's Demo/classes/Dates.py, which\n# also assumes the current Gregorian calendar indefinitely extended in\n# both directions.  Difference:  Dates.py calls January 1 of year 0 day\n# number 1.  The code here calls January 1 of year 1 day number 1.  This is\n# to match the definition of the \"proleptic Gregorian\" calendar in Dershowitz\n# and Reingold's \"Calendrical Calculations\", where it's the base calendar\n# for all computations.  See the book for algorithms for converting between",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "MAXYEAR",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "MAXYEAR = 9999\n_MAXORDINAL = 3652059  # date.max.toordinal()\n# Utility functions, adapted from Python's Demo/classes/Dates.py, which\n# also assumes the current Gregorian calendar indefinitely extended in\n# both directions.  Difference:  Dates.py calls January 1 of year 0 day\n# number 1.  The code here calls January 1 of year 1 day number 1.  This is\n# to match the definition of the \"proleptic Gregorian\" calendar in Dershowitz\n# and Reingold's \"Calendrical Calculations\", where it's the base calendar\n# for all computations.  See the book for algorithms for converting between\n# proleptic Gregorian ordinals and many other calendar systems.",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "_MAXORDINAL",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "_MAXORDINAL = 3652059  # date.max.toordinal()\n# Utility functions, adapted from Python's Demo/classes/Dates.py, which\n# also assumes the current Gregorian calendar indefinitely extended in\n# both directions.  Difference:  Dates.py calls January 1 of year 0 day\n# number 1.  The code here calls January 1 of year 1 day number 1.  This is\n# to match the definition of the \"proleptic Gregorian\" calendar in Dershowitz\n# and Reingold's \"Calendrical Calculations\", where it's the base calendar\n# for all computations.  See the book for algorithms for converting between\n# proleptic Gregorian ordinals and many other calendar systems.\n# -1 is a placeholder for indexing purposes.",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "_DAYS_IN_MONTH",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "_DAYS_IN_MONTH = [-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n_DAYS_BEFORE_MONTH = [-1]  # -1 is a placeholder for indexing purposes.\ndbm = 0\nfor dim in _DAYS_IN_MONTH[1:]:\n    _DAYS_BEFORE_MONTH.append(dbm)\n    dbm += dim\ndel dbm, dim\ndef _is_leap(year):\n    \"year -> 1 if leap year, else 0.\"\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "_DAYS_BEFORE_MONTH",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "_DAYS_BEFORE_MONTH = [-1]  # -1 is a placeholder for indexing purposes.\ndbm = 0\nfor dim in _DAYS_IN_MONTH[1:]:\n    _DAYS_BEFORE_MONTH.append(dbm)\n    dbm += dim\ndel dbm, dim\ndef _is_leap(year):\n    \"year -> 1 if leap year, else 0.\"\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\ndef _days_before_year(year):",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "dbm",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "dbm = 0\nfor dim in _DAYS_IN_MONTH[1:]:\n    _DAYS_BEFORE_MONTH.append(dbm)\n    dbm += dim\ndel dbm, dim\ndef _is_leap(year):\n    \"year -> 1 if leap year, else 0.\"\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\ndef _days_before_year(year):\n    \"year -> number of days before January 1st of year.\"",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "_DI400Y",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "_DI400Y = _days_before_year(401)    # number of days in 400 years\n_DI100Y = _days_before_year(101)    #    \"    \"   \"   \" 100   \"\n_DI4Y   = _days_before_year(5)      #    \"    \"   \"   \"   4   \"\n# A 4-year cycle has an extra leap day over what we'd get from pasting\n# together 4 single years.\nassert _DI4Y == 4 * 365 + 1\n# Similarly, a 400-year cycle has an extra leap day over what we'd get from\n# pasting together 4 100-year cycles.\nassert _DI400Y == 4 * _DI100Y + 1\n# OTOH, a 100-year cycle has one fewer leap day than we'd get from",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "_DI100Y",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "_DI100Y = _days_before_year(101)    #    \"    \"   \"   \" 100   \"\n_DI4Y   = _days_before_year(5)      #    \"    \"   \"   \"   4   \"\n# A 4-year cycle has an extra leap day over what we'd get from pasting\n# together 4 single years.\nassert _DI4Y == 4 * 365 + 1\n# Similarly, a 400-year cycle has an extra leap day over what we'd get from\n# pasting together 4 100-year cycles.\nassert _DI400Y == 4 * _DI100Y + 1\n# OTOH, a 100-year cycle has one fewer leap day than we'd get from\n# pasting together 25 4-year cycles.",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "_MONTHNAMES",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "_MONTHNAMES = [None, \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n                     \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n_DAYNAMES = [None, \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"]\ndef _build_struct_time(y, m, d, hh, mm, ss, dstflag):\n    wday = (_ymd2ord(y, m, d) + 6) % 7\n    dnum = _days_before_month(y, m) + d\n    return _time.struct_time((y, m, d, hh, mm, ss, wday, dnum, dstflag))\ndef _format_time(hh, mm, ss, us, timespec='auto'):\n    specs = {\n        'hours': '{:02d}',",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "_DAYNAMES",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "_DAYNAMES = [None, \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"]\ndef _build_struct_time(y, m, d, hh, mm, ss, dstflag):\n    wday = (_ymd2ord(y, m, d) + 6) % 7\n    dnum = _days_before_month(y, m) + d\n    return _time.struct_time((y, m, d, hh, mm, ss, wday, dnum, dstflag))\ndef _format_time(hh, mm, ss, us, timespec='auto'):\n    specs = {\n        'hours': '{:02d}',\n        'minutes': '{:02d}:{:02d}',\n        'seconds': '{:02d}:{:02d}:{:02d}',",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "timedelta.min",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "timedelta.min = timedelta(-999999999)\ntimedelta.max = timedelta(days=999999999, hours=23, minutes=59, seconds=59,\n                          microseconds=999999)\ntimedelta.resolution = timedelta(microseconds=1)\nclass date:\n    \"\"\"Concrete date type.\n    Constructors:\n    __new__()\n    fromtimestamp()\n    today()",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "timedelta.max",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "timedelta.max = timedelta(days=999999999, hours=23, minutes=59, seconds=59,\n                          microseconds=999999)\ntimedelta.resolution = timedelta(microseconds=1)\nclass date:\n    \"\"\"Concrete date type.\n    Constructors:\n    __new__()\n    fromtimestamp()\n    today()\n    fromordinal()",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "timedelta.resolution",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "timedelta.resolution = timedelta(microseconds=1)\nclass date:\n    \"\"\"Concrete date type.\n    Constructors:\n    __new__()\n    fromtimestamp()\n    today()\n    fromordinal()\n    Operators:\n    __repr__, __str__",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "_date_class",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "_date_class = date  # so functions w/ args named \"date\" can get at the class\ndate.min = date(1, 1, 1)\ndate.max = date(9999, 12, 31)\ndate.resolution = timedelta(days=1)\nclass tzinfo:\n    \"\"\"Abstract base class for time zone info classes.\n    Subclasses must override the name(), utcoffset() and dst() methods.\n    \"\"\"\n    __slots__ = ()\n    def tzname(self, dt):",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "date.min",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "date.min = date(1, 1, 1)\ndate.max = date(9999, 12, 31)\ndate.resolution = timedelta(days=1)\nclass tzinfo:\n    \"\"\"Abstract base class for time zone info classes.\n    Subclasses must override the name(), utcoffset() and dst() methods.\n    \"\"\"\n    __slots__ = ()\n    def tzname(self, dt):\n        \"datetime -> string name of time zone.\"",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "date.max",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "date.max = date(9999, 12, 31)\ndate.resolution = timedelta(days=1)\nclass tzinfo:\n    \"\"\"Abstract base class for time zone info classes.\n    Subclasses must override the name(), utcoffset() and dst() methods.\n    \"\"\"\n    __slots__ = ()\n    def tzname(self, dt):\n        \"datetime -> string name of time zone.\"\n        raise NotImplementedError(\"tzinfo subclass must override tzname()\")",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "date.resolution",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "date.resolution = timedelta(days=1)\nclass tzinfo:\n    \"\"\"Abstract base class for time zone info classes.\n    Subclasses must override the name(), utcoffset() and dst() methods.\n    \"\"\"\n    __slots__ = ()\n    def tzname(self, dt):\n        \"datetime -> string name of time zone.\"\n        raise NotImplementedError(\"tzinfo subclass must override tzname()\")\n    def utcoffset(self, dt):",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "_IsoCalendarDate",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "_IsoCalendarDate = IsoCalendarDate\ndel IsoCalendarDate\n_tzinfo_class = tzinfo\nclass time:\n    \"\"\"Time with time zone.\n    Constructors:\n    __new__()\n    Operators:\n    __repr__, __str__\n    __eq__, __le__, __lt__, __ge__, __gt__, __hash__",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "_tzinfo_class",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "_tzinfo_class = tzinfo\nclass time:\n    \"\"\"Time with time zone.\n    Constructors:\n    __new__()\n    Operators:\n    __repr__, __str__\n    __eq__, __le__, __lt__, __ge__, __gt__, __hash__\n    Methods:\n    strftime()",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "_time_class",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "_time_class = time  # so functions w/ args named \"time\" can get at the class\ntime.min = time(0, 0, 0)\ntime.max = time(23, 59, 59, 999999)\ntime.resolution = timedelta(microseconds=1)\nclass datetime(date):\n    \"\"\"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n    The year, month and day arguments are required. tzinfo may be None, or an\n    instance of a tzinfo subclass. The remaining arguments may be ints.\n    \"\"\"\n    __slots__ = date.__slots__ + time.__slots__",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "time.min",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "time.min = time(0, 0, 0)\ntime.max = time(23, 59, 59, 999999)\ntime.resolution = timedelta(microseconds=1)\nclass datetime(date):\n    \"\"\"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n    The year, month and day arguments are required. tzinfo may be None, or an\n    instance of a tzinfo subclass. The remaining arguments may be ints.\n    \"\"\"\n    __slots__ = date.__slots__ + time.__slots__\n    def __new__(cls, year, month=None, day=None, hour=0, minute=0, second=0,",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "time.max",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "time.max = time(23, 59, 59, 999999)\ntime.resolution = timedelta(microseconds=1)\nclass datetime(date):\n    \"\"\"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n    The year, month and day arguments are required. tzinfo may be None, or an\n    instance of a tzinfo subclass. The remaining arguments may be ints.\n    \"\"\"\n    __slots__ = date.__slots__ + time.__slots__\n    def __new__(cls, year, month=None, day=None, hour=0, minute=0, second=0,\n                microsecond=0, tzinfo=None, *, fold=0):",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "time.resolution",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "time.resolution = timedelta(microseconds=1)\nclass datetime(date):\n    \"\"\"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n    The year, month and day arguments are required. tzinfo may be None, or an\n    instance of a tzinfo subclass. The remaining arguments may be ints.\n    \"\"\"\n    __slots__ = date.__slots__ + time.__slots__\n    def __new__(cls, year, month=None, day=None, hour=0, minute=0, second=0,\n                microsecond=0, tzinfo=None, *, fold=0):\n        if (isinstance(year, (bytes, str)) and len(year) == 10 and",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "datetime.min",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "datetime.min = datetime(1, 1, 1)\ndatetime.max = datetime(9999, 12, 31, 23, 59, 59, 999999)\ndatetime.resolution = timedelta(microseconds=1)\ndef _isoweek1monday(year):\n    # Helper to calculate the day number of the Monday starting week 1\n    # XXX This could be done more efficiently\n    THURSDAY = 3\n    firstday = _ymd2ord(year, 1, 1)\n    firstweekday = (firstday + 6) % 7  # See weekday() above\n    week1monday = firstday - firstweekday",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "datetime.max",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "datetime.max = datetime(9999, 12, 31, 23, 59, 59, 999999)\ndatetime.resolution = timedelta(microseconds=1)\ndef _isoweek1monday(year):\n    # Helper to calculate the day number of the Monday starting week 1\n    # XXX This could be done more efficiently\n    THURSDAY = 3\n    firstday = _ymd2ord(year, 1, 1)\n    firstweekday = (firstday + 6) % 7  # See weekday() above\n    week1monday = firstday - firstweekday\n    if firstweekday > THURSDAY:",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "datetime.resolution",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "datetime.resolution = timedelta(microseconds=1)\ndef _isoweek1monday(year):\n    # Helper to calculate the day number of the Monday starting week 1\n    # XXX This could be done more efficiently\n    THURSDAY = 3\n    firstday = _ymd2ord(year, 1, 1)\n    firstweekday = (firstday + 6) % 7  # See weekday() above\n    week1monday = firstday - firstweekday\n    if firstweekday > THURSDAY:\n        week1monday += 7",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "timezone.utc",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "timezone.utc = timezone._create(timedelta(0))\n# bpo-37642: These attributes are rounded to the nearest minute for backwards\n# compatibility, even though the constructor will accept a wider range of\n# values. This may change in the future.\ntimezone.min = timezone._create(-timedelta(hours=23, minutes=59))\ntimezone.max = timezone._create(timedelta(hours=23, minutes=59))\n_EPOCH = datetime(1970, 1, 1, tzinfo=timezone.utc)\n# Some time zone algebra.  For a datetime x, let\n#     x.n = x stripped of its timezone -- its naive time.\n#     x.o = x.utcoffset(), and assuming that doesn't raise an exception or",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "timezone.min",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "timezone.min = timezone._create(-timedelta(hours=23, minutes=59))\ntimezone.max = timezone._create(timedelta(hours=23, minutes=59))\n_EPOCH = datetime(1970, 1, 1, tzinfo=timezone.utc)\n# Some time zone algebra.  For a datetime x, let\n#     x.n = x stripped of its timezone -- its naive time.\n#     x.o = x.utcoffset(), and assuming that doesn't raise an exception or\n#           return None\n#     x.d = x.dst(), and assuming that doesn't raise an exception or\n#           return None\n#     x.s = x's standard offset, x.o - x.d",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "timezone.max",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "timezone.max = timezone._create(timedelta(hours=23, minutes=59))\n_EPOCH = datetime(1970, 1, 1, tzinfo=timezone.utc)\n# Some time zone algebra.  For a datetime x, let\n#     x.n = x stripped of its timezone -- its naive time.\n#     x.o = x.utcoffset(), and assuming that doesn't raise an exception or\n#           return None\n#     x.d = x.dst(), and assuming that doesn't raise an exception or\n#           return None\n#     x.s = x's standard offset, x.o - x.d\n#",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "_EPOCH",
        "kind": 5,
        "importPath": "protobuf.Lib.datetime",
        "description": "protobuf.Lib.datetime",
        "peekOfCode": "_EPOCH = datetime(1970, 1, 1, tzinfo=timezone.utc)\n# Some time zone algebra.  For a datetime x, let\n#     x.n = x stripped of its timezone -- its naive time.\n#     x.o = x.utcoffset(), and assuming that doesn't raise an exception or\n#           return None\n#     x.d = x.dst(), and assuming that doesn't raise an exception or\n#           return None\n#     x.s = x's standard offset, x.o - x.d\n#\n# Now some derived rules, where k is a duration (timedelta).",
        "detail": "protobuf.Lib.datetime",
        "documentation": {}
    },
    {
        "label": "SequenceMatcher",
        "kind": 6,
        "importPath": "protobuf.Lib.difflib",
        "description": "protobuf.Lib.difflib",
        "peekOfCode": "class SequenceMatcher:\n    \"\"\"\n    SequenceMatcher is a flexible class for comparing pairs of sequences of\n    any type, so long as the sequence elements are hashable.  The basic\n    algorithm predates, and is a little fancier than, an algorithm\n    published in the late 1980's by Ratcliff and Obershelp under the\n    hyperbolic name \"gestalt pattern matching\".  The basic idea is to find\n    the longest contiguous matching subsequence that contains no \"junk\"\n    elements (R-O doesn't address junk).  The same idea is then applied\n    recursively to the pieces of the sequences to the left and to the right",
        "detail": "protobuf.Lib.difflib",
        "documentation": {}
    },
    {
        "label": "Differ",
        "kind": 6,
        "importPath": "protobuf.Lib.difflib",
        "description": "protobuf.Lib.difflib",
        "peekOfCode": "class Differ:\n    r\"\"\"\n    Differ is a class for comparing sequences of lines of text, and\n    producing human-readable differences or deltas.  Differ uses\n    SequenceMatcher both to compare sequences of lines, and to compare\n    sequences of characters within similar (near-matching) lines.\n    Each line of a Differ delta begins with a two-letter code:\n        '- '    line unique to sequence 1\n        '+ '    line unique to sequence 2\n        '  '    line common to both sequences",
        "detail": "protobuf.Lib.difflib",
        "documentation": {}
    },
    {
        "label": "HtmlDiff",
        "kind": 6,
        "importPath": "protobuf.Lib.difflib",
        "description": "protobuf.Lib.difflib",
        "peekOfCode": "class HtmlDiff(object):\n    \"\"\"For producing HTML side by side comparison with change highlights.\n    This class can be used to create an HTML table (or a complete HTML file\n    containing the table) showing a side by side, line by line comparison\n    of text with inter-line and intra-line change highlights.  The table can\n    be generated in either full or contextual difference mode.\n    The following methods are provided for HTML generation:\n    make_table -- generates HTML for a single side by side table\n    make_file -- generates complete HTML file with a single side by side table\n    See tools/scripts/diff.py for an example usage of this class.",
        "detail": "protobuf.Lib.difflib",
        "documentation": {}
    },
    {
        "label": "get_close_matches",
        "kind": 2,
        "importPath": "protobuf.Lib.difflib",
        "description": "protobuf.Lib.difflib",
        "peekOfCode": "def get_close_matches(word, possibilities, n=3, cutoff=0.6):\n    \"\"\"Use SequenceMatcher to return list of the best \"good enough\" matches.\n    word is a sequence for which close matches are desired (typically a\n    string).\n    possibilities is a list of sequences against which to match word\n    (typically a list of strings).\n    Optional arg n (default 3) is the maximum number of close matches to\n    return.  n must be > 0.\n    Optional arg cutoff (default 0.6) is a float in [0, 1].  Possibilities\n    that don't score at least that similar to word are ignored.",
        "detail": "protobuf.Lib.difflib",
        "documentation": {}
    },
    {
        "label": "IS_LINE_JUNK",
        "kind": 2,
        "importPath": "protobuf.Lib.difflib",
        "description": "protobuf.Lib.difflib",
        "peekOfCode": "def IS_LINE_JUNK(line, pat=re.compile(r\"\\s*(?:#\\s*)?$\").match):\n    r\"\"\"\n    Return True for ignorable line: iff `line` is blank or contains a single '#'.\n    Examples:\n    >>> IS_LINE_JUNK('\\n')\n    True\n    >>> IS_LINE_JUNK('  #   \\n')\n    True\n    >>> IS_LINE_JUNK('hello\\n')\n    False",
        "detail": "protobuf.Lib.difflib",
        "documentation": {}
    },
    {
        "label": "IS_CHARACTER_JUNK",
        "kind": 2,
        "importPath": "protobuf.Lib.difflib",
        "description": "protobuf.Lib.difflib",
        "peekOfCode": "def IS_CHARACTER_JUNK(ch, ws=\" \\t\"):\n    r\"\"\"\n    Return True for ignorable character: iff `ch` is a space or tab.\n    Examples:\n    >>> IS_CHARACTER_JUNK(' ')\n    True\n    >>> IS_CHARACTER_JUNK('\\t')\n    True\n    >>> IS_CHARACTER_JUNK('\\n')\n    False",
        "detail": "protobuf.Lib.difflib",
        "documentation": {}
    },
    {
        "label": "unified_diff",
        "kind": 2,
        "importPath": "protobuf.Lib.difflib",
        "description": "protobuf.Lib.difflib",
        "peekOfCode": "def unified_diff(a, b, fromfile='', tofile='', fromfiledate='',\n                 tofiledate='', n=3, lineterm='\\n'):\n    r\"\"\"\n    Compare two sequences of lines; generate the delta as a unified diff.\n    Unified diffs are a compact way of showing line changes and a few\n    lines of context.  The number of context lines is set by 'n' which\n    defaults to three.\n    By default, the diff control lines (those with ---, +++, or @@) are\n    created with a trailing newline.  This is helpful so that inputs\n    created from file.readlines() result in diffs that are suitable for",
        "detail": "protobuf.Lib.difflib",
        "documentation": {}
    },
    {
        "label": "context_diff",
        "kind": 2,
        "importPath": "protobuf.Lib.difflib",
        "description": "protobuf.Lib.difflib",
        "peekOfCode": "def context_diff(a, b, fromfile='', tofile='',\n                 fromfiledate='', tofiledate='', n=3, lineterm='\\n'):\n    r\"\"\"\n    Compare two sequences of lines; generate the delta as a context diff.\n    Context diffs are a compact way of showing line changes and a few\n    lines of context.  The number of context lines is set by 'n' which\n    defaults to three.\n    By default, the diff control lines (those with *** or ---) are\n    created with a trailing newline.  This is helpful so that inputs\n    created from file.readlines() result in diffs that are suitable for",
        "detail": "protobuf.Lib.difflib",
        "documentation": {}
    },
    {
        "label": "diff_bytes",
        "kind": 2,
        "importPath": "protobuf.Lib.difflib",
        "description": "protobuf.Lib.difflib",
        "peekOfCode": "def diff_bytes(dfunc, a, b, fromfile=b'', tofile=b'',\n               fromfiledate=b'', tofiledate=b'', n=3, lineterm=b'\\n'):\n    r\"\"\"\n    Compare `a` and `b`, two sequences of lines represented as bytes rather\n    than str. This is a wrapper for `dfunc`, which is typically either\n    unified_diff() or context_diff(). Inputs are losslessly converted to\n    strings so that `dfunc` only has to worry about strings, and encoded\n    back to bytes on return. This is necessary to compare files with\n    unknown or inconsistent encoding. All other inputs (except `n`) must be\n    bytes rather than str.",
        "detail": "protobuf.Lib.difflib",
        "documentation": {}
    },
    {
        "label": "ndiff",
        "kind": 2,
        "importPath": "protobuf.Lib.difflib",
        "description": "protobuf.Lib.difflib",
        "peekOfCode": "def ndiff(a, b, linejunk=None, charjunk=IS_CHARACTER_JUNK):\n    r\"\"\"\n    Compare `a` and `b` (lists of strings); return a `Differ`-style delta.\n    Optional keyword parameters `linejunk` and `charjunk` are for filter\n    functions, or can be None:\n    - linejunk: A function that should accept a single string argument and\n      return true iff the string is junk.  The default is None, and is\n      recommended; the underlying SequenceMatcher class has an adaptive\n      notion of \"noise\" lines.\n    - charjunk: A function that accepts a character (string of length",
        "detail": "protobuf.Lib.difflib",
        "documentation": {}
    },
    {
        "label": "restore",
        "kind": 2,
        "importPath": "protobuf.Lib.difflib",
        "description": "protobuf.Lib.difflib",
        "peekOfCode": "def restore(delta, which):\n    r\"\"\"\n    Generate one of the two sequences that generated a delta.\n    Given a `delta` produced by `Differ.compare()` or `ndiff()`, extract\n    lines originating from file 1 or 2 (parameter `which`), stripping off line\n    prefixes.\n    Examples:\n    >>> diff = ndiff('one\\ntwo\\nthree\\n'.splitlines(keepends=True),\n    ...              'ore\\ntree\\nemu\\n'.splitlines(keepends=True))\n    >>> diff = list(diff)",
        "detail": "protobuf.Lib.difflib",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.difflib",
        "description": "protobuf.Lib.difflib",
        "peekOfCode": "__all__ = ['get_close_matches', 'ndiff', 'restore', 'SequenceMatcher',\n           'Differ','IS_CHARACTER_JUNK', 'IS_LINE_JUNK', 'context_diff',\n           'unified_diff', 'diff_bytes', 'HtmlDiff', 'Match']\nfrom heapq import nlargest as _nlargest\nfrom collections import namedtuple as _namedtuple\nfrom types import GenericAlias\nMatch = _namedtuple('Match', 'a b size')\ndef _calculate_ratio(matches, length):\n    if length:\n        return 2.0 * matches / length",
        "detail": "protobuf.Lib.difflib",
        "documentation": {}
    },
    {
        "label": "Match",
        "kind": 5,
        "importPath": "protobuf.Lib.difflib",
        "description": "protobuf.Lib.difflib",
        "peekOfCode": "Match = _namedtuple('Match', 'a b size')\ndef _calculate_ratio(matches, length):\n    if length:\n        return 2.0 * matches / length\n    return 1.0\nclass SequenceMatcher:\n    \"\"\"\n    SequenceMatcher is a flexible class for comparing pairs of sequences of\n    any type, so long as the sequence elements are hashable.  The basic\n    algorithm predates, and is a little fancier than, an algorithm",
        "detail": "protobuf.Lib.difflib",
        "documentation": {}
    },
    {
        "label": "_file_template",
        "kind": 5,
        "importPath": "protobuf.Lib.difflib",
        "description": "protobuf.Lib.difflib",
        "peekOfCode": "_file_template = \"\"\"\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n          \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html>\n<head>\n    <meta http-equiv=\"Content-Type\"\n          content=\"text/html; charset=%(charset)s\" />\n    <title></title>\n    <style type=\"text/css\">%(styles)s\n    </style>",
        "detail": "protobuf.Lib.difflib",
        "documentation": {}
    },
    {
        "label": "_styles",
        "kind": 5,
        "importPath": "protobuf.Lib.difflib",
        "description": "protobuf.Lib.difflib",
        "peekOfCode": "_styles = \"\"\"\n        table.diff {font-family:Courier; border:medium;}\n        .diff_header {background-color:#e0e0e0}\n        td.diff_header {text-align:right}\n        .diff_next {background-color:#c0c0c0}\n        .diff_add {background-color:#aaffaa}\n        .diff_chg {background-color:#ffff77}\n        .diff_sub {background-color:#ffaaaa}\"\"\"\n_table_template = \"\"\"\n    <table class=\"diff\" id=\"difflib_chg_%(prefix)s_top\"",
        "detail": "protobuf.Lib.difflib",
        "documentation": {}
    },
    {
        "label": "_table_template",
        "kind": 5,
        "importPath": "protobuf.Lib.difflib",
        "description": "protobuf.Lib.difflib",
        "peekOfCode": "_table_template = \"\"\"\n    <table class=\"diff\" id=\"difflib_chg_%(prefix)s_top\"\n           cellspacing=\"0\" cellpadding=\"0\" rules=\"groups\" >\n        <colgroup></colgroup> <colgroup></colgroup> <colgroup></colgroup>\n        <colgroup></colgroup> <colgroup></colgroup> <colgroup></colgroup>\n        %(header_row)s\n        <tbody>\n%(data_rows)s        </tbody>\n    </table>\"\"\"\n_legend = \"\"\"",
        "detail": "protobuf.Lib.difflib",
        "documentation": {}
    },
    {
        "label": "_legend",
        "kind": 5,
        "importPath": "protobuf.Lib.difflib",
        "description": "protobuf.Lib.difflib",
        "peekOfCode": "_legend = \"\"\"\n    <table class=\"diff\" summary=\"Legends\">\n        <tr> <th colspan=\"2\"> Legends </th> </tr>\n        <tr> <td> <table border=\"\" summary=\"Colors\">\n                      <tr><th> Colors </th> </tr>\n                      <tr><td class=\"diff_add\">&nbsp;Added&nbsp;</td></tr>\n                      <tr><td class=\"diff_chg\">Changed</td> </tr>\n                      <tr><td class=\"diff_sub\">Deleted</td> </tr>\n                  </table></td>\n             <td> <table border=\"\" summary=\"Links\">",
        "detail": "protobuf.Lib.difflib",
        "documentation": {}
    },
    {
        "label": "Instruction",
        "kind": 6,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "class Instruction(_Instruction):\n    \"\"\"Details for a bytecode operation\n       Defined fields:\n         opname - human readable name for operation\n         opcode - numeric code for operation\n         arg - numeric argument to operation (if any), otherwise None\n         argval - resolved arg value (if known), otherwise same as arg\n         argrepr - human readable description of operation argument\n         offset - start index of operation within bytecode sequence\n         starts_line - line started by this opcode (if any), otherwise None",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "Bytecode",
        "kind": 6,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "class Bytecode:\n    \"\"\"The bytecode operations of a piece of code\n    Instantiate this with a function, method, other compiled object, string of\n    code, or a code object (as returned by compile()).\n    Iterating over this yields the bytecode operations as Instruction instances.\n    \"\"\"\n    def __init__(self, x, *, first_line=None, current_offset=None):\n        self.codeobj = co = _get_code_object(x)\n        if first_line is None:\n            self.first_line = co.co_firstlineno",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "dis",
        "kind": 2,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "def dis(x=None, *, file=None, depth=None):\n    \"\"\"Disassemble classes, methods, functions, and other compiled objects.\n    With no argument, disassemble the last traceback.\n    Compiled objects currently include generator objects, async generator\n    objects, and coroutine objects, all of which store their code object\n    in a special attribute.\n    \"\"\"\n    if x is None:\n        distb(file=file)\n        return",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "distb",
        "kind": 2,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "def distb(tb=None, *, file=None):\n    \"\"\"Disassemble a traceback (default: last traceback).\"\"\"\n    if tb is None:\n        try:\n            tb = sys.last_traceback\n        except AttributeError:\n            raise RuntimeError(\"no last traceback to disassemble\") from None\n        while tb.tb_next: tb = tb.tb_next\n    disassemble(tb.tb_frame.f_code, tb.tb_lasti, file=file)\n# The inspect module interrogates this dictionary to build its",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "pretty_flags",
        "kind": 2,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "def pretty_flags(flags):\n    \"\"\"Return pretty representation of code flags.\"\"\"\n    names = []\n    for i in range(32):\n        flag = 1<<i\n        if flags & flag:\n            names.append(COMPILER_FLAG_NAMES.get(flag, hex(flag)))\n            flags ^= flag\n            if not flags:\n                break",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "code_info",
        "kind": 2,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "def code_info(x):\n    \"\"\"Formatted details of methods, functions, or code.\"\"\"\n    return _format_code_info(_get_code_object(x))\ndef _format_code_info(co):\n    lines = []\n    lines.append(\"Name:              %s\" % co.co_name)\n    lines.append(\"Filename:          %s\" % co.co_filename)\n    lines.append(\"Argument count:    %s\" % co.co_argcount)\n    lines.append(\"Positional-only arguments: %s\" % co.co_posonlyargcount)\n    lines.append(\"Kw-only arguments: %s\" % co.co_kwonlyargcount)",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "show_code",
        "kind": 2,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "def show_code(co, *, file=None):\n    \"\"\"Print details of methods, functions, or code to *file*.\n    If *file* is not provided, the output is printed on stdout.\n    \"\"\"\n    print(code_info(co), file=file)\n_Instruction = collections.namedtuple(\"_Instruction\",\n     \"opname opcode arg argval argrepr offset starts_line is_jump_target\")\n_Instruction.opname.__doc__ = \"Human readable name for operation\"\n_Instruction.opcode.__doc__ = \"Numeric code for operation\"\n_Instruction.arg.__doc__ = \"Numeric argument to operation (if any), otherwise None\"",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "get_instructions",
        "kind": 2,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "def get_instructions(x, *, first_line=None):\n    \"\"\"Iterator for the opcodes in methods, functions or code\n    Generates a series of Instruction named tuples giving the details of\n    each operations in the supplied code.\n    If *first_line* is not None, it indicates the line number that should\n    be reported for the first source line in the disassembled code.\n    Otherwise, the source line information (if any) is taken directly from\n    the disassembled code object.\n    \"\"\"\n    co = _get_code_object(x)",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "disassemble",
        "kind": 2,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "def disassemble(co, lasti=-1, *, file=None):\n    \"\"\"Disassemble a code object.\"\"\"\n    cell_names = co.co_cellvars + co.co_freevars\n    linestarts = dict(findlinestarts(co))\n    _disassemble_bytes(co.co_code, lasti, co.co_varnames, co.co_names,\n                       co.co_consts, cell_names, linestarts, file=file)\ndef _disassemble_recursive(co, *, file=None, depth=None):\n    disassemble(co, file=file)\n    if depth is None or depth > 0:\n        if depth is not None:",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "findlabels",
        "kind": 2,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "def findlabels(code):\n    \"\"\"Detect all offsets in a byte code which are jump targets.\n    Return the list of offsets.\n    \"\"\"\n    labels = []\n    for offset, op, arg in _unpack_opargs(code):\n        if arg is not None:\n            if op in hasjrel:\n                label = offset + 2 + arg*2\n            elif op in hasjabs:",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "findlinestarts",
        "kind": 2,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "def findlinestarts(code):\n    \"\"\"Find the offsets in a byte code which are start of lines in the source.\n    Generate pairs (offset, lineno)\n    \"\"\"\n    lastline = None\n    for start, end, line in code.co_lines():\n        if line is not None and line != lastline:\n            lastline = line\n            yield start, line\n    return",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "__all__ = [\"code_info\", \"dis\", \"disassemble\", \"distb\", \"disco\",\n           \"findlinestarts\", \"findlabels\", \"show_code\",\n           \"get_instructions\", \"Instruction\", \"Bytecode\"] + _opcodes_all\ndel _opcodes_all\n_have_code = (types.MethodType, types.FunctionType, types.CodeType,\n              classmethod, staticmethod, type)\nFORMAT_VALUE = opmap['FORMAT_VALUE']\nFORMAT_VALUE_CONVERTERS = (\n    (None, ''),\n    (str, 'str'),",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "_have_code",
        "kind": 5,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "_have_code = (types.MethodType, types.FunctionType, types.CodeType,\n              classmethod, staticmethod, type)\nFORMAT_VALUE = opmap['FORMAT_VALUE']\nFORMAT_VALUE_CONVERTERS = (\n    (None, ''),\n    (str, 'str'),\n    (repr, 'repr'),\n    (ascii, 'ascii'),\n)\nMAKE_FUNCTION = opmap['MAKE_FUNCTION']",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "FORMAT_VALUE",
        "kind": 5,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "FORMAT_VALUE = opmap['FORMAT_VALUE']\nFORMAT_VALUE_CONVERTERS = (\n    (None, ''),\n    (str, 'str'),\n    (repr, 'repr'),\n    (ascii, 'ascii'),\n)\nMAKE_FUNCTION = opmap['MAKE_FUNCTION']\nMAKE_FUNCTION_FLAGS = ('defaults', 'kwdefaults', 'annotations', 'closure')\ndef _try_compile(source, name):",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "FORMAT_VALUE_CONVERTERS",
        "kind": 5,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "FORMAT_VALUE_CONVERTERS = (\n    (None, ''),\n    (str, 'str'),\n    (repr, 'repr'),\n    (ascii, 'ascii'),\n)\nMAKE_FUNCTION = opmap['MAKE_FUNCTION']\nMAKE_FUNCTION_FLAGS = ('defaults', 'kwdefaults', 'annotations', 'closure')\ndef _try_compile(source, name):\n    \"\"\"Attempts to compile the given source, first as an expression and",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "MAKE_FUNCTION",
        "kind": 5,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "MAKE_FUNCTION = opmap['MAKE_FUNCTION']\nMAKE_FUNCTION_FLAGS = ('defaults', 'kwdefaults', 'annotations', 'closure')\ndef _try_compile(source, name):\n    \"\"\"Attempts to compile the given source, first as an expression and\n       then as a statement if the first approach fails.\n       Utility function to accept strings in functions that otherwise\n       expect code objects\n    \"\"\"\n    try:\n        c = compile(source, name, 'eval')",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "MAKE_FUNCTION_FLAGS",
        "kind": 5,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "MAKE_FUNCTION_FLAGS = ('defaults', 'kwdefaults', 'annotations', 'closure')\ndef _try_compile(source, name):\n    \"\"\"Attempts to compile the given source, first as an expression and\n       then as a statement if the first approach fails.\n       Utility function to accept strings in functions that otherwise\n       expect code objects\n    \"\"\"\n    try:\n        c = compile(source, name, 'eval')\n    except SyntaxError:",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "COMPILER_FLAG_NAMES",
        "kind": 5,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "COMPILER_FLAG_NAMES = {\n     1: \"OPTIMIZED\",\n     2: \"NEWLOCALS\",\n     4: \"VARARGS\",\n     8: \"VARKEYWORDS\",\n    16: \"NESTED\",\n    32: \"GENERATOR\",\n    64: \"NOFREE\",\n   128: \"COROUTINE\",\n   256: \"ITERABLE_COROUTINE\",",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "_Instruction",
        "kind": 5,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "_Instruction = collections.namedtuple(\"_Instruction\",\n     \"opname opcode arg argval argrepr offset starts_line is_jump_target\")\n_Instruction.opname.__doc__ = \"Human readable name for operation\"\n_Instruction.opcode.__doc__ = \"Numeric code for operation\"\n_Instruction.arg.__doc__ = \"Numeric argument to operation (if any), otherwise None\"\n_Instruction.argval.__doc__ = \"Resolved arg value (if known), otherwise same as arg\"\n_Instruction.argrepr.__doc__ = \"Human readable description of operation argument\"\n_Instruction.offset.__doc__ = \"Start index of operation within bytecode sequence\"\n_Instruction.starts_line.__doc__ = \"Line started by this opcode (if any), otherwise None\"\n_Instruction.is_jump_target.__doc__ = \"True if other code jumps to here, otherwise False\"",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "_Instruction.opname.__doc__",
        "kind": 5,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "_Instruction.opname.__doc__ = \"Human readable name for operation\"\n_Instruction.opcode.__doc__ = \"Numeric code for operation\"\n_Instruction.arg.__doc__ = \"Numeric argument to operation (if any), otherwise None\"\n_Instruction.argval.__doc__ = \"Resolved arg value (if known), otherwise same as arg\"\n_Instruction.argrepr.__doc__ = \"Human readable description of operation argument\"\n_Instruction.offset.__doc__ = \"Start index of operation within bytecode sequence\"\n_Instruction.starts_line.__doc__ = \"Line started by this opcode (if any), otherwise None\"\n_Instruction.is_jump_target.__doc__ = \"True if other code jumps to here, otherwise False\"\n_OPNAME_WIDTH = 20\n_OPARG_WIDTH = 5",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "_Instruction.opcode.__doc__",
        "kind": 5,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "_Instruction.opcode.__doc__ = \"Numeric code for operation\"\n_Instruction.arg.__doc__ = \"Numeric argument to operation (if any), otherwise None\"\n_Instruction.argval.__doc__ = \"Resolved arg value (if known), otherwise same as arg\"\n_Instruction.argrepr.__doc__ = \"Human readable description of operation argument\"\n_Instruction.offset.__doc__ = \"Start index of operation within bytecode sequence\"\n_Instruction.starts_line.__doc__ = \"Line started by this opcode (if any), otherwise None\"\n_Instruction.is_jump_target.__doc__ = \"True if other code jumps to here, otherwise False\"\n_OPNAME_WIDTH = 20\n_OPARG_WIDTH = 5\nclass Instruction(_Instruction):",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "_Instruction.arg.__doc__",
        "kind": 5,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "_Instruction.arg.__doc__ = \"Numeric argument to operation (if any), otherwise None\"\n_Instruction.argval.__doc__ = \"Resolved arg value (if known), otherwise same as arg\"\n_Instruction.argrepr.__doc__ = \"Human readable description of operation argument\"\n_Instruction.offset.__doc__ = \"Start index of operation within bytecode sequence\"\n_Instruction.starts_line.__doc__ = \"Line started by this opcode (if any), otherwise None\"\n_Instruction.is_jump_target.__doc__ = \"True if other code jumps to here, otherwise False\"\n_OPNAME_WIDTH = 20\n_OPARG_WIDTH = 5\nclass Instruction(_Instruction):\n    \"\"\"Details for a bytecode operation",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "_Instruction.argval.__doc__",
        "kind": 5,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "_Instruction.argval.__doc__ = \"Resolved arg value (if known), otherwise same as arg\"\n_Instruction.argrepr.__doc__ = \"Human readable description of operation argument\"\n_Instruction.offset.__doc__ = \"Start index of operation within bytecode sequence\"\n_Instruction.starts_line.__doc__ = \"Line started by this opcode (if any), otherwise None\"\n_Instruction.is_jump_target.__doc__ = \"True if other code jumps to here, otherwise False\"\n_OPNAME_WIDTH = 20\n_OPARG_WIDTH = 5\nclass Instruction(_Instruction):\n    \"\"\"Details for a bytecode operation\n       Defined fields:",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "_Instruction.argrepr.__doc__",
        "kind": 5,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "_Instruction.argrepr.__doc__ = \"Human readable description of operation argument\"\n_Instruction.offset.__doc__ = \"Start index of operation within bytecode sequence\"\n_Instruction.starts_line.__doc__ = \"Line started by this opcode (if any), otherwise None\"\n_Instruction.is_jump_target.__doc__ = \"True if other code jumps to here, otherwise False\"\n_OPNAME_WIDTH = 20\n_OPARG_WIDTH = 5\nclass Instruction(_Instruction):\n    \"\"\"Details for a bytecode operation\n       Defined fields:\n         opname - human readable name for operation",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "_Instruction.offset.__doc__",
        "kind": 5,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "_Instruction.offset.__doc__ = \"Start index of operation within bytecode sequence\"\n_Instruction.starts_line.__doc__ = \"Line started by this opcode (if any), otherwise None\"\n_Instruction.is_jump_target.__doc__ = \"True if other code jumps to here, otherwise False\"\n_OPNAME_WIDTH = 20\n_OPARG_WIDTH = 5\nclass Instruction(_Instruction):\n    \"\"\"Details for a bytecode operation\n       Defined fields:\n         opname - human readable name for operation\n         opcode - numeric code for operation",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "_Instruction.starts_line.__doc__",
        "kind": 5,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "_Instruction.starts_line.__doc__ = \"Line started by this opcode (if any), otherwise None\"\n_Instruction.is_jump_target.__doc__ = \"True if other code jumps to here, otherwise False\"\n_OPNAME_WIDTH = 20\n_OPARG_WIDTH = 5\nclass Instruction(_Instruction):\n    \"\"\"Details for a bytecode operation\n       Defined fields:\n         opname - human readable name for operation\n         opcode - numeric code for operation\n         arg - numeric argument to operation (if any), otherwise None",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "_Instruction.is_jump_target.__doc__",
        "kind": 5,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "_Instruction.is_jump_target.__doc__ = \"True if other code jumps to here, otherwise False\"\n_OPNAME_WIDTH = 20\n_OPARG_WIDTH = 5\nclass Instruction(_Instruction):\n    \"\"\"Details for a bytecode operation\n       Defined fields:\n         opname - human readable name for operation\n         opcode - numeric code for operation\n         arg - numeric argument to operation (if any), otherwise None\n         argval - resolved arg value (if known), otherwise same as arg",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "_OPNAME_WIDTH",
        "kind": 5,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "_OPNAME_WIDTH = 20\n_OPARG_WIDTH = 5\nclass Instruction(_Instruction):\n    \"\"\"Details for a bytecode operation\n       Defined fields:\n         opname - human readable name for operation\n         opcode - numeric code for operation\n         arg - numeric argument to operation (if any), otherwise None\n         argval - resolved arg value (if known), otherwise same as arg\n         argrepr - human readable description of operation argument",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "_OPARG_WIDTH",
        "kind": 5,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "_OPARG_WIDTH = 5\nclass Instruction(_Instruction):\n    \"\"\"Details for a bytecode operation\n       Defined fields:\n         opname - human readable name for operation\n         opcode - numeric code for operation\n         arg - numeric argument to operation (if any), otherwise None\n         argval - resolved arg value (if known), otherwise same as arg\n         argrepr - human readable description of operation argument\n         offset - start index of operation within bytecode sequence",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "disco",
        "kind": 5,
        "importPath": "protobuf.Lib.dis",
        "description": "protobuf.Lib.dis",
        "peekOfCode": "disco = disassemble                     # XXX For backwards compatibility\ndef _unpack_opargs(code):\n    extended_arg = 0\n    for i in range(0, len(code), 2):\n        op = code[i]\n        if op >= HAVE_ARGUMENT:\n            arg = code[i+1] | extended_arg\n            extended_arg = (arg << 8) if op == EXTENDED_ARG else 0\n        else:\n            arg = None",
        "detail": "protobuf.Lib.dis",
        "documentation": {}
    },
    {
        "label": "aix_platform",
        "kind": 2,
        "importPath": "protobuf.Lib._aix_support",
        "description": "protobuf.Lib._aix_support",
        "peekOfCode": "def aix_platform():\n    # type: () -> str\n    \"\"\"\n    AIX filesets are identified by four decimal values: V.R.M.F.\n    V (version) and R (release) can be retreived using ``uname``\n    Since 2007, starting with AIX 5.3 TL7, the M value has been\n    included with the fileset bos.mp64 and represents the Technology\n    Level (TL) of AIX. The F (Fix) value also increases, but is not\n    relevant for comparing releases and binary compatibility.\n    For binary compatibility the so-called builddate is needed.",
        "detail": "protobuf.Lib._aix_support",
        "documentation": {}
    },
    {
        "label": "aix_buildtag",
        "kind": 2,
        "importPath": "protobuf.Lib._aix_support",
        "description": "protobuf.Lib._aix_support",
        "peekOfCode": "def aix_buildtag():\n    # type: () -> str\n    \"\"\"\n    Return the platform_tag of the system Python was built on.\n    \"\"\"\n    # AIX_BUILDDATE is defined by configure with:\n    # lslpp -Lcq bos.mp64 | awk -F:  '{ print $NF }'\n    build_date = sysconfig.get_config_var(\"AIX_BUILDDATE\")\n    try:\n        build_date = int(build_date)",
        "detail": "protobuf.Lib._aix_support",
        "documentation": {}
    },
    {
        "label": "Popen",
        "kind": 6,
        "importPath": "protobuf.Lib._bootsubprocess",
        "description": "protobuf.Lib._bootsubprocess",
        "peekOfCode": "class Popen:\n    def __init__(self, cmd, env=None):\n        self._cmd = cmd\n        self._env = env\n        self.returncode = None\n    def wait(self):\n        pid = os.fork()\n        if pid == 0:\n            # Child process\n            try:",
        "detail": "protobuf.Lib._bootsubprocess",
        "documentation": {}
    },
    {
        "label": "check_output",
        "kind": 2,
        "importPath": "protobuf.Lib._bootsubprocess",
        "description": "protobuf.Lib._bootsubprocess",
        "peekOfCode": "def check_output(cmd, **kwargs):\n    if kwargs:\n        raise NotImplementedError(repr(kwargs))\n    if not _check_cmd(cmd):\n        raise ValueError(f\"unsupported command: {cmd!r}\")\n    tmp_filename = \"check_output.tmp\"\n    if not isinstance(cmd, str):\n        cmd = \" \".join(cmd)\n    cmd = f\"{cmd} >{tmp_filename}\"\n    try:",
        "detail": "protobuf.Lib._bootsubprocess",
        "documentation": {}
    },
    {
        "label": "Hashable",
        "kind": 6,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "class Hashable(metaclass=ABCMeta):\n    __slots__ = ()\n    @abstractmethod\n    def __hash__(self):\n        return 0\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Hashable:\n            return _check_methods(C, \"__hash__\")\n        return NotImplemented",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "Awaitable",
        "kind": 6,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "class Awaitable(metaclass=ABCMeta):\n    __slots__ = ()\n    @abstractmethod\n    def __await__(self):\n        yield\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Awaitable:\n            return _check_methods(C, \"__await__\")\n        return NotImplemented",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "Coroutine",
        "kind": 6,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "class Coroutine(Awaitable):\n    __slots__ = ()\n    @abstractmethod\n    def send(self, value):\n        \"\"\"Send a value into the coroutine.\n        Return next yielded value or raise StopIteration.\n        \"\"\"\n        raise StopIteration\n    @abstractmethod\n    def throw(self, typ, val=None, tb=None):",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "AsyncIterable",
        "kind": 6,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "class AsyncIterable(metaclass=ABCMeta):\n    __slots__ = ()\n    @abstractmethod\n    def __aiter__(self):\n        return AsyncIterator()\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is AsyncIterable:\n            return _check_methods(C, \"__aiter__\")\n        return NotImplemented",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "AsyncIterator",
        "kind": 6,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "class AsyncIterator(AsyncIterable):\n    __slots__ = ()\n    @abstractmethod\n    async def __anext__(self):\n        \"\"\"Return the next item or raise StopAsyncIteration when exhausted.\"\"\"\n        raise StopAsyncIteration\n    def __aiter__(self):\n        return self\n    @classmethod\n    def __subclasshook__(cls, C):",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "AsyncGenerator",
        "kind": 6,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "class AsyncGenerator(AsyncIterator):\n    __slots__ = ()\n    async def __anext__(self):\n        \"\"\"Return the next item from the asynchronous generator.\n        When exhausted, raise StopAsyncIteration.\n        \"\"\"\n        return await self.asend(None)\n    @abstractmethod\n    async def asend(self, value):\n        \"\"\"Send a value into the asynchronous generator.",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "kind": 6,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "class Iterable(metaclass=ABCMeta):\n    __slots__ = ()\n    @abstractmethod\n    def __iter__(self):\n        while False:\n            yield None\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Iterable:\n            return _check_methods(C, \"__iter__\")",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "kind": 6,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "class Iterator(Iterable):\n    __slots__ = ()\n    @abstractmethod\n    def __next__(self):\n        'Return the next item from the iterator. When exhausted, raise StopIteration'\n        raise StopIteration\n    def __iter__(self):\n        return self\n    @classmethod\n    def __subclasshook__(cls, C):",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "Reversible",
        "kind": 6,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "class Reversible(Iterable):\n    __slots__ = ()\n    @abstractmethod\n    def __reversed__(self):\n        while False:\n            yield None\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Reversible:\n            return _check_methods(C, \"__reversed__\", \"__iter__\")",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "Generator",
        "kind": 6,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "class Generator(Iterator):\n    __slots__ = ()\n    def __next__(self):\n        \"\"\"Return the next item from the generator.\n        When exhausted, raise StopIteration.\n        \"\"\"\n        return self.send(None)\n    @abstractmethod\n    def send(self, value):\n        \"\"\"Send a value into the generator.",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "Sized",
        "kind": 6,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "class Sized(metaclass=ABCMeta):\n    __slots__ = ()\n    @abstractmethod\n    def __len__(self):\n        return 0\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Sized:\n            return _check_methods(C, \"__len__\")\n        return NotImplemented",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "Container",
        "kind": 6,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "class Container(metaclass=ABCMeta):\n    __slots__ = ()\n    @abstractmethod\n    def __contains__(self, x):\n        return False\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Container:\n            return _check_methods(C, \"__contains__\")\n        return NotImplemented",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "Collection",
        "kind": 6,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "class Collection(Sized, Iterable, Container):\n    __slots__ = ()\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Collection:\n            return _check_methods(C,  \"__len__\", \"__iter__\", \"__contains__\")\n        return NotImplemented\nclass _CallableGenericAlias(GenericAlias):\n    \"\"\" Represent `Callable[argtypes, resulttype]`.\n    This sets ``__args__`` to a tuple containing the flattened ``argtypes``",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "_CallableGenericAlias",
        "kind": 6,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "class _CallableGenericAlias(GenericAlias):\n    \"\"\" Represent `Callable[argtypes, resulttype]`.\n    This sets ``__args__`` to a tuple containing the flattened ``argtypes``\n    followed by ``resulttype``.\n    Example: ``Callable[[int, str], float]`` sets ``__args__`` to\n    ``(int, str, float)``.\n    \"\"\"\n    __slots__ = ()\n    def __new__(cls, origin, args):\n        if not (isinstance(args, tuple) and len(args) == 2):",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "kind": 6,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "class Callable(metaclass=ABCMeta):\n    __slots__ = ()\n    @abstractmethod\n    def __call__(self, *args, **kwds):\n        return False\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Callable:\n            return _check_methods(C, \"__call__\")\n        return NotImplemented",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "Set",
        "kind": 6,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "class Set(Collection):\n    \"\"\"A set is a finite, iterable container.\n    This class provides concrete generic implementations of all\n    methods except for __contains__, __iter__ and __len__.\n    To override the comparisons (presumably for speed, as the\n    semantics are fixed), redefine __le__ and __ge__,\n    then the other operations will automatically follow suit.\n    \"\"\"\n    __slots__ = ()\n    def __le__(self, other):",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "MutableSet",
        "kind": 6,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "class MutableSet(Set):\n    \"\"\"A mutable set is a finite, iterable container.\n    This class provides concrete generic implementations of all\n    methods except for __contains__, __iter__, __len__,\n    add(), and discard().\n    To override the comparisons (presumably for speed, as the\n    semantics are fixed), all you have to do is redefine __le__ and\n    then the other operations will automatically follow suit.\n    \"\"\"\n    __slots__ = ()",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "kind": 6,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "class Mapping(Collection):\n    \"\"\"A Mapping is a generic container for associating key/value\n    pairs.\n    This class provides concrete generic implementations of all\n    methods except for __getitem__, __iter__, and __len__.\n    \"\"\"\n    __slots__ = ()\n    # Tell ABCMeta.__new__ that this class should have TPFLAGS_MAPPING set.\n    __abc_tpflags__ = 1 << 6 # Py_TPFLAGS_MAPPING\n    @abstractmethod",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "MappingView",
        "kind": 6,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "class MappingView(Sized):\n    __slots__ = '_mapping',\n    def __init__(self, mapping):\n        self._mapping = mapping\n    def __len__(self):\n        return len(self._mapping)\n    def __repr__(self):\n        return '{0.__class__.__name__}({0._mapping!r})'.format(self)\n    __class_getitem__ = classmethod(GenericAlias)\nclass KeysView(MappingView, Set):",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "KeysView",
        "kind": 6,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "class KeysView(MappingView, Set):\n    __slots__ = ()\n    @classmethod\n    def _from_iterable(cls, it):\n        return set(it)\n    def __contains__(self, key):\n        return key in self._mapping\n    def __iter__(self):\n        yield from self._mapping\nKeysView.register(dict_keys)",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "ItemsView",
        "kind": 6,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "class ItemsView(MappingView, Set):\n    __slots__ = ()\n    @classmethod\n    def _from_iterable(cls, it):\n        return set(it)\n    def __contains__(self, item):\n        key, value = item\n        try:\n            v = self._mapping[key]\n        except KeyError:",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "ValuesView",
        "kind": 6,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "class ValuesView(MappingView, Collection):\n    __slots__ = ()\n    def __contains__(self, value):\n        for key in self._mapping:\n            v = self._mapping[key]\n            if v is value or v == value:\n                return True\n        return False\n    def __iter__(self):\n        for key in self._mapping:",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "MutableMapping",
        "kind": 6,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "class MutableMapping(Mapping):\n    \"\"\"A MutableMapping is a generic container for associating\n    key/value pairs.\n    This class provides concrete generic implementations of all\n    methods except for __getitem__, __setitem__, __delitem__,\n    __iter__, and __len__.\n    \"\"\"\n    __slots__ = ()\n    @abstractmethod\n    def __setitem__(self, key, value):",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "kind": 6,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "class Sequence(Reversible, Collection):\n    \"\"\"All the operations on a read-only sequence.\n    Concrete subclasses must override __new__ or __init__,\n    __getitem__, and __len__.\n    \"\"\"\n    __slots__ = ()\n    # Tell ABCMeta.__new__ that this class should have TPFLAGS_SEQUENCE set.\n    __abc_tpflags__ = 1 << 5 # Py_TPFLAGS_SEQUENCE\n    @abstractmethod\n    def __getitem__(self, index):",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "ByteString",
        "kind": 6,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "class ByteString(Sequence):\n    \"\"\"This unifies bytes and bytearray.\n    XXX Should add all their methods.\n    \"\"\"\n    __slots__ = ()\nByteString.register(bytes)\nByteString.register(bytearray)\nclass MutableSequence(Sequence):\n    \"\"\"All the operations on a read-write sequence.\n    Concrete subclasses must provide __new__ or __init__,",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "MutableSequence",
        "kind": 6,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "class MutableSequence(Sequence):\n    \"\"\"All the operations on a read-write sequence.\n    Concrete subclasses must provide __new__ or __init__,\n    __getitem__, __setitem__, __delitem__, __len__, and insert().\n    \"\"\"\n    __slots__ = ()\n    @abstractmethod\n    def __setitem__(self, index, value):\n        raise IndexError\n    @abstractmethod",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "GenericAlias",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "GenericAlias = type(list[int])\nEllipsisType = type(...)\ndef _f(): pass\nFunctionType = type(_f)\ndel _f\n__all__ = [\"Awaitable\", \"Coroutine\",\n           \"AsyncIterable\", \"AsyncIterator\", \"AsyncGenerator\",\n           \"Hashable\", \"Iterable\", \"Iterator\", \"Generator\", \"Reversible\",\n           \"Sized\", \"Container\", \"Callable\", \"Collection\",\n           \"Set\", \"MutableSet\",",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "EllipsisType",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "EllipsisType = type(...)\ndef _f(): pass\nFunctionType = type(_f)\ndel _f\n__all__ = [\"Awaitable\", \"Coroutine\",\n           \"AsyncIterable\", \"AsyncIterator\", \"AsyncGenerator\",\n           \"Hashable\", \"Iterable\", \"Iterator\", \"Generator\", \"Reversible\",\n           \"Sized\", \"Container\", \"Callable\", \"Collection\",\n           \"Set\", \"MutableSet\",\n           \"Mapping\", \"MutableMapping\",",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "FunctionType",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "FunctionType = type(_f)\ndel _f\n__all__ = [\"Awaitable\", \"Coroutine\",\n           \"AsyncIterable\", \"AsyncIterator\", \"AsyncGenerator\",\n           \"Hashable\", \"Iterable\", \"Iterator\", \"Generator\", \"Reversible\",\n           \"Sized\", \"Container\", \"Callable\", \"Collection\",\n           \"Set\", \"MutableSet\",\n           \"Mapping\", \"MutableMapping\",\n           \"MappingView\", \"KeysView\", \"ItemsView\", \"ValuesView\",\n           \"Sequence\", \"MutableSequence\",",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "__all__ = [\"Awaitable\", \"Coroutine\",\n           \"AsyncIterable\", \"AsyncIterator\", \"AsyncGenerator\",\n           \"Hashable\", \"Iterable\", \"Iterator\", \"Generator\", \"Reversible\",\n           \"Sized\", \"Container\", \"Callable\", \"Collection\",\n           \"Set\", \"MutableSet\",\n           \"Mapping\", \"MutableMapping\",\n           \"MappingView\", \"KeysView\", \"ItemsView\", \"ValuesView\",\n           \"Sequence\", \"MutableSequence\",\n           \"ByteString\",\n           ]",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "__name__",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "__name__ = \"collections.abc\"\n# Private list of types that we want to register with the various ABCs\n# so that they will pass tests like:\n#       it = iter(somebytearray)\n#       assert isinstance(it, Iterable)\n# Note:  in other implementations, these types might not be distinct\n# and they may have their own implementation specific types that\n# are not included on this list.\nbytes_iterator = type(iter(b''))\nbytearray_iterator = type(iter(bytearray()))",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "bytes_iterator",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "bytes_iterator = type(iter(b''))\nbytearray_iterator = type(iter(bytearray()))\n#callable_iterator = ???\ndict_keyiterator = type(iter({}.keys()))\ndict_valueiterator = type(iter({}.values()))\ndict_itemiterator = type(iter({}.items()))\nlist_iterator = type(iter([]))\nlist_reverseiterator = type(iter(reversed([])))\nrange_iterator = type(iter(range(0)))\nlongrange_iterator = type(iter(range(1 << 1000)))",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "bytearray_iterator",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "bytearray_iterator = type(iter(bytearray()))\n#callable_iterator = ???\ndict_keyiterator = type(iter({}.keys()))\ndict_valueiterator = type(iter({}.values()))\ndict_itemiterator = type(iter({}.items()))\nlist_iterator = type(iter([]))\nlist_reverseiterator = type(iter(reversed([])))\nrange_iterator = type(iter(range(0)))\nlongrange_iterator = type(iter(range(1 << 1000)))\nset_iterator = type(iter(set()))",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "#callable_iterator",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "#callable_iterator = ???\ndict_keyiterator = type(iter({}.keys()))\ndict_valueiterator = type(iter({}.values()))\ndict_itemiterator = type(iter({}.items()))\nlist_iterator = type(iter([]))\nlist_reverseiterator = type(iter(reversed([])))\nrange_iterator = type(iter(range(0)))\nlongrange_iterator = type(iter(range(1 << 1000)))\nset_iterator = type(iter(set()))\nstr_iterator = type(iter(\"\"))",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "dict_keyiterator",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "dict_keyiterator = type(iter({}.keys()))\ndict_valueiterator = type(iter({}.values()))\ndict_itemiterator = type(iter({}.items()))\nlist_iterator = type(iter([]))\nlist_reverseiterator = type(iter(reversed([])))\nrange_iterator = type(iter(range(0)))\nlongrange_iterator = type(iter(range(1 << 1000)))\nset_iterator = type(iter(set()))\nstr_iterator = type(iter(\"\"))\ntuple_iterator = type(iter(()))",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "dict_valueiterator",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "dict_valueiterator = type(iter({}.values()))\ndict_itemiterator = type(iter({}.items()))\nlist_iterator = type(iter([]))\nlist_reverseiterator = type(iter(reversed([])))\nrange_iterator = type(iter(range(0)))\nlongrange_iterator = type(iter(range(1 << 1000)))\nset_iterator = type(iter(set()))\nstr_iterator = type(iter(\"\"))\ntuple_iterator = type(iter(()))\nzip_iterator = type(iter(zip()))",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "dict_itemiterator",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "dict_itemiterator = type(iter({}.items()))\nlist_iterator = type(iter([]))\nlist_reverseiterator = type(iter(reversed([])))\nrange_iterator = type(iter(range(0)))\nlongrange_iterator = type(iter(range(1 << 1000)))\nset_iterator = type(iter(set()))\nstr_iterator = type(iter(\"\"))\ntuple_iterator = type(iter(()))\nzip_iterator = type(iter(zip()))\n## views ##",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "list_iterator",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "list_iterator = type(iter([]))\nlist_reverseiterator = type(iter(reversed([])))\nrange_iterator = type(iter(range(0)))\nlongrange_iterator = type(iter(range(1 << 1000)))\nset_iterator = type(iter(set()))\nstr_iterator = type(iter(\"\"))\ntuple_iterator = type(iter(()))\nzip_iterator = type(iter(zip()))\n## views ##\ndict_keys = type({}.keys())",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "list_reverseiterator",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "list_reverseiterator = type(iter(reversed([])))\nrange_iterator = type(iter(range(0)))\nlongrange_iterator = type(iter(range(1 << 1000)))\nset_iterator = type(iter(set()))\nstr_iterator = type(iter(\"\"))\ntuple_iterator = type(iter(()))\nzip_iterator = type(iter(zip()))\n## views ##\ndict_keys = type({}.keys())\ndict_values = type({}.values())",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "range_iterator",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "range_iterator = type(iter(range(0)))\nlongrange_iterator = type(iter(range(1 << 1000)))\nset_iterator = type(iter(set()))\nstr_iterator = type(iter(\"\"))\ntuple_iterator = type(iter(()))\nzip_iterator = type(iter(zip()))\n## views ##\ndict_keys = type({}.keys())\ndict_values = type({}.values())\ndict_items = type({}.items())",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "longrange_iterator",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "longrange_iterator = type(iter(range(1 << 1000)))\nset_iterator = type(iter(set()))\nstr_iterator = type(iter(\"\"))\ntuple_iterator = type(iter(()))\nzip_iterator = type(iter(zip()))\n## views ##\ndict_keys = type({}.keys())\ndict_values = type({}.values())\ndict_items = type({}.items())\n## misc ##",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "set_iterator",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "set_iterator = type(iter(set()))\nstr_iterator = type(iter(\"\"))\ntuple_iterator = type(iter(()))\nzip_iterator = type(iter(zip()))\n## views ##\ndict_keys = type({}.keys())\ndict_values = type({}.values())\ndict_items = type({}.items())\n## misc ##\nmappingproxy = type(type.__dict__)",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "str_iterator",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "str_iterator = type(iter(\"\"))\ntuple_iterator = type(iter(()))\nzip_iterator = type(iter(zip()))\n## views ##\ndict_keys = type({}.keys())\ndict_values = type({}.values())\ndict_items = type({}.items())\n## misc ##\nmappingproxy = type(type.__dict__)\ngenerator = type((lambda: (yield))())",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "tuple_iterator",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "tuple_iterator = type(iter(()))\nzip_iterator = type(iter(zip()))\n## views ##\ndict_keys = type({}.keys())\ndict_values = type({}.values())\ndict_items = type({}.items())\n## misc ##\nmappingproxy = type(type.__dict__)\ngenerator = type((lambda: (yield))())\n## coroutine ##",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "zip_iterator",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "zip_iterator = type(iter(zip()))\n## views ##\ndict_keys = type({}.keys())\ndict_values = type({}.values())\ndict_items = type({}.items())\n## misc ##\nmappingproxy = type(type.__dict__)\ngenerator = type((lambda: (yield))())\n## coroutine ##\nasync def _coro(): pass",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "dict_keys",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "dict_keys = type({}.keys())\ndict_values = type({}.values())\ndict_items = type({}.items())\n## misc ##\nmappingproxy = type(type.__dict__)\ngenerator = type((lambda: (yield))())\n## coroutine ##\nasync def _coro(): pass\n_coro = _coro()\ncoroutine = type(_coro)",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "dict_values",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "dict_values = type({}.values())\ndict_items = type({}.items())\n## misc ##\nmappingproxy = type(type.__dict__)\ngenerator = type((lambda: (yield))())\n## coroutine ##\nasync def _coro(): pass\n_coro = _coro()\ncoroutine = type(_coro)\n_coro.close()  # Prevent ResourceWarning",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "dict_items",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "dict_items = type({}.items())\n## misc ##\nmappingproxy = type(type.__dict__)\ngenerator = type((lambda: (yield))())\n## coroutine ##\nasync def _coro(): pass\n_coro = _coro()\ncoroutine = type(_coro)\n_coro.close()  # Prevent ResourceWarning\ndel _coro",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "mappingproxy",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "mappingproxy = type(type.__dict__)\ngenerator = type((lambda: (yield))())\n## coroutine ##\nasync def _coro(): pass\n_coro = _coro()\ncoroutine = type(_coro)\n_coro.close()  # Prevent ResourceWarning\ndel _coro\n## asynchronous generator ##\nasync def _ag(): yield",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "generator",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "generator = type((lambda: (yield))())\n## coroutine ##\nasync def _coro(): pass\n_coro = _coro()\ncoroutine = type(_coro)\n_coro.close()  # Prevent ResourceWarning\ndel _coro\n## asynchronous generator ##\nasync def _ag(): yield\n_ag = _ag()",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "_coro",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "_coro = _coro()\ncoroutine = type(_coro)\n_coro.close()  # Prevent ResourceWarning\ndel _coro\n## asynchronous generator ##\nasync def _ag(): yield\n_ag = _ag()\nasync_generator = type(_ag)\ndel _ag\n### ONE-TRICK PONIES ###",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "coroutine",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "coroutine = type(_coro)\n_coro.close()  # Prevent ResourceWarning\ndel _coro\n## asynchronous generator ##\nasync def _ag(): yield\n_ag = _ag()\nasync_generator = type(_ag)\ndel _ag\n### ONE-TRICK PONIES ###\ndef _check_methods(C, *methods):",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "_ag",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "_ag = _ag()\nasync_generator = type(_ag)\ndel _ag\n### ONE-TRICK PONIES ###\ndef _check_methods(C, *methods):\n    mro = C.__mro__\n    for method in methods:\n        for B in mro:\n            if method in B.__dict__:\n                if B.__dict__[method] is None:",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "async_generator",
        "kind": 5,
        "importPath": "protobuf.Lib._collections_abc",
        "description": "protobuf.Lib._collections_abc",
        "peekOfCode": "async_generator = type(_ag)\ndel _ag\n### ONE-TRICK PONIES ###\ndef _check_methods(C, *methods):\n    mro = C.__mro__\n    for method in methods:\n        for B in mro:\n            if method in B.__dict__:\n                if B.__dict__[method] is None:\n                    return NotImplemented",
        "detail": "protobuf.Lib._collections_abc",
        "documentation": {}
    },
    {
        "label": "IMPORT_MAPPING",
        "kind": 5,
        "importPath": "protobuf.Lib._compat_pickle",
        "description": "protobuf.Lib._compat_pickle",
        "peekOfCode": "IMPORT_MAPPING = {\n    '__builtin__' : 'builtins',\n    'copy_reg': 'copyreg',\n    'Queue': 'queue',\n    'SocketServer': 'socketserver',\n    'ConfigParser': 'configparser',\n    'repr': 'reprlib',\n    'tkFileDialog': 'tkinter.filedialog',\n    'tkSimpleDialog': 'tkinter.simpledialog',\n    'tkColorChooser': 'tkinter.colorchooser',",
        "detail": "protobuf.Lib._compat_pickle",
        "documentation": {}
    },
    {
        "label": "NAME_MAPPING",
        "kind": 5,
        "importPath": "protobuf.Lib._compat_pickle",
        "description": "protobuf.Lib._compat_pickle",
        "peekOfCode": "NAME_MAPPING = {\n    ('__builtin__', 'xrange'):     ('builtins', 'range'),\n    ('__builtin__', 'reduce'):     ('functools', 'reduce'),\n    ('__builtin__', 'intern'):     ('sys', 'intern'),\n    ('__builtin__', 'unichr'):     ('builtins', 'chr'),\n    ('__builtin__', 'unicode'):    ('builtins', 'str'),\n    ('__builtin__', 'long'):       ('builtins', 'int'),\n    ('itertools', 'izip'):         ('builtins', 'zip'),\n    ('itertools', 'imap'):         ('builtins', 'map'),\n    ('itertools', 'ifilter'):      ('builtins', 'filter'),",
        "detail": "protobuf.Lib._compat_pickle",
        "documentation": {}
    },
    {
        "label": "PYTHON2_EXCEPTIONS",
        "kind": 5,
        "importPath": "protobuf.Lib._compat_pickle",
        "description": "protobuf.Lib._compat_pickle",
        "peekOfCode": "PYTHON2_EXCEPTIONS = (\n    \"ArithmeticError\",\n    \"AssertionError\",\n    \"AttributeError\",\n    \"BaseException\",\n    \"BufferError\",\n    \"BytesWarning\",\n    \"DeprecationWarning\",\n    \"EOFError\",\n    \"EnvironmentError\",",
        "detail": "protobuf.Lib._compat_pickle",
        "documentation": {}
    },
    {
        "label": "MULTIPROCESSING_EXCEPTIONS",
        "kind": 5,
        "importPath": "protobuf.Lib._compat_pickle",
        "description": "protobuf.Lib._compat_pickle",
        "peekOfCode": "MULTIPROCESSING_EXCEPTIONS = (\n    'AuthenticationError',\n    'BufferTooShort',\n    'ProcessError',\n    'TimeoutError',\n)\nfor excname in MULTIPROCESSING_EXCEPTIONS:\n    NAME_MAPPING[(\"multiprocessing\", excname)] = (\"multiprocessing.context\", excname)\n# Same, but for 3.x to 2.x\nREVERSE_IMPORT_MAPPING = dict((v, k) for (k, v) in IMPORT_MAPPING.items())",
        "detail": "protobuf.Lib._compat_pickle",
        "documentation": {}
    },
    {
        "label": "REVERSE_IMPORT_MAPPING",
        "kind": 5,
        "importPath": "protobuf.Lib._compat_pickle",
        "description": "protobuf.Lib._compat_pickle",
        "peekOfCode": "REVERSE_IMPORT_MAPPING = dict((v, k) for (k, v) in IMPORT_MAPPING.items())\nassert len(REVERSE_IMPORT_MAPPING) == len(IMPORT_MAPPING)\nREVERSE_NAME_MAPPING = dict((v, k) for (k, v) in NAME_MAPPING.items())\nassert len(REVERSE_NAME_MAPPING) == len(NAME_MAPPING)\n# Non-mutual mappings.\nIMPORT_MAPPING.update({\n    'cPickle': 'pickle',\n    '_elementtree': 'xml.etree.ElementTree',\n    'FileDialog': 'tkinter.filedialog',\n    'SimpleDialog': 'tkinter.simpledialog',",
        "detail": "protobuf.Lib._compat_pickle",
        "documentation": {}
    },
    {
        "label": "REVERSE_NAME_MAPPING",
        "kind": 5,
        "importPath": "protobuf.Lib._compat_pickle",
        "description": "protobuf.Lib._compat_pickle",
        "peekOfCode": "REVERSE_NAME_MAPPING = dict((v, k) for (k, v) in NAME_MAPPING.items())\nassert len(REVERSE_NAME_MAPPING) == len(NAME_MAPPING)\n# Non-mutual mappings.\nIMPORT_MAPPING.update({\n    'cPickle': 'pickle',\n    '_elementtree': 'xml.etree.ElementTree',\n    'FileDialog': 'tkinter.filedialog',\n    'SimpleDialog': 'tkinter.simpledialog',\n    'DocXMLRPCServer': 'xmlrpc.server',\n    'SimpleHTTPServer': 'http.server',",
        "detail": "protobuf.Lib._compat_pickle",
        "documentation": {}
    },
    {
        "label": "PYTHON3_OSERROR_EXCEPTIONS",
        "kind": 5,
        "importPath": "protobuf.Lib._compat_pickle",
        "description": "protobuf.Lib._compat_pickle",
        "peekOfCode": "PYTHON3_OSERROR_EXCEPTIONS = (\n    'BrokenPipeError',\n    'ChildProcessError',\n    'ConnectionAbortedError',\n    'ConnectionError',\n    'ConnectionRefusedError',\n    'ConnectionResetError',\n    'FileExistsError',\n    'FileNotFoundError',\n    'InterruptedError',",
        "detail": "protobuf.Lib._compat_pickle",
        "documentation": {}
    },
    {
        "label": "PYTHON3_IMPORTERROR_EXCEPTIONS",
        "kind": 5,
        "importPath": "protobuf.Lib._compat_pickle",
        "description": "protobuf.Lib._compat_pickle",
        "peekOfCode": "PYTHON3_IMPORTERROR_EXCEPTIONS = (\n    'ModuleNotFoundError',\n)\nfor excname in PYTHON3_IMPORTERROR_EXCEPTIONS:\n    REVERSE_NAME_MAPPING[('builtins', excname)] = ('exceptions', 'ImportError')",
        "detail": "protobuf.Lib._compat_pickle",
        "documentation": {}
    },
    {
        "label": "BaseStream",
        "kind": 6,
        "importPath": "protobuf.Lib._compression",
        "description": "protobuf.Lib._compression",
        "peekOfCode": "class BaseStream(io.BufferedIOBase):\n    \"\"\"Mode-checking helper functions.\"\"\"\n    def _check_not_closed(self):\n        if self.closed:\n            raise ValueError(\"I/O operation on closed file\")\n    def _check_can_read(self):\n        if not self.readable():\n            raise io.UnsupportedOperation(\"File not open for reading\")\n    def _check_can_write(self):\n        if not self.writable():",
        "detail": "protobuf.Lib._compression",
        "documentation": {}
    },
    {
        "label": "DecompressReader",
        "kind": 6,
        "importPath": "protobuf.Lib._compression",
        "description": "protobuf.Lib._compression",
        "peekOfCode": "class DecompressReader(io.RawIOBase):\n    \"\"\"Adapts the decompressor API to a RawIOBase reader API\"\"\"\n    def readable(self):\n        return True\n    def __init__(self, fp, decomp_factory, trailing_error=(), **decomp_args):\n        self._fp = fp\n        self._eof = False\n        self._pos = 0  # Current offset in decompressed stream\n        # Set to size of decompressed stream once it is known, for SEEK_END\n        self._size = -1",
        "detail": "protobuf.Lib._compression",
        "documentation": {}
    },
    {
        "label": "BUFFER_SIZE",
        "kind": 5,
        "importPath": "protobuf.Lib._compression",
        "description": "protobuf.Lib._compression",
        "peekOfCode": "BUFFER_SIZE = io.DEFAULT_BUFFER_SIZE  # Compressed data read chunk size\nclass BaseStream(io.BufferedIOBase):\n    \"\"\"Mode-checking helper functions.\"\"\"\n    def _check_not_closed(self):\n        if self.closed:\n            raise ValueError(\"I/O operation on closed file\")\n    def _check_can_read(self):\n        if not self.readable():\n            raise io.UnsupportedOperation(\"File not open for reading\")\n    def _check_can_write(self):",
        "detail": "protobuf.Lib._compression",
        "documentation": {}
    },
    {
        "label": "ParserBase",
        "kind": 6,
        "importPath": "protobuf.Lib._markupbase",
        "description": "protobuf.Lib._markupbase",
        "peekOfCode": "class ParserBase:\n    \"\"\"Parser base class which provides some common support methods used\n    by the SGML/HTML and XHTML parsers.\"\"\"\n    def __init__(self):\n        if self.__class__ is ParserBase:\n            raise RuntimeError(\n                \"_markupbase.ParserBase must be subclassed\")\n    def reset(self):\n        self.lineno = 1\n        self.offset = 0",
        "detail": "protobuf.Lib._markupbase",
        "documentation": {}
    },
    {
        "label": "_declname_match",
        "kind": 5,
        "importPath": "protobuf.Lib._markupbase",
        "description": "protobuf.Lib._markupbase",
        "peekOfCode": "_declname_match = re.compile(r'[a-zA-Z][-_.a-zA-Z0-9]*\\s*').match\n_declstringlit_match = re.compile(r'(\\'[^\\']*\\'|\"[^\"]*\")\\s*').match\n_commentclose = re.compile(r'--\\s*>')\n_markedsectionclose = re.compile(r']\\s*]\\s*>')\n# An analysis of the MS-Word extensions is available at\n# http://www.planetpublish.com/xmlarena/xap/Thursday/WordtoXML.pdf\n_msmarkedsectionclose = re.compile(r']\\s*>')\ndel re\nclass ParserBase:\n    \"\"\"Parser base class which provides some common support methods used",
        "detail": "protobuf.Lib._markupbase",
        "documentation": {}
    },
    {
        "label": "_declstringlit_match",
        "kind": 5,
        "importPath": "protobuf.Lib._markupbase",
        "description": "protobuf.Lib._markupbase",
        "peekOfCode": "_declstringlit_match = re.compile(r'(\\'[^\\']*\\'|\"[^\"]*\")\\s*').match\n_commentclose = re.compile(r'--\\s*>')\n_markedsectionclose = re.compile(r']\\s*]\\s*>')\n# An analysis of the MS-Word extensions is available at\n# http://www.planetpublish.com/xmlarena/xap/Thursday/WordtoXML.pdf\n_msmarkedsectionclose = re.compile(r']\\s*>')\ndel re\nclass ParserBase:\n    \"\"\"Parser base class which provides some common support methods used\n    by the SGML/HTML and XHTML parsers.\"\"\"",
        "detail": "protobuf.Lib._markupbase",
        "documentation": {}
    },
    {
        "label": "_commentclose",
        "kind": 5,
        "importPath": "protobuf.Lib._markupbase",
        "description": "protobuf.Lib._markupbase",
        "peekOfCode": "_commentclose = re.compile(r'--\\s*>')\n_markedsectionclose = re.compile(r']\\s*]\\s*>')\n# An analysis of the MS-Word extensions is available at\n# http://www.planetpublish.com/xmlarena/xap/Thursday/WordtoXML.pdf\n_msmarkedsectionclose = re.compile(r']\\s*>')\ndel re\nclass ParserBase:\n    \"\"\"Parser base class which provides some common support methods used\n    by the SGML/HTML and XHTML parsers.\"\"\"\n    def __init__(self):",
        "detail": "protobuf.Lib._markupbase",
        "documentation": {}
    },
    {
        "label": "_markedsectionclose",
        "kind": 5,
        "importPath": "protobuf.Lib._markupbase",
        "description": "protobuf.Lib._markupbase",
        "peekOfCode": "_markedsectionclose = re.compile(r']\\s*]\\s*>')\n# An analysis of the MS-Word extensions is available at\n# http://www.planetpublish.com/xmlarena/xap/Thursday/WordtoXML.pdf\n_msmarkedsectionclose = re.compile(r']\\s*>')\ndel re\nclass ParserBase:\n    \"\"\"Parser base class which provides some common support methods used\n    by the SGML/HTML and XHTML parsers.\"\"\"\n    def __init__(self):\n        if self.__class__ is ParserBase:",
        "detail": "protobuf.Lib._markupbase",
        "documentation": {}
    },
    {
        "label": "_msmarkedsectionclose",
        "kind": 5,
        "importPath": "protobuf.Lib._markupbase",
        "description": "protobuf.Lib._markupbase",
        "peekOfCode": "_msmarkedsectionclose = re.compile(r']\\s*>')\ndel re\nclass ParserBase:\n    \"\"\"Parser base class which provides some common support methods used\n    by the SGML/HTML and XHTML parsers.\"\"\"\n    def __init__(self):\n        if self.__class__ is ParserBase:\n            raise RuntimeError(\n                \"_markupbase.ParserBase must be subclassed\")\n    def reset(self):",
        "detail": "protobuf.Lib._markupbase",
        "documentation": {}
    },
    {
        "label": "compiler_fixup",
        "kind": 2,
        "importPath": "protobuf.Lib._osx_support",
        "description": "protobuf.Lib._osx_support",
        "peekOfCode": "def compiler_fixup(compiler_so, cc_args):\n    \"\"\"\n    This function will strip '-isysroot PATH' and '-arch ARCH' from the\n    compile flags if the user has specified one them in extra_compile_flags.\n    This is needed because '-arch ARCH' adds another architecture to the\n    build, without a way to remove an architecture. Furthermore GCC will\n    barf if multiple '-isysroot' arguments are present.\n    \"\"\"\n    stripArch = stripSysroot = False\n    compiler_so = list(compiler_so)",
        "detail": "protobuf.Lib._osx_support",
        "documentation": {}
    },
    {
        "label": "customize_config_vars",
        "kind": 2,
        "importPath": "protobuf.Lib._osx_support",
        "description": "protobuf.Lib._osx_support",
        "peekOfCode": "def customize_config_vars(_config_vars):\n    \"\"\"Customize Python build configuration variables.\n    Called internally from sysconfig with a mutable mapping\n    containing name/value pairs parsed from the configured\n    makefile used to build this interpreter.  Returns\n    the mapping updated as needed to reflect the environment\n    in which the interpreter is running; in the case of\n    a Python from a binary installer, the installed\n    environment may be very different from the build\n    environment, i.e. different OS levels, different",
        "detail": "protobuf.Lib._osx_support",
        "documentation": {}
    },
    {
        "label": "customize_compiler",
        "kind": 2,
        "importPath": "protobuf.Lib._osx_support",
        "description": "protobuf.Lib._osx_support",
        "peekOfCode": "def customize_compiler(_config_vars):\n    \"\"\"Customize compiler path and configuration variables.\n    This customization is performed when the first\n    extension module build is requested\n    in distutils.sysconfig.customize_compiler.\n    \"\"\"\n    # Find a compiler to use for extension module builds\n    _find_appropriate_compiler(_config_vars)\n    # Remove ppc arch flags if not supported here\n    _remove_unsupported_archs(_config_vars)",
        "detail": "protobuf.Lib._osx_support",
        "documentation": {}
    },
    {
        "label": "get_platform_osx",
        "kind": 2,
        "importPath": "protobuf.Lib._osx_support",
        "description": "protobuf.Lib._osx_support",
        "peekOfCode": "def get_platform_osx(_config_vars, osname, release, machine):\n    \"\"\"Filter values for get_platform()\"\"\"\n    # called from get_platform() in sysconfig and distutils.util\n    #\n    # For our purposes, we'll assume that the system version from\n    # distutils' perspective is what MACOSX_DEPLOYMENT_TARGET is set\n    # to. This makes the compatibility story a bit more sane because the\n    # machine is going to compile and link as if it were\n    # MACOSX_DEPLOYMENT_TARGET.\n    macver = _config_vars.get('MACOSX_DEPLOYMENT_TARGET', '')",
        "detail": "protobuf.Lib._osx_support",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib._osx_support",
        "description": "protobuf.Lib._osx_support",
        "peekOfCode": "__all__ = [\n    'compiler_fixup',\n    'customize_config_vars',\n    'customize_compiler',\n    'get_platform_osx',\n]\n# configuration variables that may contain universal build flags,\n# like \"-arch\" or \"-isdkroot\", that may need customization for\n# the user environment\n_UNIVERSAL_CONFIG_VARS = ('CFLAGS', 'LDFLAGS', 'CPPFLAGS', 'BASECFLAGS',",
        "detail": "protobuf.Lib._osx_support",
        "documentation": {}
    },
    {
        "label": "_UNIVERSAL_CONFIG_VARS",
        "kind": 5,
        "importPath": "protobuf.Lib._osx_support",
        "description": "protobuf.Lib._osx_support",
        "peekOfCode": "_UNIVERSAL_CONFIG_VARS = ('CFLAGS', 'LDFLAGS', 'CPPFLAGS', 'BASECFLAGS',\n                            'BLDSHARED', 'LDSHARED', 'CC', 'CXX',\n                            'PY_CFLAGS', 'PY_LDFLAGS', 'PY_CPPFLAGS',\n                            'PY_CORE_CFLAGS', 'PY_CORE_LDFLAGS')\n# configuration variables that may contain compiler calls\n_COMPILER_CONFIG_VARS = ('BLDSHARED', 'LDSHARED', 'CC', 'CXX')\n# prefix added to original configuration variable names\n_INITPRE = '_OSX_SUPPORT_INITIAL_'\ndef _find_executable(executable, path=None):\n    \"\"\"Tries to find 'executable' in the directories listed in 'path'.",
        "detail": "protobuf.Lib._osx_support",
        "documentation": {}
    },
    {
        "label": "_COMPILER_CONFIG_VARS",
        "kind": 5,
        "importPath": "protobuf.Lib._osx_support",
        "description": "protobuf.Lib._osx_support",
        "peekOfCode": "_COMPILER_CONFIG_VARS = ('BLDSHARED', 'LDSHARED', 'CC', 'CXX')\n# prefix added to original configuration variable names\n_INITPRE = '_OSX_SUPPORT_INITIAL_'\ndef _find_executable(executable, path=None):\n    \"\"\"Tries to find 'executable' in the directories listed in 'path'.\n    A string listing directories separated by 'os.pathsep'; defaults to\n    os.environ['PATH'].  Returns the complete filename or None if not found.\n    \"\"\"\n    if path is None:\n        path = os.environ['PATH']",
        "detail": "protobuf.Lib._osx_support",
        "documentation": {}
    },
    {
        "label": "_INITPRE",
        "kind": 5,
        "importPath": "protobuf.Lib._osx_support",
        "description": "protobuf.Lib._osx_support",
        "peekOfCode": "_INITPRE = '_OSX_SUPPORT_INITIAL_'\ndef _find_executable(executable, path=None):\n    \"\"\"Tries to find 'executable' in the directories listed in 'path'.\n    A string listing directories separated by 'os.pathsep'; defaults to\n    os.environ['PATH'].  Returns the complete filename or None if not found.\n    \"\"\"\n    if path is None:\n        path = os.environ['PATH']\n    paths = path.split(os.pathsep)\n    base, ext = os.path.splitext(executable)",
        "detail": "protobuf.Lib._osx_support",
        "documentation": {}
    },
    {
        "label": "_SYSTEM_VERSION",
        "kind": 5,
        "importPath": "protobuf.Lib._osx_support",
        "description": "protobuf.Lib._osx_support",
        "peekOfCode": "_SYSTEM_VERSION = None\ndef _get_system_version():\n    \"\"\"Return the OS X system version as a string\"\"\"\n    # Reading this plist is a documented way to get the system\n    # version (see the documentation for the Gestalt Manager)\n    # We avoid using platform.mac_ver to avoid possible bootstrap issues during\n    # the build of Python itself (distutils is used to build standard library\n    # extensions).\n    global _SYSTEM_VERSION\n    if _SYSTEM_VERSION is None:",
        "detail": "protobuf.Lib._osx_support",
        "documentation": {}
    },
    {
        "label": "_SYSTEM_VERSION_TUPLE",
        "kind": 5,
        "importPath": "protobuf.Lib._osx_support",
        "description": "protobuf.Lib._osx_support",
        "peekOfCode": "_SYSTEM_VERSION_TUPLE = None\ndef _get_system_version_tuple():\n    \"\"\"\n    Return the macOS system version as a tuple\n    The return value is safe to use to compare\n    two version numbers.\n    \"\"\"\n    global _SYSTEM_VERSION_TUPLE\n    if _SYSTEM_VERSION_TUPLE is None:\n        osx_version = _get_system_version()",
        "detail": "protobuf.Lib._osx_support",
        "documentation": {}
    },
    {
        "label": "_cache_default_sysroot",
        "kind": 5,
        "importPath": "protobuf.Lib._osx_support",
        "description": "protobuf.Lib._osx_support",
        "peekOfCode": "_cache_default_sysroot = None\ndef _default_sysroot(cc):\n    \"\"\" Returns the root of the default SDK for this system, or '/' \"\"\"\n    global _cache_default_sysroot\n    if _cache_default_sysroot is not None:\n        return _cache_default_sysroot\n    contents = _read_output('%s -c -E -v - </dev/null' % (cc,), True)\n    in_incdirs = False\n    for line in contents.splitlines():\n        if line.startswith(\"#include <...>\"):",
        "detail": "protobuf.Lib._osx_support",
        "documentation": {}
    },
    {
        "label": "DecimalException",
        "kind": 6,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "class DecimalException(ArithmeticError):\n    \"\"\"Base exception class.\n    Used exceptions derive from this.\n    If an exception derives from another exception besides this (such as\n    Underflow (Inexact, Rounded, Subnormal) that indicates that it is only\n    called if the others are present.  This isn't actually used for\n    anything, though.\n    handle  -- Called when context._raise_error is called and the\n               trap_enabler is not set.  First argument is self, second is the\n               context.  More arguments can be given, those being after",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "Clamped",
        "kind": 6,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "class Clamped(DecimalException):\n    \"\"\"Exponent of a 0 changed to fit bounds.\n    This occurs and signals clamped if the exponent of a result has been\n    altered in order to fit the constraints of a specific concrete\n    representation.  This may occur when the exponent of a zero result would\n    be outside the bounds of a representation, or when a large normal\n    number would have an encoded exponent that cannot be represented.  In\n    this latter case, the exponent is reduced to fit and the corresponding\n    number of zero digits are appended to the coefficient (\"fold-down\").\n    \"\"\"",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "InvalidOperation",
        "kind": 6,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "class InvalidOperation(DecimalException):\n    \"\"\"An invalid operation was performed.\n    Various bad things cause this:\n    Something creates a signaling NaN\n    -INF + INF\n    0 * (+-)INF\n    (+-)INF / (+-)INF\n    x % 0\n    (+-)INF % x\n    x._rescale( non-integer )",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "ConversionSyntax",
        "kind": 6,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "class ConversionSyntax(InvalidOperation):\n    \"\"\"Trying to convert badly formed string.\n    This occurs and signals invalid-operation if a string is being\n    converted to a number and it does not conform to the numeric string\n    syntax.  The result is [0,qNaN].\n    \"\"\"\n    def handle(self, context, *args):\n        return _NaN\nclass DivisionByZero(DecimalException, ZeroDivisionError):\n    \"\"\"Division by 0.",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "DivisionByZero",
        "kind": 6,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "class DivisionByZero(DecimalException, ZeroDivisionError):\n    \"\"\"Division by 0.\n    This occurs and signals division-by-zero if division of a finite number\n    by zero was attempted (during a divide-integer or divide operation, or a\n    power operation with negative right-hand operand), and the dividend was\n    not zero.\n    The result of the operation is [sign,inf], where sign is the exclusive\n    or of the signs of the operands for divide, or is 1 for an odd power of\n    -0, for power.\n    \"\"\"",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "DivisionImpossible",
        "kind": 6,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "class DivisionImpossible(InvalidOperation):\n    \"\"\"Cannot perform the division adequately.\n    This occurs and signals invalid-operation if the integer result of a\n    divide-integer or remainder operation had too many digits (would be\n    longer than precision).  The result is [0,qNaN].\n    \"\"\"\n    def handle(self, context, *args):\n        return _NaN\nclass DivisionUndefined(InvalidOperation, ZeroDivisionError):\n    \"\"\"Undefined result of division.",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "DivisionUndefined",
        "kind": 6,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "class DivisionUndefined(InvalidOperation, ZeroDivisionError):\n    \"\"\"Undefined result of division.\n    This occurs and signals invalid-operation if division by zero was\n    attempted (during a divide-integer, divide, or remainder operation), and\n    the dividend is also zero.  The result is [0,qNaN].\n    \"\"\"\n    def handle(self, context, *args):\n        return _NaN\nclass Inexact(DecimalException):\n    \"\"\"Had to round, losing information.",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "Inexact",
        "kind": 6,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "class Inexact(DecimalException):\n    \"\"\"Had to round, losing information.\n    This occurs and signals inexact whenever the result of an operation is\n    not exact (that is, it needed to be rounded and any discarded digits\n    were non-zero), or if an overflow or underflow condition occurs.  The\n    result in all cases is unchanged.\n    The inexact signal may be tested (or trapped) to determine if a given\n    operation (or sequence of operations) was inexact.\n    \"\"\"\nclass InvalidContext(InvalidOperation):",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "InvalidContext",
        "kind": 6,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "class InvalidContext(InvalidOperation):\n    \"\"\"Invalid context.  Unknown rounding, for example.\n    This occurs and signals invalid-operation if an invalid context was\n    detected during an operation.  This can occur if contexts are not checked\n    on creation and either the precision exceeds the capability of the\n    underlying concrete representation or an unknown or unsupported rounding\n    was specified.  These aspects of the context need only be checked when\n    the values are required to be used.  The result is [0,qNaN].\n    \"\"\"\n    def handle(self, context, *args):",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "Rounded",
        "kind": 6,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "class Rounded(DecimalException):\n    \"\"\"Number got rounded (not  necessarily changed during rounding).\n    This occurs and signals rounded whenever the result of an operation is\n    rounded (that is, some zero or non-zero digits were discarded from the\n    coefficient), or if an overflow or underflow condition occurs.  The\n    result in all cases is unchanged.\n    The rounded signal may be tested (or trapped) to determine if a given\n    operation (or sequence of operations) caused a loss of precision.\n    \"\"\"\nclass Subnormal(DecimalException):",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "Subnormal",
        "kind": 6,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "class Subnormal(DecimalException):\n    \"\"\"Exponent < Emin before rounding.\n    This occurs and signals subnormal whenever the result of a conversion or\n    operation is subnormal (that is, its adjusted exponent is less than\n    Emin, before any rounding).  The result in all cases is unchanged.\n    The subnormal signal may be tested (or trapped) to determine if a given\n    or operation (or sequence of operations) yielded a subnormal result.\n    \"\"\"\nclass Overflow(Inexact, Rounded):\n    \"\"\"Numerical overflow.",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "Overflow",
        "kind": 6,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "class Overflow(Inexact, Rounded):\n    \"\"\"Numerical overflow.\n    This occurs and signals overflow if the adjusted exponent of a result\n    (from a conversion or from an operation that is not an attempt to divide\n    by zero), after rounding, would be greater than the largest value that\n    can be handled by the implementation (the value Emax).\n    The result depends on the rounding mode:\n    For round-half-up and round-half-even (and for round-half-down and\n    round-up, if implemented), the result of the operation is [sign,inf],\n    where sign is the sign of the intermediate result.  For round-down, the",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "Underflow",
        "kind": 6,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "class Underflow(Inexact, Rounded, Subnormal):\n    \"\"\"Numerical underflow with result rounded to 0.\n    This occurs and signals underflow if a result is inexact and the\n    adjusted exponent of the result would be smaller (more negative) than\n    the smallest value that can be handled by the implementation (the value\n    Emin).  That is, the result is both inexact and subnormal.\n    The result after an underflow will be a subnormal number rounded, if\n    necessary, so that its exponent is not less than Etiny.  This may result\n    in 0 with the sign of the intermediate result and an exponent of Etiny.\n    In all cases, Inexact, Rounded, and Subnormal will also be raised.",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "FloatOperation",
        "kind": 6,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "class FloatOperation(DecimalException, TypeError):\n    \"\"\"Enable stricter semantics for mixing floats and Decimals.\n    If the signal is not trapped (default), mixing floats and Decimals is\n    permitted in the Decimal() constructor, context.create_decimal() and\n    all comparison operators. Both conversion and comparisons are exact.\n    Any occurrence of a mixed operation is silently recorded by setting\n    FloatOperation in the context flags.  Explicit conversions with\n    Decimal.from_float() or context.create_decimal_from_float() do not\n    set the flag.\n    Otherwise (the signal is trapped), only equality comparisons and explicit",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "Decimal",
        "kind": 6,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "class Decimal(object):\n    \"\"\"Floating point class for decimal arithmetic.\"\"\"\n    __slots__ = ('_exp','_int','_sign', '_is_special')\n    # Generally, the value of the Decimal instance is given by\n    #  (-1)**_sign * _int * 10**_exp\n    # Special values are signified by _is_special == True\n    # We're immutable, so use __new__ not __init__\n    def __new__(cls, value=\"0\", context=None):\n        \"\"\"Create a decimal point instance.\n        >>> Decimal('3.14')              # string input",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "_ContextManager",
        "kind": 6,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "class _ContextManager(object):\n    \"\"\"Context manager class to support localcontext().\n      Sets a copy of the supplied context in __enter__() and restores\n      the previous decimal context in __exit__()\n    \"\"\"\n    def __init__(self, new_context):\n        self.new_context = new_context.copy()\n    def __enter__(self):\n        self.saved_context = getcontext()\n        setcontext(self.new_context)",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "Context",
        "kind": 6,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "class Context(object):\n    \"\"\"Contains the context for a Decimal instance.\n    Contains:\n    prec - precision (for use in rounding, division, square roots..)\n    rounding - rounding type (how you round)\n    traps - If traps[exception] = 1, then the exception is\n                    raised when it is caused.  Otherwise, a value is\n                    substituted in.\n    flags  - When an exception is caused, flags[exception] is set.\n             (Whether or not the trap_enabler is set)",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "_WorkRep",
        "kind": 6,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "class _WorkRep(object):\n    __slots__ = ('sign','int','exp')\n    # sign: 0 or 1\n    # int:  int\n    # exp:  None, int, or string\n    def __init__(self, value=None):\n        if value is None:\n            self.sign = None\n            self.int = 0\n            self.exp = None",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "_Log10Memoize",
        "kind": 6,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "class _Log10Memoize(object):\n    \"\"\"Class to compute, store, and allow retrieval of, digits of the\n    constant log(10) = 2.302585....  This constant is needed by\n    Decimal.ln, Decimal.log10, Decimal.exp and Decimal.__pow__.\"\"\"\n    def __init__(self):\n        self.digits = \"23025850929940456840179914546843642076011014886\"\n    def getdigits(self, p):\n        \"\"\"Given an integer p >= 0, return floor(10**p)*log(10).\n        For example, self.getdigits(3) returns 2302.\n        \"\"\"",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "getcontext",
        "kind": 2,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "def getcontext():\n    \"\"\"Returns this thread's context.\n    If this thread does not yet have a context, returns\n    a new context and sets this thread's context.\n    New contexts are copies of DefaultContext.\n    \"\"\"\n    try:\n        return _current_context_var.get()\n    except LookupError:\n        context = Context()",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "setcontext",
        "kind": 2,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "def setcontext(context):\n    \"\"\"Set this thread's context to context.\"\"\"\n    if context in (DefaultContext, BasicContext, ExtendedContext):\n        context = context.copy()\n        context.clear_flags()\n    _current_context_var.set(context)\ndel contextvars        # Don't contaminate the namespace\ndef localcontext(ctx=None):\n    \"\"\"Return a context manager for a copy of the supplied context\n    Uses a copy of the current context if no context is specified",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "localcontext",
        "kind": 2,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "def localcontext(ctx=None):\n    \"\"\"Return a context manager for a copy of the supplied context\n    Uses a copy of the current context if no context is specified\n    The returned context manager creates a local decimal context\n    in a with statement:\n        def sin(x):\n             with localcontext() as ctx:\n                 ctx.prec += 2\n                 # Rest of sin calculation algorithm\n                 # uses a precision 2 greater than normal",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "__all__ = [\n    # Two major classes\n    'Decimal', 'Context',\n    # Named tuple representation\n    'DecimalTuple',\n    # Contexts\n    'DefaultContext', 'BasicContext', 'ExtendedContext',\n    # Exceptions\n    'DecimalException', 'Clamped', 'InvalidOperation', 'DivisionByZero',\n    'Inexact', 'Rounded', 'Subnormal', 'Overflow', 'Underflow',",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "__xname__",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "__xname__ = __name__    # sys.modules lookup (--without-threads)\n__name__ = 'decimal'    # For pickling\n__version__ = '1.70'    # Highest version of the spec this complies with\n                        # See http://speleotrove.com/decimal/\n__libmpdec_version__ = \"2.4.2\" # compatible libmpdec version\nimport math as _math\nimport numbers as _numbers\nimport sys\ntry:\n    from collections import namedtuple as _namedtuple",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "__name__",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "__name__ = 'decimal'    # For pickling\n__version__ = '1.70'    # Highest version of the spec this complies with\n                        # See http://speleotrove.com/decimal/\n__libmpdec_version__ = \"2.4.2\" # compatible libmpdec version\nimport math as _math\nimport numbers as _numbers\nimport sys\ntry:\n    from collections import namedtuple as _namedtuple\n    DecimalTuple = _namedtuple('DecimalTuple', 'sign digits exponent')",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "__version__ = '1.70'    # Highest version of the spec this complies with\n                        # See http://speleotrove.com/decimal/\n__libmpdec_version__ = \"2.4.2\" # compatible libmpdec version\nimport math as _math\nimport numbers as _numbers\nimport sys\ntry:\n    from collections import namedtuple as _namedtuple\n    DecimalTuple = _namedtuple('DecimalTuple', 'sign digits exponent')\nexcept ImportError:",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "__libmpdec_version__",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "__libmpdec_version__ = \"2.4.2\" # compatible libmpdec version\nimport math as _math\nimport numbers as _numbers\nimport sys\ntry:\n    from collections import namedtuple as _namedtuple\n    DecimalTuple = _namedtuple('DecimalTuple', 'sign digits exponent')\nexcept ImportError:\n    DecimalTuple = lambda *args: args\n# Rounding",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "ROUND_DOWN",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "ROUND_DOWN = 'ROUND_DOWN'\nROUND_HALF_UP = 'ROUND_HALF_UP'\nROUND_HALF_EVEN = 'ROUND_HALF_EVEN'\nROUND_CEILING = 'ROUND_CEILING'\nROUND_FLOOR = 'ROUND_FLOOR'\nROUND_UP = 'ROUND_UP'\nROUND_HALF_DOWN = 'ROUND_HALF_DOWN'\nROUND_05UP = 'ROUND_05UP'\n# Compatibility with the C version\nHAVE_THREADS = True",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "ROUND_HALF_UP",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "ROUND_HALF_UP = 'ROUND_HALF_UP'\nROUND_HALF_EVEN = 'ROUND_HALF_EVEN'\nROUND_CEILING = 'ROUND_CEILING'\nROUND_FLOOR = 'ROUND_FLOOR'\nROUND_UP = 'ROUND_UP'\nROUND_HALF_DOWN = 'ROUND_HALF_DOWN'\nROUND_05UP = 'ROUND_05UP'\n# Compatibility with the C version\nHAVE_THREADS = True\nHAVE_CONTEXTVAR = True",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "ROUND_HALF_EVEN",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "ROUND_HALF_EVEN = 'ROUND_HALF_EVEN'\nROUND_CEILING = 'ROUND_CEILING'\nROUND_FLOOR = 'ROUND_FLOOR'\nROUND_UP = 'ROUND_UP'\nROUND_HALF_DOWN = 'ROUND_HALF_DOWN'\nROUND_05UP = 'ROUND_05UP'\n# Compatibility with the C version\nHAVE_THREADS = True\nHAVE_CONTEXTVAR = True\nif sys.maxsize == 2**63-1:",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "ROUND_CEILING",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "ROUND_CEILING = 'ROUND_CEILING'\nROUND_FLOOR = 'ROUND_FLOOR'\nROUND_UP = 'ROUND_UP'\nROUND_HALF_DOWN = 'ROUND_HALF_DOWN'\nROUND_05UP = 'ROUND_05UP'\n# Compatibility with the C version\nHAVE_THREADS = True\nHAVE_CONTEXTVAR = True\nif sys.maxsize == 2**63-1:\n    MAX_PREC = 999999999999999999",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "ROUND_FLOOR",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "ROUND_FLOOR = 'ROUND_FLOOR'\nROUND_UP = 'ROUND_UP'\nROUND_HALF_DOWN = 'ROUND_HALF_DOWN'\nROUND_05UP = 'ROUND_05UP'\n# Compatibility with the C version\nHAVE_THREADS = True\nHAVE_CONTEXTVAR = True\nif sys.maxsize == 2**63-1:\n    MAX_PREC = 999999999999999999\n    MAX_EMAX = 999999999999999999",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "ROUND_UP",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "ROUND_UP = 'ROUND_UP'\nROUND_HALF_DOWN = 'ROUND_HALF_DOWN'\nROUND_05UP = 'ROUND_05UP'\n# Compatibility with the C version\nHAVE_THREADS = True\nHAVE_CONTEXTVAR = True\nif sys.maxsize == 2**63-1:\n    MAX_PREC = 999999999999999999\n    MAX_EMAX = 999999999999999999\n    MIN_EMIN = -999999999999999999",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "ROUND_HALF_DOWN",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "ROUND_HALF_DOWN = 'ROUND_HALF_DOWN'\nROUND_05UP = 'ROUND_05UP'\n# Compatibility with the C version\nHAVE_THREADS = True\nHAVE_CONTEXTVAR = True\nif sys.maxsize == 2**63-1:\n    MAX_PREC = 999999999999999999\n    MAX_EMAX = 999999999999999999\n    MIN_EMIN = -999999999999999999\nelse:",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "ROUND_05UP",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "ROUND_05UP = 'ROUND_05UP'\n# Compatibility with the C version\nHAVE_THREADS = True\nHAVE_CONTEXTVAR = True\nif sys.maxsize == 2**63-1:\n    MAX_PREC = 999999999999999999\n    MAX_EMAX = 999999999999999999\n    MIN_EMIN = -999999999999999999\nelse:\n    MAX_PREC = 425000000",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "HAVE_THREADS",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "HAVE_THREADS = True\nHAVE_CONTEXTVAR = True\nif sys.maxsize == 2**63-1:\n    MAX_PREC = 999999999999999999\n    MAX_EMAX = 999999999999999999\n    MIN_EMIN = -999999999999999999\nelse:\n    MAX_PREC = 425000000\n    MAX_EMAX = 425000000\n    MIN_EMIN = -425000000",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "HAVE_CONTEXTVAR",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "HAVE_CONTEXTVAR = True\nif sys.maxsize == 2**63-1:\n    MAX_PREC = 999999999999999999\n    MAX_EMAX = 999999999999999999\n    MIN_EMIN = -999999999999999999\nelse:\n    MAX_PREC = 425000000\n    MAX_EMAX = 425000000\n    MIN_EMIN = -425000000\nMIN_ETINY = MIN_EMIN - (MAX_PREC-1)",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "MIN_ETINY",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "MIN_ETINY = MIN_EMIN - (MAX_PREC-1)\n# Errors\nclass DecimalException(ArithmeticError):\n    \"\"\"Base exception class.\n    Used exceptions derive from this.\n    If an exception derives from another exception besides this (such as\n    Underflow (Inexact, Rounded, Subnormal) that indicates that it is only\n    called if the others are present.  This isn't actually used for\n    anything, though.\n    handle  -- Called when context._raise_error is called and the",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "_signals",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "_signals = [Clamped, DivisionByZero, Inexact, Overflow, Rounded,\n            Underflow, InvalidOperation, Subnormal, FloatOperation]\n# Map conditions (per the spec) to signals\n_condition_map = {ConversionSyntax:InvalidOperation,\n                  DivisionImpossible:InvalidOperation,\n                  DivisionUndefined:InvalidOperation,\n                  InvalidContext:InvalidOperation}\n# Valid rounding modes\n_rounding_modes = (ROUND_DOWN, ROUND_HALF_UP, ROUND_HALF_EVEN, ROUND_CEILING,\n                   ROUND_FLOOR, ROUND_UP, ROUND_HALF_DOWN, ROUND_05UP)",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "_condition_map",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "_condition_map = {ConversionSyntax:InvalidOperation,\n                  DivisionImpossible:InvalidOperation,\n                  DivisionUndefined:InvalidOperation,\n                  InvalidContext:InvalidOperation}\n# Valid rounding modes\n_rounding_modes = (ROUND_DOWN, ROUND_HALF_UP, ROUND_HALF_EVEN, ROUND_CEILING,\n                   ROUND_FLOOR, ROUND_UP, ROUND_HALF_DOWN, ROUND_05UP)\n##### Context Functions ##################################################\n# The getcontext() and setcontext() function manage access to a thread-local\n# current context.",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "_rounding_modes",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "_rounding_modes = (ROUND_DOWN, ROUND_HALF_UP, ROUND_HALF_EVEN, ROUND_CEILING,\n                   ROUND_FLOOR, ROUND_UP, ROUND_HALF_DOWN, ROUND_05UP)\n##### Context Functions ##################################################\n# The getcontext() and setcontext() function manage access to a thread-local\n# current context.\nimport contextvars\n_current_context_var = contextvars.ContextVar('decimal_context')\ndef getcontext():\n    \"\"\"Returns this thread's context.\n    If this thread does not yet have a context, returns",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "_current_context_var",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "_current_context_var = contextvars.ContextVar('decimal_context')\ndef getcontext():\n    \"\"\"Returns this thread's context.\n    If this thread does not yet have a context, returns\n    a new context and sets this thread's context.\n    New contexts are copies of DefaultContext.\n    \"\"\"\n    try:\n        return _current_context_var.get()\n    except LookupError:",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "_nbits",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "_nbits = int.bit_length\ndef _decimal_lshift_exact(n, e):\n    \"\"\" Given integers n and e, return n * 10**e if it's an integer, else None.\n    The computation is designed to avoid computing large powers of 10\n    unnecessarily.\n    >>> _decimal_lshift_exact(3, 4)\n    30000\n    >>> _decimal_lshift_exact(300, -999999999)  # returns None\n    \"\"\"\n    if n == 0:",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "_log10_digits",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "_log10_digits = _Log10Memoize().getdigits\ndef _iexp(x, M, L=8):\n    \"\"\"Given integers x and M, M > 0, such that x/M is small in absolute\n    value, compute an integer approximation to M*exp(x/M).  For 0 <=\n    x/M <= 2.4, the absolute error in the result is bounded by 60 (and\n    is usually much smaller).\"\"\"\n    # Algorithm: to compute exp(z) for a real number z, first divide z\n    # by a suitable power R of 2 so that |z/2**R| < 2**-L.  Then\n    # compute expm1(z/2**R) = exp(z/2**R) - 1 using the usual Taylor\n    # series",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "DefaultContext",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "DefaultContext = Context(\n        prec=28, rounding=ROUND_HALF_EVEN,\n        traps=[DivisionByZero, Overflow, InvalidOperation],\n        flags=[],\n        Emax=999999,\n        Emin=-999999,\n        capitals=1,\n        clamp=0\n)\n# Pre-made alternate contexts offered by the specification",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "BasicContext",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "BasicContext = Context(\n        prec=9, rounding=ROUND_HALF_UP,\n        traps=[DivisionByZero, Overflow, InvalidOperation, Clamped, Underflow],\n        flags=[],\n)\nExtendedContext = Context(\n        prec=9, rounding=ROUND_HALF_EVEN,\n        traps=[],\n        flags=[],\n)",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "ExtendedContext",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "ExtendedContext = Context(\n        prec=9, rounding=ROUND_HALF_EVEN,\n        traps=[],\n        flags=[],\n)\n##### crud for parsing strings #############################################\n#\n# Regular expression used for parsing numeric strings.  Additional\n# comments:\n#",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "_parser",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "_parser = re.compile(r\"\"\"        # A numeric string consists of:\n#    \\s*\n    (?P<sign>[-+])?              # an optional sign, followed by either...\n    (\n        (?=\\d|\\.\\d)              # ...a number (with at least one digit)\n        (?P<int>\\d*)             # having a (possibly empty) integer part\n        (\\.(?P<frac>\\d*))?       # followed by an optional fractional part\n        (E(?P<exp>[-+]?\\d+))?    # followed by an optional exponent, or...\n    |\n        Inf(inity)?              # ...an infinity, or...",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "_all_zeros",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "_all_zeros = re.compile('0*$').match\n_exact_half = re.compile('50*$').match\n##### PEP3101 support functions ##############################################\n# The functions in this section have little to do with the Decimal\n# class, and could potentially be reused or adapted for other pure\n# Python numeric classes that want to implement __format__\n#\n# A format specifier for Decimal looks like:\n#\n#   [[fill]align][sign][#][0][minimumwidth][,][.precision][type]",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "_exact_half",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "_exact_half = re.compile('50*$').match\n##### PEP3101 support functions ##############################################\n# The functions in this section have little to do with the Decimal\n# class, and could potentially be reused or adapted for other pure\n# Python numeric classes that want to implement __format__\n#\n# A format specifier for Decimal looks like:\n#\n#   [[fill]align][sign][#][0][minimumwidth][,][.precision][type]\n_parse_format_specifier_regex = re.compile(r\"\"\"\\A",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "_parse_format_specifier_regex",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "_parse_format_specifier_regex = re.compile(r\"\"\"\\A\n(?:\n   (?P<fill>.)?\n   (?P<align>[<>=^])\n)?\n(?P<sign>[-+ ])?\n(?P<alt>\\#)?\n(?P<zeropad>0)?\n(?P<minimumwidth>(?!0)\\d+)?\n(?P<thousands_sep>,)?",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "_Infinity",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "_Infinity = Decimal('Inf')\n_NegativeInfinity = Decimal('-Inf')\n_NaN = Decimal('NaN')\n_Zero = Decimal(0)\n_One = Decimal(1)\n_NegativeOne = Decimal(-1)\n# _SignedInfinity[sign] is infinity w/ that sign\n_SignedInfinity = (_Infinity, _NegativeInfinity)\n# Constants related to the hash implementation;  hash(x) is based\n# on the reduction of x modulo _PyHASH_MODULUS",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "_NegativeInfinity",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "_NegativeInfinity = Decimal('-Inf')\n_NaN = Decimal('NaN')\n_Zero = Decimal(0)\n_One = Decimal(1)\n_NegativeOne = Decimal(-1)\n# _SignedInfinity[sign] is infinity w/ that sign\n_SignedInfinity = (_Infinity, _NegativeInfinity)\n# Constants related to the hash implementation;  hash(x) is based\n# on the reduction of x modulo _PyHASH_MODULUS\n_PyHASH_MODULUS = sys.hash_info.modulus",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "_NaN",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "_NaN = Decimal('NaN')\n_Zero = Decimal(0)\n_One = Decimal(1)\n_NegativeOne = Decimal(-1)\n# _SignedInfinity[sign] is infinity w/ that sign\n_SignedInfinity = (_Infinity, _NegativeInfinity)\n# Constants related to the hash implementation;  hash(x) is based\n# on the reduction of x modulo _PyHASH_MODULUS\n_PyHASH_MODULUS = sys.hash_info.modulus\n# hash values to use for positive and negative infinities, and nans",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "_Zero",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "_Zero = Decimal(0)\n_One = Decimal(1)\n_NegativeOne = Decimal(-1)\n# _SignedInfinity[sign] is infinity w/ that sign\n_SignedInfinity = (_Infinity, _NegativeInfinity)\n# Constants related to the hash implementation;  hash(x) is based\n# on the reduction of x modulo _PyHASH_MODULUS\n_PyHASH_MODULUS = sys.hash_info.modulus\n# hash values to use for positive and negative infinities, and nans\n_PyHASH_INF = sys.hash_info.inf",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "_One",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "_One = Decimal(1)\n_NegativeOne = Decimal(-1)\n# _SignedInfinity[sign] is infinity w/ that sign\n_SignedInfinity = (_Infinity, _NegativeInfinity)\n# Constants related to the hash implementation;  hash(x) is based\n# on the reduction of x modulo _PyHASH_MODULUS\n_PyHASH_MODULUS = sys.hash_info.modulus\n# hash values to use for positive and negative infinities, and nans\n_PyHASH_INF = sys.hash_info.inf\n_PyHASH_NAN = sys.hash_info.nan",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "_NegativeOne",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "_NegativeOne = Decimal(-1)\n# _SignedInfinity[sign] is infinity w/ that sign\n_SignedInfinity = (_Infinity, _NegativeInfinity)\n# Constants related to the hash implementation;  hash(x) is based\n# on the reduction of x modulo _PyHASH_MODULUS\n_PyHASH_MODULUS = sys.hash_info.modulus\n# hash values to use for positive and negative infinities, and nans\n_PyHASH_INF = sys.hash_info.inf\n_PyHASH_NAN = sys.hash_info.nan\n# _PyHASH_10INV is the inverse of 10 modulo the prime _PyHASH_MODULUS",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "_SignedInfinity",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "_SignedInfinity = (_Infinity, _NegativeInfinity)\n# Constants related to the hash implementation;  hash(x) is based\n# on the reduction of x modulo _PyHASH_MODULUS\n_PyHASH_MODULUS = sys.hash_info.modulus\n# hash values to use for positive and negative infinities, and nans\n_PyHASH_INF = sys.hash_info.inf\n_PyHASH_NAN = sys.hash_info.nan\n# _PyHASH_10INV is the inverse of 10 modulo the prime _PyHASH_MODULUS\n_PyHASH_10INV = pow(10, _PyHASH_MODULUS - 2, _PyHASH_MODULUS)\ndel sys",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "_PyHASH_MODULUS",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "_PyHASH_MODULUS = sys.hash_info.modulus\n# hash values to use for positive and negative infinities, and nans\n_PyHASH_INF = sys.hash_info.inf\n_PyHASH_NAN = sys.hash_info.nan\n# _PyHASH_10INV is the inverse of 10 modulo the prime _PyHASH_MODULUS\n_PyHASH_10INV = pow(10, _PyHASH_MODULUS - 2, _PyHASH_MODULUS)\ndel sys",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "_PyHASH_INF",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "_PyHASH_INF = sys.hash_info.inf\n_PyHASH_NAN = sys.hash_info.nan\n# _PyHASH_10INV is the inverse of 10 modulo the prime _PyHASH_MODULUS\n_PyHASH_10INV = pow(10, _PyHASH_MODULUS - 2, _PyHASH_MODULUS)\ndel sys",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "_PyHASH_NAN",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "_PyHASH_NAN = sys.hash_info.nan\n# _PyHASH_10INV is the inverse of 10 modulo the prime _PyHASH_MODULUS\n_PyHASH_10INV = pow(10, _PyHASH_MODULUS - 2, _PyHASH_MODULUS)\ndel sys",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "_PyHASH_10INV",
        "kind": 5,
        "importPath": "protobuf.Lib._pydecimal",
        "description": "protobuf.Lib._pydecimal",
        "peekOfCode": "_PyHASH_10INV = pow(10, _PyHASH_MODULUS - 2, _PyHASH_MODULUS)\ndel sys",
        "detail": "protobuf.Lib._pydecimal",
        "documentation": {}
    },
    {
        "label": "IOBase",
        "kind": 6,
        "importPath": "protobuf.Lib._pyio",
        "description": "protobuf.Lib._pyio",
        "peekOfCode": "class IOBase(metaclass=abc.ABCMeta):\n    \"\"\"The abstract base class for all I/O classes.\n    This class provides dummy implementations for many methods that\n    derived classes can override selectively; the default implementations\n    represent a file that cannot be read, written or seeked.\n    Even though IOBase does not declare read or write because\n    their signatures will vary, implementations and clients should\n    consider those methods part of the interface. Also, implementations\n    may raise UnsupportedOperation when operations they do not support are\n    called.",
        "detail": "protobuf.Lib._pyio",
        "documentation": {}
    },
    {
        "label": "RawIOBase",
        "kind": 6,
        "importPath": "protobuf.Lib._pyio",
        "description": "protobuf.Lib._pyio",
        "peekOfCode": "class RawIOBase(IOBase):\n    \"\"\"Base class for raw binary I/O.\"\"\"\n    # The read() method is implemented by calling readinto(); derived\n    # classes that want to support read() only need to implement\n    # readinto() as a primitive operation.  In general, readinto() can be\n    # more efficient than read().\n    # (It would be tempting to also provide an implementation of\n    # readinto() in terms of read(), in case the latter is a more suitable\n    # primitive operation, but that would lead to nasty recursion in case\n    # a subclass doesn't implement either.)",
        "detail": "protobuf.Lib._pyio",
        "documentation": {}
    },
    {
        "label": "BufferedIOBase",
        "kind": 6,
        "importPath": "protobuf.Lib._pyio",
        "description": "protobuf.Lib._pyio",
        "peekOfCode": "class BufferedIOBase(IOBase):\n    \"\"\"Base class for buffered IO objects.\n    The main difference with RawIOBase is that the read() method\n    supports omitting the size argument, and does not have a default\n    implementation that defers to readinto().\n    In addition, read(), readinto() and write() may raise\n    BlockingIOError if the underlying raw stream is in non-blocking\n    mode and not ready; unlike their raw counterparts, they will never\n    return None.\n    A typical implementation should not inherit from a RawIOBase",
        "detail": "protobuf.Lib._pyio",
        "documentation": {}
    },
    {
        "label": "_BufferedIOMixin",
        "kind": 6,
        "importPath": "protobuf.Lib._pyio",
        "description": "protobuf.Lib._pyio",
        "peekOfCode": "class _BufferedIOMixin(BufferedIOBase):\n    \"\"\"A mixin implementation of BufferedIOBase with an underlying raw stream.\n    This passes most requests on to the underlying raw stream.  It\n    does *not* provide implementations of read(), readinto() or\n    write().\n    \"\"\"\n    def __init__(self, raw):\n        self._raw = raw\n    ### Positioning ###\n    def seek(self, pos, whence=0):",
        "detail": "protobuf.Lib._pyio",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "kind": 6,
        "importPath": "protobuf.Lib._pyio",
        "description": "protobuf.Lib._pyio",
        "peekOfCode": "class BytesIO(BufferedIOBase):\n    \"\"\"Buffered I/O implementation using an in-memory bytes buffer.\"\"\"\n    # Initialize _buffer as soon as possible since it's used by __del__()\n    # which calls close()\n    _buffer = None\n    def __init__(self, initial_bytes=None):\n        buf = bytearray()\n        if initial_bytes is not None:\n            buf += initial_bytes\n        self._buffer = buf",
        "detail": "protobuf.Lib._pyio",
        "documentation": {}
    },
    {
        "label": "BufferedReader",
        "kind": 6,
        "importPath": "protobuf.Lib._pyio",
        "description": "protobuf.Lib._pyio",
        "peekOfCode": "class BufferedReader(_BufferedIOMixin):\n    \"\"\"BufferedReader(raw[, buffer_size])\n    A buffer for a readable, sequential BaseRawIO object.\n    The constructor creates a BufferedReader for the given readable raw\n    stream and buffer_size. If buffer_size is omitted, DEFAULT_BUFFER_SIZE\n    is used.\n    \"\"\"\n    def __init__(self, raw, buffer_size=DEFAULT_BUFFER_SIZE):\n        \"\"\"Create a new buffered reader using the given readable raw IO object.\n        \"\"\"",
        "detail": "protobuf.Lib._pyio",
        "documentation": {}
    },
    {
        "label": "BufferedWriter",
        "kind": 6,
        "importPath": "protobuf.Lib._pyio",
        "description": "protobuf.Lib._pyio",
        "peekOfCode": "class BufferedWriter(_BufferedIOMixin):\n    \"\"\"A buffer for a writeable sequential RawIO object.\n    The constructor creates a BufferedWriter for the given writeable raw\n    stream. If the buffer_size is not given, it defaults to\n    DEFAULT_BUFFER_SIZE.\n    \"\"\"\n    def __init__(self, raw, buffer_size=DEFAULT_BUFFER_SIZE):\n        if not raw.writable():\n            raise OSError('\"raw\" argument must be writable.')\n        _BufferedIOMixin.__init__(self, raw)",
        "detail": "protobuf.Lib._pyio",
        "documentation": {}
    },
    {
        "label": "BufferedRWPair",
        "kind": 6,
        "importPath": "protobuf.Lib._pyio",
        "description": "protobuf.Lib._pyio",
        "peekOfCode": "class BufferedRWPair(BufferedIOBase):\n    \"\"\"A buffered reader and writer object together.\n    A buffered reader object and buffered writer object put together to\n    form a sequential IO object that can read and write. This is typically\n    used with a socket or two-way pipe.\n    reader and writer are RawIOBase objects that are readable and\n    writeable respectively. If the buffer_size is omitted it defaults to\n    DEFAULT_BUFFER_SIZE.\n    \"\"\"\n    # XXX The usefulness of this (compared to having two separate IO",
        "detail": "protobuf.Lib._pyio",
        "documentation": {}
    },
    {
        "label": "BufferedRandom",
        "kind": 6,
        "importPath": "protobuf.Lib._pyio",
        "description": "protobuf.Lib._pyio",
        "peekOfCode": "class BufferedRandom(BufferedWriter, BufferedReader):\n    \"\"\"A buffered interface to random access streams.\n    The constructor creates a reader and writer for a seekable stream,\n    raw, given in the first argument. If the buffer_size is omitted it\n    defaults to DEFAULT_BUFFER_SIZE.\n    \"\"\"\n    def __init__(self, raw, buffer_size=DEFAULT_BUFFER_SIZE):\n        raw._checkSeekable()\n        BufferedReader.__init__(self, raw, buffer_size)\n        BufferedWriter.__init__(self, raw, buffer_size)",
        "detail": "protobuf.Lib._pyio",
        "documentation": {}
    },
    {
        "label": "FileIO",
        "kind": 6,
        "importPath": "protobuf.Lib._pyio",
        "description": "protobuf.Lib._pyio",
        "peekOfCode": "class FileIO(RawIOBase):\n    _fd = -1\n    _created = False\n    _readable = False\n    _writable = False\n    _appending = False\n    _seekable = None\n    _closefd = True\n    def __init__(self, file, mode='r', closefd=True, opener=None):\n        \"\"\"Open a file.  The mode can be 'r' (default), 'w', 'x' or 'a' for reading,",
        "detail": "protobuf.Lib._pyio",
        "documentation": {}
    },
    {
        "label": "TextIOBase",
        "kind": 6,
        "importPath": "protobuf.Lib._pyio",
        "description": "protobuf.Lib._pyio",
        "peekOfCode": "class TextIOBase(IOBase):\n    \"\"\"Base class for text I/O.\n    This class provides a character and line based interface to stream\n    I/O.\n    \"\"\"\n    def read(self, size=-1):\n        \"\"\"Read at most size characters from stream, where size is an int.\n        Read from underlying buffer until we have size characters or we hit EOF.\n        If size is negative or omitted, read until EOF.\n        Returns a string.",
        "detail": "protobuf.Lib._pyio",
        "documentation": {}
    },
    {
        "label": "IncrementalNewlineDecoder",
        "kind": 6,
        "importPath": "protobuf.Lib._pyio",
        "description": "protobuf.Lib._pyio",
        "peekOfCode": "class IncrementalNewlineDecoder(codecs.IncrementalDecoder):\n    r\"\"\"Codec used when reading a file in universal newlines mode.  It wraps\n    another incremental decoder, translating \\r\\n and \\r into \\n.  It also\n    records the types of newlines encountered.  When used with\n    translate=False, it ensures that the newline sequence is returned in\n    one piece.\n    \"\"\"\n    def __init__(self, decoder, translate, errors='strict'):\n        codecs.IncrementalDecoder.__init__(self, errors=errors)\n        self.translate = translate",
        "detail": "protobuf.Lib._pyio",
        "documentation": {}
    },
    {
        "label": "TextIOWrapper",
        "kind": 6,
        "importPath": "protobuf.Lib._pyio",
        "description": "protobuf.Lib._pyio",
        "peekOfCode": "class TextIOWrapper(TextIOBase):\n    r\"\"\"Character and line based layer over a BufferedIOBase object, buffer.\n    encoding gives the name of the encoding that the stream will be\n    decoded or encoded with. It defaults to locale.getpreferredencoding(False).\n    errors determines the strictness of encoding and decoding (see the\n    codecs.register) and defaults to \"strict\".\n    newline can be None, '', '\\n', '\\r', or '\\r\\n'.  It controls the\n    handling of line endings. If it is None, universal newlines is\n    enabled.  With this enabled, on input, the lines endings '\\n', '\\r',\n    or '\\r\\n' are translated to '\\n' before being returned to the",
        "detail": "protobuf.Lib._pyio",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "kind": 6,
        "importPath": "protobuf.Lib._pyio",
        "description": "protobuf.Lib._pyio",
        "peekOfCode": "class StringIO(TextIOWrapper):\n    \"\"\"Text I/O implementation using an in-memory buffer.\n    The initial_value argument sets the value of object.  The newline\n    argument is like the one of TextIOWrapper's constructor.\n    \"\"\"\n    def __init__(self, initial_value=\"\", newline=\"\\n\"):\n        super(StringIO, self).__init__(BytesIO(),\n                                       encoding=\"utf-8\",\n                                       errors=\"surrogatepass\",\n                                       newline=newline)",
        "detail": "protobuf.Lib._pyio",
        "documentation": {}
    },
    {
        "label": "text_encoding",
        "kind": 2,
        "importPath": "protobuf.Lib._pyio",
        "description": "protobuf.Lib._pyio",
        "peekOfCode": "def text_encoding(encoding, stacklevel=2):\n    \"\"\"\n    A helper function to choose the text encoding.\n    When encoding is not None, just return it.\n    Otherwise, return the default text encoding (i.e. \"locale\").\n    This function emits an EncodingWarning if *encoding* is None and\n    sys.flags.warn_default_encoding is true.\n    This can be used in APIs with an encoding=None parameter\n    that pass it to TextIOWrapper or open.\n    However, please consider using encoding=\"utf-8\" for new APIs.",
        "detail": "protobuf.Lib._pyio",
        "documentation": {}
    },
    {
        "label": "open",
        "kind": 2,
        "importPath": "protobuf.Lib._pyio",
        "description": "protobuf.Lib._pyio",
        "peekOfCode": "def open(file, mode=\"r\", buffering=-1, encoding=None, errors=None,\n         newline=None, closefd=True, opener=None):\n    r\"\"\"Open file and return a stream.  Raise OSError upon failure.\n    file is either a text or byte string giving the name (and the path\n    if the file isn't in the current working directory) of the file to\n    be opened or an integer file descriptor of the file to be\n    wrapped. (If a file descriptor is given, it is closed when the\n    returned I/O object is closed, unless closefd is set to False.)\n    mode is an optional string that specifies the mode in which the file is\n    opened. It defaults to 'r' which means open for reading in text mode. Other",
        "detail": "protobuf.Lib._pyio",
        "documentation": {}
    },
    {
        "label": "valid_seek_flags",
        "kind": 5,
        "importPath": "protobuf.Lib._pyio",
        "description": "protobuf.Lib._pyio",
        "peekOfCode": "valid_seek_flags = {0, 1, 2}  # Hardwired values\nif hasattr(os, 'SEEK_HOLE') :\n    valid_seek_flags.add(os.SEEK_HOLE)\n    valid_seek_flags.add(os.SEEK_DATA)\n# open() uses st_blksize whenever we can\nDEFAULT_BUFFER_SIZE = 8 * 1024  # bytes\n# NOTE: Base classes defined here are registered with the \"official\" ABCs\n# defined in io.py. We don't use real inheritance though, because we don't want\n# to inherit the C implementations.\n# Rebind for compatibility",
        "detail": "protobuf.Lib._pyio",
        "documentation": {}
    },
    {
        "label": "DEFAULT_BUFFER_SIZE",
        "kind": 5,
        "importPath": "protobuf.Lib._pyio",
        "description": "protobuf.Lib._pyio",
        "peekOfCode": "DEFAULT_BUFFER_SIZE = 8 * 1024  # bytes\n# NOTE: Base classes defined here are registered with the \"official\" ABCs\n# defined in io.py. We don't use real inheritance though, because we don't want\n# to inherit the C implementations.\n# Rebind for compatibility\nBlockingIOError = BlockingIOError\n# Does io.IOBase finalizer log the exception if the close() method fails?\n# The exception is ignored silently by default in release build.\n_IOBASE_EMITS_UNRAISABLE = (hasattr(sys, \"gettotalrefcount\") or sys.flags.dev_mode)\n# Does open() check its 'errors' argument?",
        "detail": "protobuf.Lib._pyio",
        "documentation": {}
    },
    {
        "label": "BlockingIOError",
        "kind": 5,
        "importPath": "protobuf.Lib._pyio",
        "description": "protobuf.Lib._pyio",
        "peekOfCode": "BlockingIOError = BlockingIOError\n# Does io.IOBase finalizer log the exception if the close() method fails?\n# The exception is ignored silently by default in release build.\n_IOBASE_EMITS_UNRAISABLE = (hasattr(sys, \"gettotalrefcount\") or sys.flags.dev_mode)\n# Does open() check its 'errors' argument?\n_CHECK_ERRORS = _IOBASE_EMITS_UNRAISABLE\ndef text_encoding(encoding, stacklevel=2):\n    \"\"\"\n    A helper function to choose the text encoding.\n    When encoding is not None, just return it.",
        "detail": "protobuf.Lib._pyio",
        "documentation": {}
    },
    {
        "label": "_IOBASE_EMITS_UNRAISABLE",
        "kind": 5,
        "importPath": "protobuf.Lib._pyio",
        "description": "protobuf.Lib._pyio",
        "peekOfCode": "_IOBASE_EMITS_UNRAISABLE = (hasattr(sys, \"gettotalrefcount\") or sys.flags.dev_mode)\n# Does open() check its 'errors' argument?\n_CHECK_ERRORS = _IOBASE_EMITS_UNRAISABLE\ndef text_encoding(encoding, stacklevel=2):\n    \"\"\"\n    A helper function to choose the text encoding.\n    When encoding is not None, just return it.\n    Otherwise, return the default text encoding (i.e. \"locale\").\n    This function emits an EncodingWarning if *encoding* is None and\n    sys.flags.warn_default_encoding is true.",
        "detail": "protobuf.Lib._pyio",
        "documentation": {}
    },
    {
        "label": "_CHECK_ERRORS",
        "kind": 5,
        "importPath": "protobuf.Lib._pyio",
        "description": "protobuf.Lib._pyio",
        "peekOfCode": "_CHECK_ERRORS = _IOBASE_EMITS_UNRAISABLE\ndef text_encoding(encoding, stacklevel=2):\n    \"\"\"\n    A helper function to choose the text encoding.\n    When encoding is not None, just return it.\n    Otherwise, return the default text encoding (i.e. \"locale\").\n    This function emits an EncodingWarning if *encoding* is None and\n    sys.flags.warn_default_encoding is true.\n    This can be used in APIs with an encoding=None parameter\n    that pass it to TextIOWrapper or open.",
        "detail": "protobuf.Lib._pyio",
        "documentation": {}
    },
    {
        "label": "ABCMeta",
        "kind": 6,
        "importPath": "protobuf.Lib._py_abc",
        "description": "protobuf.Lib._py_abc",
        "peekOfCode": "class ABCMeta(type):\n    \"\"\"Metaclass for defining Abstract Base Classes (ABCs).\n    Use this metaclass to create an ABC.  An ABC can be subclassed\n    directly, and then acts as a mix-in class.  You can also register\n    unrelated concrete classes (even built-in classes) and unrelated\n    ABCs as 'virtual subclasses' -- these and their descendants will\n    be considered subclasses of the registering ABC by the built-in\n    issubclass() function, but the registering ABC won't show up in\n    their MRO (Method Resolution Order) nor will method\n    implementations defined by the registering ABC be callable (not",
        "detail": "protobuf.Lib._py_abc",
        "documentation": {}
    },
    {
        "label": "get_cache_token",
        "kind": 2,
        "importPath": "protobuf.Lib._py_abc",
        "description": "protobuf.Lib._py_abc",
        "peekOfCode": "def get_cache_token():\n    \"\"\"Returns the current ABC cache token.\n    The token is an opaque object (supporting equality testing) identifying the\n    current version of the ABC cache for virtual subclasses. The token changes\n    with every call to ``register()`` on any ABC.\n    \"\"\"\n    return ABCMeta._abc_invalidation_counter\nclass ABCMeta(type):\n    \"\"\"Metaclass for defining Abstract Base Classes (ABCs).\n    Use this metaclass to create an ABC.  An ABC can be subclassed",
        "detail": "protobuf.Lib._py_abc",
        "documentation": {}
    },
    {
        "label": "Quitter",
        "kind": 6,
        "importPath": "protobuf.Lib._sitebuiltins",
        "description": "protobuf.Lib._sitebuiltins",
        "peekOfCode": "class Quitter(object):\n    def __init__(self, name, eof):\n        self.name = name\n        self.eof = eof\n    def __repr__(self):\n        return 'Use %s() or %s to exit' % (self.name, self.eof)\n    def __call__(self, code=None):\n        # Shells like IDLE catch the SystemExit, but listen when their\n        # stdin wrapper is closed.\n        try:",
        "detail": "protobuf.Lib._sitebuiltins",
        "documentation": {}
    },
    {
        "label": "_Printer",
        "kind": 6,
        "importPath": "protobuf.Lib._sitebuiltins",
        "description": "protobuf.Lib._sitebuiltins",
        "peekOfCode": "class _Printer(object):\n    \"\"\"interactive prompt objects for printing the license text, a list of\n    contributors and the copyright notice.\"\"\"\n    MAXLINES = 23\n    def __init__(self, name, data, files=(), dirs=()):\n        import os\n        self.__name = name\n        self.__data = data\n        self.__lines = None\n        self.__filenames = [os.path.join(dir, filename)",
        "detail": "protobuf.Lib._sitebuiltins",
        "documentation": {}
    },
    {
        "label": "_Helper",
        "kind": 6,
        "importPath": "protobuf.Lib._sitebuiltins",
        "description": "protobuf.Lib._sitebuiltins",
        "peekOfCode": "class _Helper(object):\n    \"\"\"Define the builtin 'help'.\n    This is a wrapper around pydoc.help that provides a helpful message\n    when 'help' is typed at the Python interactive prompt.\n    Calling help() at the Python prompt starts an interactive help session.\n    Calling help(thing) prints help for the python object 'thing'.\n    \"\"\"\n    def __repr__(self):\n        return \"Type help() for interactive help, \" \\\n               \"or help(object) for help about object.\"",
        "detail": "protobuf.Lib._sitebuiltins",
        "documentation": {}
    },
    {
        "label": "LocaleTime",
        "kind": 6,
        "importPath": "protobuf.Lib._strptime",
        "description": "protobuf.Lib._strptime",
        "peekOfCode": "class LocaleTime(object):\n    \"\"\"Stores and handles locale-specific information related to time.\n    ATTRIBUTES:\n        f_weekday -- full weekday names (7-item list)\n        a_weekday -- abbreviated weekday names (7-item list)\n        f_month -- full month names (13-item list; dummy value in [0], which\n                    is added by code)\n        a_month -- abbreviated month names (13-item list, dummy value in\n                    [0], which is added by code)\n        am_pm -- AM/PM representation (2-item list)",
        "detail": "protobuf.Lib._strptime",
        "documentation": {}
    },
    {
        "label": "TimeRE",
        "kind": 6,
        "importPath": "protobuf.Lib._strptime",
        "description": "protobuf.Lib._strptime",
        "peekOfCode": "class TimeRE(dict):\n    \"\"\"Handle conversion from format directives to regexes.\"\"\"\n    def __init__(self, locale_time=None):\n        \"\"\"Create keys/values.\n        Order of execution is important for dependency reasons.\n        \"\"\"\n        if locale_time:\n            self.locale_time = locale_time\n        else:\n            self.locale_time = LocaleTime()",
        "detail": "protobuf.Lib._strptime",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib._strptime",
        "description": "protobuf.Lib._strptime",
        "peekOfCode": "__all__ = []\ndef _getlang():\n    # Figure out what the current language is set to.\n    return locale.getlocale(locale.LC_TIME)\nclass LocaleTime(object):\n    \"\"\"Stores and handles locale-specific information related to time.\n    ATTRIBUTES:\n        f_weekday -- full weekday names (7-item list)\n        a_weekday -- abbreviated weekday names (7-item list)\n        f_month -- full month names (13-item list; dummy value in [0], which",
        "detail": "protobuf.Lib._strptime",
        "documentation": {}
    },
    {
        "label": "_cache_lock",
        "kind": 5,
        "importPath": "protobuf.Lib._strptime",
        "description": "protobuf.Lib._strptime",
        "peekOfCode": "_cache_lock = _thread_allocate_lock()\n# DO NOT modify _TimeRE_cache or _regex_cache without acquiring the cache lock\n# first!\n_TimeRE_cache = TimeRE()\n_CACHE_MAX_SIZE = 5 # Max number of regexes stored in _regex_cache\n_regex_cache = {}\ndef _calc_julian_from_U_or_W(year, week_of_year, day_of_week, week_starts_Mon):\n    \"\"\"Calculate the Julian day based on the year, week of the year, and day of\n    the week, with week_start_day representing whether the week of the year\n    assumes the week starts on Sunday or Monday (6 or 0).\"\"\"",
        "detail": "protobuf.Lib._strptime",
        "documentation": {}
    },
    {
        "label": "_TimeRE_cache",
        "kind": 5,
        "importPath": "protobuf.Lib._strptime",
        "description": "protobuf.Lib._strptime",
        "peekOfCode": "_TimeRE_cache = TimeRE()\n_CACHE_MAX_SIZE = 5 # Max number of regexes stored in _regex_cache\n_regex_cache = {}\ndef _calc_julian_from_U_or_W(year, week_of_year, day_of_week, week_starts_Mon):\n    \"\"\"Calculate the Julian day based on the year, week of the year, and day of\n    the week, with week_start_day representing whether the week of the year\n    assumes the week starts on Sunday or Monday (6 or 0).\"\"\"\n    first_weekday = datetime_date(year, 1, 1).weekday()\n    # If we are dealing with the %U directive (week starts on Sunday), it's\n    # easier to just shift the view to Sunday being the first day of the",
        "detail": "protobuf.Lib._strptime",
        "documentation": {}
    },
    {
        "label": "_CACHE_MAX_SIZE",
        "kind": 5,
        "importPath": "protobuf.Lib._strptime",
        "description": "protobuf.Lib._strptime",
        "peekOfCode": "_CACHE_MAX_SIZE = 5 # Max number of regexes stored in _regex_cache\n_regex_cache = {}\ndef _calc_julian_from_U_or_W(year, week_of_year, day_of_week, week_starts_Mon):\n    \"\"\"Calculate the Julian day based on the year, week of the year, and day of\n    the week, with week_start_day representing whether the week of the year\n    assumes the week starts on Sunday or Monday (6 or 0).\"\"\"\n    first_weekday = datetime_date(year, 1, 1).weekday()\n    # If we are dealing with the %U directive (week starts on Sunday), it's\n    # easier to just shift the view to Sunday being the first day of the\n    # week.",
        "detail": "protobuf.Lib._strptime",
        "documentation": {}
    },
    {
        "label": "_regex_cache",
        "kind": 5,
        "importPath": "protobuf.Lib._strptime",
        "description": "protobuf.Lib._strptime",
        "peekOfCode": "_regex_cache = {}\ndef _calc_julian_from_U_or_W(year, week_of_year, day_of_week, week_starts_Mon):\n    \"\"\"Calculate the Julian day based on the year, week of the year, and day of\n    the week, with week_start_day representing whether the week of the year\n    assumes the week starts on Sunday or Monday (6 or 0).\"\"\"\n    first_weekday = datetime_date(year, 1, 1).weekday()\n    # If we are dealing with the %U directive (week starts on Sunday), it's\n    # easier to just shift the view to Sunday being the first day of the\n    # week.\n    if not week_starts_Mon:",
        "detail": "protobuf.Lib._strptime",
        "documentation": {}
    },
    {
        "label": "_localimpl",
        "kind": 6,
        "importPath": "protobuf.Lib._threading_local",
        "description": "protobuf.Lib._threading_local",
        "peekOfCode": "class _localimpl:\n    \"\"\"A class managing thread-local dicts\"\"\"\n    __slots__ = 'key', 'dicts', 'localargs', 'locallock', '__weakref__'\n    def __init__(self):\n        # The key used in the Thread objects' attribute dicts.\n        # We keep it a string for speed but make it unlikely to clash with\n        # a \"real\" attribute.\n        self.key = '_threading_local._localimpl.' + str(id(self))\n        # { id(Thread) -> (ref(Thread), thread-local dict) }\n        self.dicts = {}",
        "detail": "protobuf.Lib._threading_local",
        "documentation": {}
    },
    {
        "label": "local",
        "kind": 6,
        "importPath": "protobuf.Lib._threading_local",
        "description": "protobuf.Lib._threading_local",
        "peekOfCode": "class local:\n    __slots__ = '_local__impl', '__dict__'\n    def __new__(cls, /, *args, **kw):\n        if (args or kw) and (cls.__init__ is object.__init__):\n            raise TypeError(\"Initialization arguments are not supported\")\n        self = object.__new__(cls)\n        impl = _localimpl()\n        impl.localargs = (args, kw)\n        impl.locallock = RLock()\n        object.__setattr__(self, '_local__impl', impl)",
        "detail": "protobuf.Lib._threading_local",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib._threading_local",
        "description": "protobuf.Lib._threading_local",
        "peekOfCode": "__all__ = [\"local\"]\n# We need to use objects from the threading module, but the threading\n# module may also want to use our `local` class, if support for locals\n# isn't compiled in to the `thread` module.  This creates potential problems\n# with circular imports.  For that reason, we don't import `threading`\n# until the bottom of this file (a hack sufficient to worm around the\n# potential problems).  Note that all platforms on CPython do have support\n# for locals in the `thread` module, and there is no circular import problem\n# then, so problems introduced by fiddling the order of imports here won't\n# manifest.",
        "detail": "protobuf.Lib._threading_local",
        "documentation": {}
    },
    {
        "label": "_IterationGuard",
        "kind": 6,
        "importPath": "protobuf.Lib._weakrefset",
        "description": "protobuf.Lib._weakrefset",
        "peekOfCode": "class _IterationGuard:\n    # This context manager registers itself in the current iterators of the\n    # weak container, such as to delay all removals until the context manager\n    # exits.\n    # This technique should be relatively thread-safe (since sets are).\n    def __init__(self, weakcontainer):\n        # Don't create cycles\n        self.weakcontainer = ref(weakcontainer)\n    def __enter__(self):\n        w = self.weakcontainer()",
        "detail": "protobuf.Lib._weakrefset",
        "documentation": {}
    },
    {
        "label": "WeakSet",
        "kind": 6,
        "importPath": "protobuf.Lib._weakrefset",
        "description": "protobuf.Lib._weakrefset",
        "peekOfCode": "class WeakSet:\n    def __init__(self, data=None):\n        self.data = set()\n        def _remove(item, selfref=ref(self)):\n            self = selfref()\n            if self is not None:\n                if self._iterating:\n                    self._pending_removals.append(item)\n                else:\n                    self.data.discard(item)",
        "detail": "protobuf.Lib._weakrefset",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "protobuf.Lib._weakrefset",
        "description": "protobuf.Lib._weakrefset",
        "peekOfCode": "__all__ = ['WeakSet']\nclass _IterationGuard:\n    # This context manager registers itself in the current iterators of the\n    # weak container, such as to delay all removals until the context manager\n    # exits.\n    # This technique should be relatively thread-safe (since sets are).\n    def __init__(self, weakcontainer):\n        # Don't create cycles\n        self.weakcontainer = ref(weakcontainer)\n    def __enter__(self):",
        "detail": "protobuf.Lib._weakrefset",
        "documentation": {}
    },
    {
        "label": "get_gemini_response",
        "kind": 2,
        "importPath": "SQL + Gemini.app",
        "description": "SQL + Gemini.app",
        "peekOfCode": "def get_gemini_response(question, prompt):\n    model = genai.GenerativeModel('gemini-pro')\n    response = model.generate_content([prompt[0], question])\n    return response.text\n## Function to retrieve query from sql database \ndef read_sql_query(sql, db):\n    conn = sqlite3.connect(db)\n    cur = conn.cursor()\n    cur.execute(sql)\n    rows = cur.fetchall()",
        "detail": "SQL + Gemini.app",
        "documentation": {}
    },
    {
        "label": "read_sql_query",
        "kind": 2,
        "importPath": "SQL + Gemini.app",
        "description": "SQL + Gemini.app",
        "peekOfCode": "def read_sql_query(sql, db):\n    conn = sqlite3.connect(db)\n    cur = conn.cursor()\n    cur.execute(sql)\n    rows = cur.fetchall()\n    conn.commit()\n    conn.close()\n    return rows\n## Define my prompt\nprompt =[",
        "detail": "SQL + Gemini.app",
        "documentation": {}
    },
    {
        "label": "connection",
        "kind": 5,
        "importPath": "SQL + Gemini.sql",
        "description": "SQL + Gemini.sql",
        "peekOfCode": "connection = sqlite3.connect(\"student.db\")\n## Create a cursor to insert record, create and stuff\ncursor = connection.cursor()\n## creating the table\ntable_info = \"\"\"\nCreate table STUDENT(NAME VARCHAR(25), CLASS VARCHAR(25), \nSECTION VARCHAR(25), MARKS INT);\n\"\"\"\ncursor.execute(table_info)\n## Insert some records",
        "detail": "SQL + Gemini.sql",
        "documentation": {}
    },
    {
        "label": "cursor",
        "kind": 5,
        "importPath": "SQL + Gemini.sql",
        "description": "SQL + Gemini.sql",
        "peekOfCode": "cursor = connection.cursor()\n## creating the table\ntable_info = \"\"\"\nCreate table STUDENT(NAME VARCHAR(25), CLASS VARCHAR(25), \nSECTION VARCHAR(25), MARKS INT);\n\"\"\"\ncursor.execute(table_info)\n## Insert some records\ncursor.execute('''INSERT INTO STUDENT (NAME, CLASS, SECTION, MARKS)\nVALUES ('John Doe', '10th', 'A', 85),",
        "detail": "SQL + Gemini.sql",
        "documentation": {}
    },
    {
        "label": "table_info",
        "kind": 5,
        "importPath": "SQL + Gemini.sql",
        "description": "SQL + Gemini.sql",
        "peekOfCode": "table_info = \"\"\"\nCreate table STUDENT(NAME VARCHAR(25), CLASS VARCHAR(25), \nSECTION VARCHAR(25), MARKS INT);\n\"\"\"\ncursor.execute(table_info)\n## Insert some records\ncursor.execute('''INSERT INTO STUDENT (NAME, CLASS, SECTION, MARKS)\nVALUES ('John Doe', '10th', 'A', 85),\n    ('Jane Smith', '9th', 'B', 92),\n    ('Mike Johnson', '11th', 'C', 78);",
        "detail": "SQL + Gemini.sql",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "SQL + Gemini.sql",
        "description": "SQL + Gemini.sql",
        "peekOfCode": "data = cursor.execute('''SELECT * from STUDENT''')\nprint(f\"The inserted records are : {[row for row in data]}\")\n## Close the connection\nconnection.commit()\nconnection.close()",
        "detail": "SQL + Gemini.sql",
        "documentation": {}
    },
    {
        "label": "get_gemini_response",
        "kind": 2,
        "importPath": "Vision Application.app",
        "description": "Vision Application.app",
        "peekOfCode": "def get_gemini_response(input_text, image):\n    '''\n    This function will load the Gemini model and get responses\n    '''\n    if input_text:\n        response = model.generate_content([input_text, image])\n    else:\n        response = model.generate_content(image)\n    if response and response.parts:\n        return response.parts[0].text",
        "detail": "Vision Application.app",
        "documentation": {}
    },
    {
        "label": "stream_response",
        "kind": 2,
        "importPath": "Vision Application.app",
        "description": "Vision Application.app",
        "peekOfCode": "def stream_response(response_text, chunk_size=14):\n    placeholder = st.empty()\n    words = response_text.split()\n    chunks = [\" \".join(words[i:i + chunk_size]) for i in range(0, len(words), chunk_size)]\n    text = \"\"\n    for chunk in chunks:\n        for letter in chunk:\n            text += letter\n            placeholder.text(text)\n            time.sleep(0.01)  # Adjust the speed of letter streaming here",
        "detail": "Vision Application.app",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "Vision Application.app",
        "description": "Vision Application.app",
        "peekOfCode": "model = genai.GenerativeModel(\"gemini-1.5-flash\")\n# Using Gemini API to get a response\ndef get_gemini_response(input_text, image):\n    '''\n    This function will load the Gemini model and get responses\n    '''\n    if input_text:\n        response = model.generate_content([input_text, image])\n    else:\n        response = model.generate_content(image)",
        "detail": "Vision Application.app",
        "documentation": {}
    },
    {
        "label": "uploaded_file",
        "kind": 5,
        "importPath": "Vision Application.app",
        "description": "Vision Application.app",
        "peekOfCode": "uploaded_file = st.file_uploader(\"Upload Image\", type=[\"jpg\", \"jpeg\", \"png\"])\nimage = None\nif uploaded_file:\n    image = Image.open(uploaded_file)\n    st.image(image, caption='Uploaded Image.', use_column_width=True)\nsubmit = st.button(\"Tell me about the image\")\n# When submit is clicked\nif submit:\n    with st.spinner('Generating response...'):\n        response = get_gemini_response(input_text, image)",
        "detail": "Vision Application.app",
        "documentation": {}
    },
    {
        "label": "image",
        "kind": 5,
        "importPath": "Vision Application.app",
        "description": "Vision Application.app",
        "peekOfCode": "image = None\nif uploaded_file:\n    image = Image.open(uploaded_file)\n    st.image(image, caption='Uploaded Image.', use_column_width=True)\nsubmit = st.button(\"Tell me about the image\")\n# When submit is clicked\nif submit:\n    with st.spinner('Generating response...'):\n        response = get_gemini_response(input_text, image)\n    st.header(\"The response to your question is: \")",
        "detail": "Vision Application.app",
        "documentation": {}
    },
    {
        "label": "submit",
        "kind": 5,
        "importPath": "Vision Application.app",
        "description": "Vision Application.app",
        "peekOfCode": "submit = st.button(\"Tell me about the image\")\n# When submit is clicked\nif submit:\n    with st.spinner('Generating response...'):\n        response = get_gemini_response(input_text, image)\n    st.header(\"The response to your question is: \")\n    stream_response(response)",
        "detail": "Vision Application.app",
        "documentation": {}
    },
    {
        "label": "get_gemini_response",
        "kind": 2,
        "importPath": "Youtube Transcribe.app",
        "description": "Youtube Transcribe.app",
        "peekOfCode": "def get_gemini_response(prompt, transcript):\n    model = genai.GenerativeModel(\"gemini-pro\")\n    response = model.generate_content(prompt + transcript)\n    if response and response.parts:\n        return response.parts[0].text\n    else:\n        return \"No response received.\"\ndef extract_details(url):\n    try:\n        video_id = url.split(\"=\")[1]",
        "detail": "Youtube Transcribe.app",
        "documentation": {}
    },
    {
        "label": "extract_details",
        "kind": 2,
        "importPath": "Youtube Transcribe.app",
        "description": "Youtube Transcribe.app",
        "peekOfCode": "def extract_details(url):\n    try:\n        video_id = url.split(\"=\")[1]\n        transcript_text = YouTubeTranscriptApi.get_transcript(video_id=video_id)\n        transcript = \"\"\n        for i in transcript_text:\n            if len(transcript) < 1000:\n                transcript += \" \" + i[\"text\"]\n        return transcript\n    except Exception as e:",
        "detail": "Youtube Transcribe.app",
        "documentation": {}
    },
    {
        "label": "prompt",
        "kind": 5,
        "importPath": "Youtube Transcribe.app",
        "description": "Youtube Transcribe.app",
        "peekOfCode": "prompt = \"\"\"\nYou are an expert Youtube summarizer. You will be taking the transcript text and summarizing the entire video\nand provide the most important summaryu in points all within 250 words. Make it as informative as you can and \nshould give as much context from the transcript as you can. Here is the transcript text : \n\"\"\"\ndef get_gemini_response(prompt, transcript):\n    model = genai.GenerativeModel(\"gemini-pro\")\n    response = model.generate_content(prompt + transcript)\n    if response and response.parts:\n        return response.parts[0].text",
        "detail": "Youtube Transcribe.app",
        "documentation": {}
    },
    {
        "label": "url",
        "kind": 5,
        "importPath": "Youtube Transcribe.app",
        "description": "Youtube Transcribe.app",
        "peekOfCode": "url = st.text_input(\"Enter YouTube URL:\")\nif url:\n    video_id = url.split(\"=\")[1]\n    st.image(f\"http://img.youtube.com/vi/{video_id}/0.jpg\")\nif st.button(\"Summarize\"):\n    if url:\n        with st.spinner(\"Extracting transcript...\"):\n            try:\n                transcript = extract_details(url)\n                with st.spinner(\"Generating summary...\"):",
        "detail": "Youtube Transcribe.app",
        "documentation": {}
    },
    {
        "label": "get_gemini_response",
        "kind": 2,
        "importPath": "trial",
        "description": "trial",
        "peekOfCode": "def get_gemini_response(prompt):\n    model = genai.GenerativeModel(\"gemini-1.5-pro\")\n    response = model.generate_content([prompt])\n    return response.text\nprompt = input(\"Enter your prompt: \")\nresponse = get_gemini_response(prompt)\nprint(\"Response from Gemini:\", response)",
        "detail": "trial",
        "documentation": {}
    },
    {
        "label": "prompt",
        "kind": 5,
        "importPath": "trial",
        "description": "trial",
        "peekOfCode": "prompt = input(\"Enter your prompt: \")\nresponse = get_gemini_response(prompt)\nprint(\"Response from Gemini:\", response)",
        "detail": "trial",
        "documentation": {}
    },
    {
        "label": "response",
        "kind": 5,
        "importPath": "trial",
        "description": "trial",
        "peekOfCode": "response = get_gemini_response(prompt)\nprint(\"Response from Gemini:\", response)",
        "detail": "trial",
        "documentation": {}
    }
]